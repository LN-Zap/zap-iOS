//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: rpc.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import Foundation
import Dispatch
import SwiftGRPC
import SwiftProtobuf

internal protocol Lnrpc_WalletUnlockerGenSeedCall: ClientCallUnary {}

fileprivate final class Lnrpc_WalletUnlockerGenSeedCallBase: ClientCallUnaryBase<Lnrpc_GenSeedRequest, Lnrpc_GenSeedResponse>, Lnrpc_WalletUnlockerGenSeedCall {
  override class var method: String { return "/lnrpc.WalletUnlocker/GenSeed" }
}

internal protocol Lnrpc_WalletUnlockerInitWalletCall: ClientCallUnary {}

fileprivate final class Lnrpc_WalletUnlockerInitWalletCallBase: ClientCallUnaryBase<Lnrpc_InitWalletRequest, Lnrpc_InitWalletResponse>, Lnrpc_WalletUnlockerInitWalletCall {
  override class var method: String { return "/lnrpc.WalletUnlocker/InitWallet" }
}

internal protocol Lnrpc_WalletUnlockerUnlockWalletCall: ClientCallUnary {}

fileprivate final class Lnrpc_WalletUnlockerUnlockWalletCallBase: ClientCallUnaryBase<Lnrpc_UnlockWalletRequest, Lnrpc_UnlockWalletResponse>, Lnrpc_WalletUnlockerUnlockWalletCall {
  override class var method: String { return "/lnrpc.WalletUnlocker/UnlockWallet" }
}

internal protocol Lnrpc_WalletUnlockerChangePasswordCall: ClientCallUnary {}

fileprivate final class Lnrpc_WalletUnlockerChangePasswordCallBase: ClientCallUnaryBase<Lnrpc_ChangePasswordRequest, Lnrpc_ChangePasswordResponse>, Lnrpc_WalletUnlockerChangePasswordCall {
  override class var method: String { return "/lnrpc.WalletUnlocker/ChangePassword" }
}


/// Instantiate Lnrpc_WalletUnlockerServiceClient, then call methods of this protocol to make API calls.
internal protocol Lnrpc_WalletUnlockerService: ServiceClient {
  /// Synchronous. Unary.
  func genSeed(_ request: Lnrpc_GenSeedRequest) throws -> Lnrpc_GenSeedResponse
  /// Asynchronous. Unary.
  func genSeed(_ request: Lnrpc_GenSeedRequest, completion: @escaping (Lnrpc_GenSeedResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerGenSeedCall

  /// Synchronous. Unary.
  func initWallet(_ request: Lnrpc_InitWalletRequest) throws -> Lnrpc_InitWalletResponse
  /// Asynchronous. Unary.
  func initWallet(_ request: Lnrpc_InitWalletRequest, completion: @escaping (Lnrpc_InitWalletResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerInitWalletCall

  /// Synchronous. Unary.
  func unlockWallet(_ request: Lnrpc_UnlockWalletRequest) throws -> Lnrpc_UnlockWalletResponse
  /// Asynchronous. Unary.
  func unlockWallet(_ request: Lnrpc_UnlockWalletRequest, completion: @escaping (Lnrpc_UnlockWalletResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerUnlockWalletCall

  /// Synchronous. Unary.
  func changePassword(_ request: Lnrpc_ChangePasswordRequest) throws -> Lnrpc_ChangePasswordResponse
  /// Asynchronous. Unary.
  func changePassword(_ request: Lnrpc_ChangePasswordRequest, completion: @escaping (Lnrpc_ChangePasswordResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerChangePasswordCall

}

internal final class Lnrpc_WalletUnlockerServiceClient: ServiceClientBase, Lnrpc_WalletUnlockerService {
  /// Synchronous. Unary.
  internal func genSeed(_ request: Lnrpc_GenSeedRequest) throws -> Lnrpc_GenSeedResponse {
    return try Lnrpc_WalletUnlockerGenSeedCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func genSeed(_ request: Lnrpc_GenSeedRequest, completion: @escaping (Lnrpc_GenSeedResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerGenSeedCall {
    return try Lnrpc_WalletUnlockerGenSeedCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func initWallet(_ request: Lnrpc_InitWalletRequest) throws -> Lnrpc_InitWalletResponse {
    return try Lnrpc_WalletUnlockerInitWalletCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func initWallet(_ request: Lnrpc_InitWalletRequest, completion: @escaping (Lnrpc_InitWalletResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerInitWalletCall {
    return try Lnrpc_WalletUnlockerInitWalletCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func unlockWallet(_ request: Lnrpc_UnlockWalletRequest) throws -> Lnrpc_UnlockWalletResponse {
    return try Lnrpc_WalletUnlockerUnlockWalletCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func unlockWallet(_ request: Lnrpc_UnlockWalletRequest, completion: @escaping (Lnrpc_UnlockWalletResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerUnlockWalletCall {
    return try Lnrpc_WalletUnlockerUnlockWalletCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func changePassword(_ request: Lnrpc_ChangePasswordRequest) throws -> Lnrpc_ChangePasswordResponse {
    return try Lnrpc_WalletUnlockerChangePasswordCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func changePassword(_ request: Lnrpc_ChangePasswordRequest, completion: @escaping (Lnrpc_ChangePasswordResponse?, CallResult) -> Void) throws -> Lnrpc_WalletUnlockerChangePasswordCall {
    return try Lnrpc_WalletUnlockerChangePasswordCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

}
internal protocol Lnrpc_LightningWalletBalanceCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningWalletBalanceCallBase: ClientCallUnaryBase<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>, Lnrpc_LightningWalletBalanceCall {
  override class var method: String { return "/lnrpc.Lightning/WalletBalance" }
}

internal protocol Lnrpc_LightningChannelBalanceCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningChannelBalanceCallBase: ClientCallUnaryBase<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>, Lnrpc_LightningChannelBalanceCall {
  override class var method: String { return "/lnrpc.Lightning/ChannelBalance" }
}

internal protocol Lnrpc_LightningGetTransactionsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningGetTransactionsCallBase: ClientCallUnaryBase<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>, Lnrpc_LightningGetTransactionsCall {
  override class var method: String { return "/lnrpc.Lightning/GetTransactions" }
}

internal protocol Lnrpc_LightningSendCoinsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningSendCoinsCallBase: ClientCallUnaryBase<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>, Lnrpc_LightningSendCoinsCall {
  override class var method: String { return "/lnrpc.Lightning/SendCoins" }
}

internal protocol Lnrpc_LightningSubscribeTransactionsCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_Transaction?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_Transaction?>) -> Void) throws
}

internal extension Lnrpc_LightningSubscribeTransactionsCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_Transaction? { return try self._receive(timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeTransactionsCallBase: ClientCallServerStreamingBase<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>, Lnrpc_LightningSubscribeTransactionsCall {
  override class var method: String { return "/lnrpc.Lightning/SubscribeTransactions" }
}

internal protocol Lnrpc_LightningSendManyCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningSendManyCallBase: ClientCallUnaryBase<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>, Lnrpc_LightningSendManyCall {
  override class var method: String { return "/lnrpc.Lightning/SendMany" }
}

internal protocol Lnrpc_LightningNewAddressCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningNewAddressCallBase: ClientCallUnaryBase<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>, Lnrpc_LightningNewAddressCall {
  override class var method: String { return "/lnrpc.Lightning/NewAddress" }
}

internal protocol Lnrpc_LightningSignMessageCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningSignMessageCallBase: ClientCallUnaryBase<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>, Lnrpc_LightningSignMessageCall {
  override class var method: String { return "/lnrpc.Lightning/SignMessage" }
}

internal protocol Lnrpc_LightningVerifyMessageCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningVerifyMessageCallBase: ClientCallUnaryBase<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>, Lnrpc_LightningVerifyMessageCall {
  override class var method: String { return "/lnrpc.Lightning/VerifyMessage" }
}

internal protocol Lnrpc_LightningConnectPeerCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningConnectPeerCallBase: ClientCallUnaryBase<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>, Lnrpc_LightningConnectPeerCall {
  override class var method: String { return "/lnrpc.Lightning/ConnectPeer" }
}

internal protocol Lnrpc_LightningDisconnectPeerCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningDisconnectPeerCallBase: ClientCallUnaryBase<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>, Lnrpc_LightningDisconnectPeerCall {
  override class var method: String { return "/lnrpc.Lightning/DisconnectPeer" }
}

internal protocol Lnrpc_LightningListPeersCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningListPeersCallBase: ClientCallUnaryBase<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>, Lnrpc_LightningListPeersCall {
  override class var method: String { return "/lnrpc.Lightning/ListPeers" }
}

internal protocol Lnrpc_LightningGetInfoCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningGetInfoCallBase: ClientCallUnaryBase<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>, Lnrpc_LightningGetInfoCall {
  override class var method: String { return "/lnrpc.Lightning/GetInfo" }
}

internal protocol Lnrpc_LightningPendingChannelsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningPendingChannelsCallBase: ClientCallUnaryBase<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>, Lnrpc_LightningPendingChannelsCall {
  override class var method: String { return "/lnrpc.Lightning/PendingChannels" }
}

internal protocol Lnrpc_LightningListChannelsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningListChannelsCallBase: ClientCallUnaryBase<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>, Lnrpc_LightningListChannelsCall {
  override class var method: String { return "/lnrpc.Lightning/ListChannels" }
}

internal protocol Lnrpc_LightningClosedChannelsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningClosedChannelsCallBase: ClientCallUnaryBase<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>, Lnrpc_LightningClosedChannelsCall {
  override class var method: String { return "/lnrpc.Lightning/ClosedChannels" }
}

internal protocol Lnrpc_LightningOpenChannelSyncCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningOpenChannelSyncCallBase: ClientCallUnaryBase<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>, Lnrpc_LightningOpenChannelSyncCall {
  override class var method: String { return "/lnrpc.Lightning/OpenChannelSync" }
}

internal protocol Lnrpc_LightningOpenChannelCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_OpenStatusUpdate?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_OpenStatusUpdate?>) -> Void) throws
}

internal extension Lnrpc_LightningOpenChannelCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_OpenStatusUpdate? { return try self._receive(timeout: timeout) }
}

fileprivate final class Lnrpc_LightningOpenChannelCallBase: ClientCallServerStreamingBase<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>, Lnrpc_LightningOpenChannelCall {
  override class var method: String { return "/lnrpc.Lightning/OpenChannel" }
}

internal protocol Lnrpc_LightningCloseChannelCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_CloseStatusUpdate?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_CloseStatusUpdate?>) -> Void) throws
}

internal extension Lnrpc_LightningCloseChannelCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_CloseStatusUpdate? { return try self._receive(timeout: timeout) }
}

fileprivate final class Lnrpc_LightningCloseChannelCallBase: ClientCallServerStreamingBase<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>, Lnrpc_LightningCloseChannelCall {
  override class var method: String { return "/lnrpc.Lightning/CloseChannel" }
}

internal protocol Lnrpc_LightningAbandonChannelCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningAbandonChannelCallBase: ClientCallUnaryBase<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>, Lnrpc_LightningAbandonChannelCall {
  override class var method: String { return "/lnrpc.Lightning/AbandonChannel" }
}

internal protocol Lnrpc_LightningSendPaymentCall: ClientCallBidirectionalStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_SendResponse?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_SendResponse?>) -> Void) throws

  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_SendRequest, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_SendRequest, timeout: DispatchTime) throws

  /// Call this to close the sending connection. Blocking.
  func closeSend() throws
  /// Call this to close the sending connection. Nonblocking.
  func closeSend(completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSendPaymentCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_SendResponse? { return try self._receive(timeout: timeout) }
}

internal extension Lnrpc_LightningSendPaymentCall {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_SendRequest, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSendPaymentCallBase: ClientCallBidirectionalStreamingBase<Lnrpc_SendRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendPaymentCall {
  override class var method: String { return "/lnrpc.Lightning/SendPayment" }
}

internal protocol Lnrpc_LightningSendPaymentSyncCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningSendPaymentSyncCallBase: ClientCallUnaryBase<Lnrpc_SendRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendPaymentSyncCall {
  override class var method: String { return "/lnrpc.Lightning/SendPaymentSync" }
}

internal protocol Lnrpc_LightningSendToRouteCall: ClientCallBidirectionalStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_SendResponse?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_SendResponse?>) -> Void) throws

  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_SendToRouteRequest, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_SendToRouteRequest, timeout: DispatchTime) throws

  /// Call this to close the sending connection. Blocking.
  func closeSend() throws
  /// Call this to close the sending connection. Nonblocking.
  func closeSend(completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSendToRouteCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_SendResponse? { return try self._receive(timeout: timeout) }
}

internal extension Lnrpc_LightningSendToRouteCall {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_SendToRouteRequest, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSendToRouteCallBase: ClientCallBidirectionalStreamingBase<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendToRouteCall {
  override class var method: String { return "/lnrpc.Lightning/SendToRoute" }
}

internal protocol Lnrpc_LightningSendToRouteSyncCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningSendToRouteSyncCallBase: ClientCallUnaryBase<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendToRouteSyncCall {
  override class var method: String { return "/lnrpc.Lightning/SendToRouteSync" }
}

internal protocol Lnrpc_LightningAddInvoiceCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningAddInvoiceCallBase: ClientCallUnaryBase<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>, Lnrpc_LightningAddInvoiceCall {
  override class var method: String { return "/lnrpc.Lightning/AddInvoice" }
}

internal protocol Lnrpc_LightningListInvoicesCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningListInvoicesCallBase: ClientCallUnaryBase<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>, Lnrpc_LightningListInvoicesCall {
  override class var method: String { return "/lnrpc.Lightning/ListInvoices" }
}

internal protocol Lnrpc_LightningLookupInvoiceCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningLookupInvoiceCallBase: ClientCallUnaryBase<Lnrpc_PaymentHash, Lnrpc_Invoice>, Lnrpc_LightningLookupInvoiceCall {
  override class var method: String { return "/lnrpc.Lightning/LookupInvoice" }
}

internal protocol Lnrpc_LightningSubscribeInvoicesCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_Invoice?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_Invoice?>) -> Void) throws
}

internal extension Lnrpc_LightningSubscribeInvoicesCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_Invoice? { return try self._receive(timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeInvoicesCallBase: ClientCallServerStreamingBase<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>, Lnrpc_LightningSubscribeInvoicesCall {
  override class var method: String { return "/lnrpc.Lightning/SubscribeInvoices" }
}

internal protocol Lnrpc_LightningDecodePayReqCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningDecodePayReqCallBase: ClientCallUnaryBase<Lnrpc_PayReqString, Lnrpc_PayReq>, Lnrpc_LightningDecodePayReqCall {
  override class var method: String { return "/lnrpc.Lightning/DecodePayReq" }
}

internal protocol Lnrpc_LightningListPaymentsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningListPaymentsCallBase: ClientCallUnaryBase<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>, Lnrpc_LightningListPaymentsCall {
  override class var method: String { return "/lnrpc.Lightning/ListPayments" }
}

internal protocol Lnrpc_LightningDeleteAllPaymentsCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningDeleteAllPaymentsCallBase: ClientCallUnaryBase<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>, Lnrpc_LightningDeleteAllPaymentsCall {
  override class var method: String { return "/lnrpc.Lightning/DeleteAllPayments" }
}

internal protocol Lnrpc_LightningDescribeGraphCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningDescribeGraphCallBase: ClientCallUnaryBase<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>, Lnrpc_LightningDescribeGraphCall {
  override class var method: String { return "/lnrpc.Lightning/DescribeGraph" }
}

internal protocol Lnrpc_LightningGetChanInfoCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningGetChanInfoCallBase: ClientCallUnaryBase<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>, Lnrpc_LightningGetChanInfoCall {
  override class var method: String { return "/lnrpc.Lightning/GetChanInfo" }
}

internal protocol Lnrpc_LightningGetNodeInfoCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningGetNodeInfoCallBase: ClientCallUnaryBase<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>, Lnrpc_LightningGetNodeInfoCall {
  override class var method: String { return "/lnrpc.Lightning/GetNodeInfo" }
}

internal protocol Lnrpc_LightningQueryRoutesCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningQueryRoutesCallBase: ClientCallUnaryBase<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>, Lnrpc_LightningQueryRoutesCall {
  override class var method: String { return "/lnrpc.Lightning/QueryRoutes" }
}

internal protocol Lnrpc_LightningGetNetworkInfoCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningGetNetworkInfoCallBase: ClientCallUnaryBase<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>, Lnrpc_LightningGetNetworkInfoCall {
  override class var method: String { return "/lnrpc.Lightning/GetNetworkInfo" }
}

internal protocol Lnrpc_LightningStopDaemonCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningStopDaemonCallBase: ClientCallUnaryBase<Lnrpc_StopRequest, Lnrpc_StopResponse>, Lnrpc_LightningStopDaemonCall {
  override class var method: String { return "/lnrpc.Lightning/StopDaemon" }
}

internal protocol Lnrpc_LightningSubscribeChannelGraphCall: ClientCallServerStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_GraphTopologyUpdate?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_GraphTopologyUpdate?>) -> Void) throws
}

internal extension Lnrpc_LightningSubscribeChannelGraphCall {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_GraphTopologyUpdate? { return try self._receive(timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeChannelGraphCallBase: ClientCallServerStreamingBase<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>, Lnrpc_LightningSubscribeChannelGraphCall {
  override class var method: String { return "/lnrpc.Lightning/SubscribeChannelGraph" }
}

internal protocol Lnrpc_LightningDebugLevelCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningDebugLevelCallBase: ClientCallUnaryBase<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>, Lnrpc_LightningDebugLevelCall {
  override class var method: String { return "/lnrpc.Lightning/DebugLevel" }
}

internal protocol Lnrpc_LightningFeeReportCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningFeeReportCallBase: ClientCallUnaryBase<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>, Lnrpc_LightningFeeReportCall {
  override class var method: String { return "/lnrpc.Lightning/FeeReport" }
}

internal protocol Lnrpc_LightningUpdateChannelPolicyCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningUpdateChannelPolicyCallBase: ClientCallUnaryBase<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>, Lnrpc_LightningUpdateChannelPolicyCall {
  override class var method: String { return "/lnrpc.Lightning/UpdateChannelPolicy" }
}

internal protocol Lnrpc_LightningForwardingHistoryCall: ClientCallUnary {}

fileprivate final class Lnrpc_LightningForwardingHistoryCallBase: ClientCallUnaryBase<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>, Lnrpc_LightningForwardingHistoryCall {
  override class var method: String { return "/lnrpc.Lightning/ForwardingHistory" }
}


/// Instantiate Lnrpc_LightningServiceClient, then call methods of this protocol to make API calls.
internal protocol Lnrpc_LightningService: ServiceClient {
  /// Synchronous. Unary.
  func walletBalance(_ request: Lnrpc_WalletBalanceRequest) throws -> Lnrpc_WalletBalanceResponse
  /// Asynchronous. Unary.
  func walletBalance(_ request: Lnrpc_WalletBalanceRequest, completion: @escaping (Lnrpc_WalletBalanceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningWalletBalanceCall

  /// Synchronous. Unary.
  func channelBalance(_ request: Lnrpc_ChannelBalanceRequest) throws -> Lnrpc_ChannelBalanceResponse
  /// Asynchronous. Unary.
  func channelBalance(_ request: Lnrpc_ChannelBalanceRequest, completion: @escaping (Lnrpc_ChannelBalanceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningChannelBalanceCall

  /// Synchronous. Unary.
  func getTransactions(_ request: Lnrpc_GetTransactionsRequest) throws -> Lnrpc_TransactionDetails
  /// Asynchronous. Unary.
  func getTransactions(_ request: Lnrpc_GetTransactionsRequest, completion: @escaping (Lnrpc_TransactionDetails?, CallResult) -> Void) throws -> Lnrpc_LightningGetTransactionsCall

  /// Synchronous. Unary.
  func sendCoins(_ request: Lnrpc_SendCoinsRequest) throws -> Lnrpc_SendCoinsResponse
  /// Asynchronous. Unary.
  func sendCoins(_ request: Lnrpc_SendCoinsRequest, completion: @escaping (Lnrpc_SendCoinsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendCoinsCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func subscribeTransactions(_ request: Lnrpc_GetTransactionsRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeTransactionsCall

  /// Synchronous. Unary.
  func sendMany(_ request: Lnrpc_SendManyRequest) throws -> Lnrpc_SendManyResponse
  /// Asynchronous. Unary.
  func sendMany(_ request: Lnrpc_SendManyRequest, completion: @escaping (Lnrpc_SendManyResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendManyCall

  /// Synchronous. Unary.
  func newAddress(_ request: Lnrpc_NewAddressRequest) throws -> Lnrpc_NewAddressResponse
  /// Asynchronous. Unary.
  func newAddress(_ request: Lnrpc_NewAddressRequest, completion: @escaping (Lnrpc_NewAddressResponse?, CallResult) -> Void) throws -> Lnrpc_LightningNewAddressCall

  /// Synchronous. Unary.
  func signMessage(_ request: Lnrpc_SignMessageRequest) throws -> Lnrpc_SignMessageResponse
  /// Asynchronous. Unary.
  func signMessage(_ request: Lnrpc_SignMessageRequest, completion: @escaping (Lnrpc_SignMessageResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSignMessageCall

  /// Synchronous. Unary.
  func verifyMessage(_ request: Lnrpc_VerifyMessageRequest) throws -> Lnrpc_VerifyMessageResponse
  /// Asynchronous. Unary.
  func verifyMessage(_ request: Lnrpc_VerifyMessageRequest, completion: @escaping (Lnrpc_VerifyMessageResponse?, CallResult) -> Void) throws -> Lnrpc_LightningVerifyMessageCall

  /// Synchronous. Unary.
  func connectPeer(_ request: Lnrpc_ConnectPeerRequest) throws -> Lnrpc_ConnectPeerResponse
  /// Asynchronous. Unary.
  func connectPeer(_ request: Lnrpc_ConnectPeerRequest, completion: @escaping (Lnrpc_ConnectPeerResponse?, CallResult) -> Void) throws -> Lnrpc_LightningConnectPeerCall

  /// Synchronous. Unary.
  func disconnectPeer(_ request: Lnrpc_DisconnectPeerRequest) throws -> Lnrpc_DisconnectPeerResponse
  /// Asynchronous. Unary.
  func disconnectPeer(_ request: Lnrpc_DisconnectPeerRequest, completion: @escaping (Lnrpc_DisconnectPeerResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDisconnectPeerCall

  /// Synchronous. Unary.
  func listPeers(_ request: Lnrpc_ListPeersRequest) throws -> Lnrpc_ListPeersResponse
  /// Asynchronous. Unary.
  func listPeers(_ request: Lnrpc_ListPeersRequest, completion: @escaping (Lnrpc_ListPeersResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListPeersCall

  /// Synchronous. Unary.
  func getInfo(_ request: Lnrpc_GetInfoRequest) throws -> Lnrpc_GetInfoResponse
  /// Asynchronous. Unary.
  func getInfo(_ request: Lnrpc_GetInfoRequest, completion: @escaping (Lnrpc_GetInfoResponse?, CallResult) -> Void) throws -> Lnrpc_LightningGetInfoCall

  /// Synchronous. Unary.
  func pendingChannels(_ request: Lnrpc_PendingChannelsRequest) throws -> Lnrpc_PendingChannelsResponse
  /// Asynchronous. Unary.
  func pendingChannels(_ request: Lnrpc_PendingChannelsRequest, completion: @escaping (Lnrpc_PendingChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningPendingChannelsCall

  /// Synchronous. Unary.
  func listChannels(_ request: Lnrpc_ListChannelsRequest) throws -> Lnrpc_ListChannelsResponse
  /// Asynchronous. Unary.
  func listChannels(_ request: Lnrpc_ListChannelsRequest, completion: @escaping (Lnrpc_ListChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListChannelsCall

  /// Synchronous. Unary.
  func closedChannels(_ request: Lnrpc_ClosedChannelsRequest) throws -> Lnrpc_ClosedChannelsResponse
  /// Asynchronous. Unary.
  func closedChannels(_ request: Lnrpc_ClosedChannelsRequest, completion: @escaping (Lnrpc_ClosedChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningClosedChannelsCall

  /// Synchronous. Unary.
  func openChannelSync(_ request: Lnrpc_OpenChannelRequest) throws -> Lnrpc_ChannelPoint
  /// Asynchronous. Unary.
  func openChannelSync(_ request: Lnrpc_OpenChannelRequest, completion: @escaping (Lnrpc_ChannelPoint?, CallResult) -> Void) throws -> Lnrpc_LightningOpenChannelSyncCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func openChannel(_ request: Lnrpc_OpenChannelRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningOpenChannelCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func closeChannel(_ request: Lnrpc_CloseChannelRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningCloseChannelCall

  /// Synchronous. Unary.
  func abandonChannel(_ request: Lnrpc_AbandonChannelRequest) throws -> Lnrpc_AbandonChannelResponse
  /// Asynchronous. Unary.
  func abandonChannel(_ request: Lnrpc_AbandonChannelRequest, completion: @escaping (Lnrpc_AbandonChannelResponse?, CallResult) -> Void) throws -> Lnrpc_LightningAbandonChannelCall

  /// Asynchronous. Bidirectional-streaming.
  /// Use methods on the returned object to stream messages,
  /// to wait for replies, and to close the connection.
  func sendPayment(completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSendPaymentCall

  /// Synchronous. Unary.
  func sendPaymentSync(_ request: Lnrpc_SendRequest) throws -> Lnrpc_SendResponse
  /// Asynchronous. Unary.
  func sendPaymentSync(_ request: Lnrpc_SendRequest, completion: @escaping (Lnrpc_SendResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendPaymentSyncCall

  /// Asynchronous. Bidirectional-streaming.
  /// Use methods on the returned object to stream messages,
  /// to wait for replies, and to close the connection.
  func sendToRoute(completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSendToRouteCall

  /// Synchronous. Unary.
  func sendToRouteSync(_ request: Lnrpc_SendToRouteRequest) throws -> Lnrpc_SendResponse
  /// Asynchronous. Unary.
  func sendToRouteSync(_ request: Lnrpc_SendToRouteRequest, completion: @escaping (Lnrpc_SendResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendToRouteSyncCall

  /// Synchronous. Unary.
  func addInvoice(_ request: Lnrpc_Invoice) throws -> Lnrpc_AddInvoiceResponse
  /// Asynchronous. Unary.
  func addInvoice(_ request: Lnrpc_Invoice, completion: @escaping (Lnrpc_AddInvoiceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningAddInvoiceCall

  /// Synchronous. Unary.
  func listInvoices(_ request: Lnrpc_ListInvoiceRequest) throws -> Lnrpc_ListInvoiceResponse
  /// Asynchronous. Unary.
  func listInvoices(_ request: Lnrpc_ListInvoiceRequest, completion: @escaping (Lnrpc_ListInvoiceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListInvoicesCall

  /// Synchronous. Unary.
  func lookupInvoice(_ request: Lnrpc_PaymentHash) throws -> Lnrpc_Invoice
  /// Asynchronous. Unary.
  func lookupInvoice(_ request: Lnrpc_PaymentHash, completion: @escaping (Lnrpc_Invoice?, CallResult) -> Void) throws -> Lnrpc_LightningLookupInvoiceCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func subscribeInvoices(_ request: Lnrpc_InvoiceSubscription, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeInvoicesCall

  /// Synchronous. Unary.
  func decodePayReq(_ request: Lnrpc_PayReqString) throws -> Lnrpc_PayReq
  /// Asynchronous. Unary.
  func decodePayReq(_ request: Lnrpc_PayReqString, completion: @escaping (Lnrpc_PayReq?, CallResult) -> Void) throws -> Lnrpc_LightningDecodePayReqCall

  /// Synchronous. Unary.
  func listPayments(_ request: Lnrpc_ListPaymentsRequest) throws -> Lnrpc_ListPaymentsResponse
  /// Asynchronous. Unary.
  func listPayments(_ request: Lnrpc_ListPaymentsRequest, completion: @escaping (Lnrpc_ListPaymentsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListPaymentsCall

  /// Synchronous. Unary.
  func deleteAllPayments(_ request: Lnrpc_DeleteAllPaymentsRequest) throws -> Lnrpc_DeleteAllPaymentsResponse
  /// Asynchronous. Unary.
  func deleteAllPayments(_ request: Lnrpc_DeleteAllPaymentsRequest, completion: @escaping (Lnrpc_DeleteAllPaymentsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDeleteAllPaymentsCall

  /// Synchronous. Unary.
  func describeGraph(_ request: Lnrpc_ChannelGraphRequest) throws -> Lnrpc_ChannelGraph
  /// Asynchronous. Unary.
  func describeGraph(_ request: Lnrpc_ChannelGraphRequest, completion: @escaping (Lnrpc_ChannelGraph?, CallResult) -> Void) throws -> Lnrpc_LightningDescribeGraphCall

  /// Synchronous. Unary.
  func getChanInfo(_ request: Lnrpc_ChanInfoRequest) throws -> Lnrpc_ChannelEdge
  /// Asynchronous. Unary.
  func getChanInfo(_ request: Lnrpc_ChanInfoRequest, completion: @escaping (Lnrpc_ChannelEdge?, CallResult) -> Void) throws -> Lnrpc_LightningGetChanInfoCall

  /// Synchronous. Unary.
  func getNodeInfo(_ request: Lnrpc_NodeInfoRequest) throws -> Lnrpc_NodeInfo
  /// Asynchronous. Unary.
  func getNodeInfo(_ request: Lnrpc_NodeInfoRequest, completion: @escaping (Lnrpc_NodeInfo?, CallResult) -> Void) throws -> Lnrpc_LightningGetNodeInfoCall

  /// Synchronous. Unary.
  func queryRoutes(_ request: Lnrpc_QueryRoutesRequest) throws -> Lnrpc_QueryRoutesResponse
  /// Asynchronous. Unary.
  func queryRoutes(_ request: Lnrpc_QueryRoutesRequest, completion: @escaping (Lnrpc_QueryRoutesResponse?, CallResult) -> Void) throws -> Lnrpc_LightningQueryRoutesCall

  /// Synchronous. Unary.
  func getNetworkInfo(_ request: Lnrpc_NetworkInfoRequest) throws -> Lnrpc_NetworkInfo
  /// Asynchronous. Unary.
  func getNetworkInfo(_ request: Lnrpc_NetworkInfoRequest, completion: @escaping (Lnrpc_NetworkInfo?, CallResult) -> Void) throws -> Lnrpc_LightningGetNetworkInfoCall

  /// Synchronous. Unary.
  func stopDaemon(_ request: Lnrpc_StopRequest) throws -> Lnrpc_StopResponse
  /// Asynchronous. Unary.
  func stopDaemon(_ request: Lnrpc_StopRequest, completion: @escaping (Lnrpc_StopResponse?, CallResult) -> Void) throws -> Lnrpc_LightningStopDaemonCall

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  func subscribeChannelGraph(_ request: Lnrpc_GraphTopologySubscription, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeChannelGraphCall

  /// Synchronous. Unary.
  func debugLevel(_ request: Lnrpc_DebugLevelRequest) throws -> Lnrpc_DebugLevelResponse
  /// Asynchronous. Unary.
  func debugLevel(_ request: Lnrpc_DebugLevelRequest, completion: @escaping (Lnrpc_DebugLevelResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDebugLevelCall

  /// Synchronous. Unary.
  func feeReport(_ request: Lnrpc_FeeReportRequest) throws -> Lnrpc_FeeReportResponse
  /// Asynchronous. Unary.
  func feeReport(_ request: Lnrpc_FeeReportRequest, completion: @escaping (Lnrpc_FeeReportResponse?, CallResult) -> Void) throws -> Lnrpc_LightningFeeReportCall

  /// Synchronous. Unary.
  func updateChannelPolicy(_ request: Lnrpc_PolicyUpdateRequest) throws -> Lnrpc_PolicyUpdateResponse
  /// Asynchronous. Unary.
  func updateChannelPolicy(_ request: Lnrpc_PolicyUpdateRequest, completion: @escaping (Lnrpc_PolicyUpdateResponse?, CallResult) -> Void) throws -> Lnrpc_LightningUpdateChannelPolicyCall

  /// Synchronous. Unary.
  func forwardingHistory(_ request: Lnrpc_ForwardingHistoryRequest) throws -> Lnrpc_ForwardingHistoryResponse
  /// Asynchronous. Unary.
  func forwardingHistory(_ request: Lnrpc_ForwardingHistoryRequest, completion: @escaping (Lnrpc_ForwardingHistoryResponse?, CallResult) -> Void) throws -> Lnrpc_LightningForwardingHistoryCall

}

internal final class Lnrpc_LightningServiceClient: ServiceClientBase, Lnrpc_LightningService {
  /// Synchronous. Unary.
  internal func walletBalance(_ request: Lnrpc_WalletBalanceRequest) throws -> Lnrpc_WalletBalanceResponse {
    return try Lnrpc_LightningWalletBalanceCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func walletBalance(_ request: Lnrpc_WalletBalanceRequest, completion: @escaping (Lnrpc_WalletBalanceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningWalletBalanceCall {
    return try Lnrpc_LightningWalletBalanceCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func channelBalance(_ request: Lnrpc_ChannelBalanceRequest) throws -> Lnrpc_ChannelBalanceResponse {
    return try Lnrpc_LightningChannelBalanceCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func channelBalance(_ request: Lnrpc_ChannelBalanceRequest, completion: @escaping (Lnrpc_ChannelBalanceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningChannelBalanceCall {
    return try Lnrpc_LightningChannelBalanceCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func getTransactions(_ request: Lnrpc_GetTransactionsRequest) throws -> Lnrpc_TransactionDetails {
    return try Lnrpc_LightningGetTransactionsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func getTransactions(_ request: Lnrpc_GetTransactionsRequest, completion: @escaping (Lnrpc_TransactionDetails?, CallResult) -> Void) throws -> Lnrpc_LightningGetTransactionsCall {
    return try Lnrpc_LightningGetTransactionsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func sendCoins(_ request: Lnrpc_SendCoinsRequest) throws -> Lnrpc_SendCoinsResponse {
    return try Lnrpc_LightningSendCoinsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func sendCoins(_ request: Lnrpc_SendCoinsRequest, completion: @escaping (Lnrpc_SendCoinsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendCoinsCall {
    return try Lnrpc_LightningSendCoinsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribeTransactions(_ request: Lnrpc_GetTransactionsRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeTransactionsCall {
    return try Lnrpc_LightningSubscribeTransactionsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func sendMany(_ request: Lnrpc_SendManyRequest) throws -> Lnrpc_SendManyResponse {
    return try Lnrpc_LightningSendManyCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func sendMany(_ request: Lnrpc_SendManyRequest, completion: @escaping (Lnrpc_SendManyResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendManyCall {
    return try Lnrpc_LightningSendManyCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func newAddress(_ request: Lnrpc_NewAddressRequest) throws -> Lnrpc_NewAddressResponse {
    return try Lnrpc_LightningNewAddressCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func newAddress(_ request: Lnrpc_NewAddressRequest, completion: @escaping (Lnrpc_NewAddressResponse?, CallResult) -> Void) throws -> Lnrpc_LightningNewAddressCall {
    return try Lnrpc_LightningNewAddressCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func signMessage(_ request: Lnrpc_SignMessageRequest) throws -> Lnrpc_SignMessageResponse {
    return try Lnrpc_LightningSignMessageCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func signMessage(_ request: Lnrpc_SignMessageRequest, completion: @escaping (Lnrpc_SignMessageResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSignMessageCall {
    return try Lnrpc_LightningSignMessageCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func verifyMessage(_ request: Lnrpc_VerifyMessageRequest) throws -> Lnrpc_VerifyMessageResponse {
    return try Lnrpc_LightningVerifyMessageCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func verifyMessage(_ request: Lnrpc_VerifyMessageRequest, completion: @escaping (Lnrpc_VerifyMessageResponse?, CallResult) -> Void) throws -> Lnrpc_LightningVerifyMessageCall {
    return try Lnrpc_LightningVerifyMessageCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func connectPeer(_ request: Lnrpc_ConnectPeerRequest) throws -> Lnrpc_ConnectPeerResponse {
    return try Lnrpc_LightningConnectPeerCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func connectPeer(_ request: Lnrpc_ConnectPeerRequest, completion: @escaping (Lnrpc_ConnectPeerResponse?, CallResult) -> Void) throws -> Lnrpc_LightningConnectPeerCall {
    return try Lnrpc_LightningConnectPeerCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func disconnectPeer(_ request: Lnrpc_DisconnectPeerRequest) throws -> Lnrpc_DisconnectPeerResponse {
    return try Lnrpc_LightningDisconnectPeerCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func disconnectPeer(_ request: Lnrpc_DisconnectPeerRequest, completion: @escaping (Lnrpc_DisconnectPeerResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDisconnectPeerCall {
    return try Lnrpc_LightningDisconnectPeerCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func listPeers(_ request: Lnrpc_ListPeersRequest) throws -> Lnrpc_ListPeersResponse {
    return try Lnrpc_LightningListPeersCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func listPeers(_ request: Lnrpc_ListPeersRequest, completion: @escaping (Lnrpc_ListPeersResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListPeersCall {
    return try Lnrpc_LightningListPeersCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func getInfo(_ request: Lnrpc_GetInfoRequest) throws -> Lnrpc_GetInfoResponse {
    return try Lnrpc_LightningGetInfoCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func getInfo(_ request: Lnrpc_GetInfoRequest, completion: @escaping (Lnrpc_GetInfoResponse?, CallResult) -> Void) throws -> Lnrpc_LightningGetInfoCall {
    return try Lnrpc_LightningGetInfoCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func pendingChannels(_ request: Lnrpc_PendingChannelsRequest) throws -> Lnrpc_PendingChannelsResponse {
    return try Lnrpc_LightningPendingChannelsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func pendingChannels(_ request: Lnrpc_PendingChannelsRequest, completion: @escaping (Lnrpc_PendingChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningPendingChannelsCall {
    return try Lnrpc_LightningPendingChannelsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func listChannels(_ request: Lnrpc_ListChannelsRequest) throws -> Lnrpc_ListChannelsResponse {
    return try Lnrpc_LightningListChannelsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func listChannels(_ request: Lnrpc_ListChannelsRequest, completion: @escaping (Lnrpc_ListChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListChannelsCall {
    return try Lnrpc_LightningListChannelsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func closedChannels(_ request: Lnrpc_ClosedChannelsRequest) throws -> Lnrpc_ClosedChannelsResponse {
    return try Lnrpc_LightningClosedChannelsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func closedChannels(_ request: Lnrpc_ClosedChannelsRequest, completion: @escaping (Lnrpc_ClosedChannelsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningClosedChannelsCall {
    return try Lnrpc_LightningClosedChannelsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func openChannelSync(_ request: Lnrpc_OpenChannelRequest) throws -> Lnrpc_ChannelPoint {
    return try Lnrpc_LightningOpenChannelSyncCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func openChannelSync(_ request: Lnrpc_OpenChannelRequest, completion: @escaping (Lnrpc_ChannelPoint?, CallResult) -> Void) throws -> Lnrpc_LightningOpenChannelSyncCall {
    return try Lnrpc_LightningOpenChannelSyncCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func openChannel(_ request: Lnrpc_OpenChannelRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningOpenChannelCall {
    return try Lnrpc_LightningOpenChannelCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func closeChannel(_ request: Lnrpc_CloseChannelRequest, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningCloseChannelCall {
    return try Lnrpc_LightningCloseChannelCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func abandonChannel(_ request: Lnrpc_AbandonChannelRequest) throws -> Lnrpc_AbandonChannelResponse {
    return try Lnrpc_LightningAbandonChannelCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func abandonChannel(_ request: Lnrpc_AbandonChannelRequest, completion: @escaping (Lnrpc_AbandonChannelResponse?, CallResult) -> Void) throws -> Lnrpc_LightningAbandonChannelCall {
    return try Lnrpc_LightningAbandonChannelCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Bidirectional-streaming.
  /// Use methods on the returned object to stream messages,
  /// to wait for replies, and to close the connection.
  internal func sendPayment(completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSendPaymentCall {
    return try Lnrpc_LightningSendPaymentCallBase(channel)
      .start(metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func sendPaymentSync(_ request: Lnrpc_SendRequest) throws -> Lnrpc_SendResponse {
    return try Lnrpc_LightningSendPaymentSyncCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func sendPaymentSync(_ request: Lnrpc_SendRequest, completion: @escaping (Lnrpc_SendResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendPaymentSyncCall {
    return try Lnrpc_LightningSendPaymentSyncCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Bidirectional-streaming.
  /// Use methods on the returned object to stream messages,
  /// to wait for replies, and to close the connection.
  internal func sendToRoute(completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSendToRouteCall {
    return try Lnrpc_LightningSendToRouteCallBase(channel)
      .start(metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func sendToRouteSync(_ request: Lnrpc_SendToRouteRequest) throws -> Lnrpc_SendResponse {
    return try Lnrpc_LightningSendToRouteSyncCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func sendToRouteSync(_ request: Lnrpc_SendToRouteRequest, completion: @escaping (Lnrpc_SendResponse?, CallResult) -> Void) throws -> Lnrpc_LightningSendToRouteSyncCall {
    return try Lnrpc_LightningSendToRouteSyncCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func addInvoice(_ request: Lnrpc_Invoice) throws -> Lnrpc_AddInvoiceResponse {
    return try Lnrpc_LightningAddInvoiceCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func addInvoice(_ request: Lnrpc_Invoice, completion: @escaping (Lnrpc_AddInvoiceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningAddInvoiceCall {
    return try Lnrpc_LightningAddInvoiceCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func listInvoices(_ request: Lnrpc_ListInvoiceRequest) throws -> Lnrpc_ListInvoiceResponse {
    return try Lnrpc_LightningListInvoicesCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func listInvoices(_ request: Lnrpc_ListInvoiceRequest, completion: @escaping (Lnrpc_ListInvoiceResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListInvoicesCall {
    return try Lnrpc_LightningListInvoicesCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func lookupInvoice(_ request: Lnrpc_PaymentHash) throws -> Lnrpc_Invoice {
    return try Lnrpc_LightningLookupInvoiceCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func lookupInvoice(_ request: Lnrpc_PaymentHash, completion: @escaping (Lnrpc_Invoice?, CallResult) -> Void) throws -> Lnrpc_LightningLookupInvoiceCall {
    return try Lnrpc_LightningLookupInvoiceCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribeInvoices(_ request: Lnrpc_InvoiceSubscription, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeInvoicesCall {
    return try Lnrpc_LightningSubscribeInvoicesCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func decodePayReq(_ request: Lnrpc_PayReqString) throws -> Lnrpc_PayReq {
    return try Lnrpc_LightningDecodePayReqCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func decodePayReq(_ request: Lnrpc_PayReqString, completion: @escaping (Lnrpc_PayReq?, CallResult) -> Void) throws -> Lnrpc_LightningDecodePayReqCall {
    return try Lnrpc_LightningDecodePayReqCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func listPayments(_ request: Lnrpc_ListPaymentsRequest) throws -> Lnrpc_ListPaymentsResponse {
    return try Lnrpc_LightningListPaymentsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func listPayments(_ request: Lnrpc_ListPaymentsRequest, completion: @escaping (Lnrpc_ListPaymentsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningListPaymentsCall {
    return try Lnrpc_LightningListPaymentsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func deleteAllPayments(_ request: Lnrpc_DeleteAllPaymentsRequest) throws -> Lnrpc_DeleteAllPaymentsResponse {
    return try Lnrpc_LightningDeleteAllPaymentsCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func deleteAllPayments(_ request: Lnrpc_DeleteAllPaymentsRequest, completion: @escaping (Lnrpc_DeleteAllPaymentsResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDeleteAllPaymentsCall {
    return try Lnrpc_LightningDeleteAllPaymentsCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func describeGraph(_ request: Lnrpc_ChannelGraphRequest) throws -> Lnrpc_ChannelGraph {
    return try Lnrpc_LightningDescribeGraphCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func describeGraph(_ request: Lnrpc_ChannelGraphRequest, completion: @escaping (Lnrpc_ChannelGraph?, CallResult) -> Void) throws -> Lnrpc_LightningDescribeGraphCall {
    return try Lnrpc_LightningDescribeGraphCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func getChanInfo(_ request: Lnrpc_ChanInfoRequest) throws -> Lnrpc_ChannelEdge {
    return try Lnrpc_LightningGetChanInfoCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func getChanInfo(_ request: Lnrpc_ChanInfoRequest, completion: @escaping (Lnrpc_ChannelEdge?, CallResult) -> Void) throws -> Lnrpc_LightningGetChanInfoCall {
    return try Lnrpc_LightningGetChanInfoCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func getNodeInfo(_ request: Lnrpc_NodeInfoRequest) throws -> Lnrpc_NodeInfo {
    return try Lnrpc_LightningGetNodeInfoCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func getNodeInfo(_ request: Lnrpc_NodeInfoRequest, completion: @escaping (Lnrpc_NodeInfo?, CallResult) -> Void) throws -> Lnrpc_LightningGetNodeInfoCall {
    return try Lnrpc_LightningGetNodeInfoCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func queryRoutes(_ request: Lnrpc_QueryRoutesRequest) throws -> Lnrpc_QueryRoutesResponse {
    return try Lnrpc_LightningQueryRoutesCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func queryRoutes(_ request: Lnrpc_QueryRoutesRequest, completion: @escaping (Lnrpc_QueryRoutesResponse?, CallResult) -> Void) throws -> Lnrpc_LightningQueryRoutesCall {
    return try Lnrpc_LightningQueryRoutesCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func getNetworkInfo(_ request: Lnrpc_NetworkInfoRequest) throws -> Lnrpc_NetworkInfo {
    return try Lnrpc_LightningGetNetworkInfoCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func getNetworkInfo(_ request: Lnrpc_NetworkInfoRequest, completion: @escaping (Lnrpc_NetworkInfo?, CallResult) -> Void) throws -> Lnrpc_LightningGetNetworkInfoCall {
    return try Lnrpc_LightningGetNetworkInfoCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func stopDaemon(_ request: Lnrpc_StopRequest) throws -> Lnrpc_StopResponse {
    return try Lnrpc_LightningStopDaemonCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func stopDaemon(_ request: Lnrpc_StopRequest, completion: @escaping (Lnrpc_StopResponse?, CallResult) -> Void) throws -> Lnrpc_LightningStopDaemonCall {
    return try Lnrpc_LightningStopDaemonCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Asynchronous. Server-streaming.
  /// Send the initial message.
  /// Use methods on the returned object to get streamed responses.
  internal func subscribeChannelGraph(_ request: Lnrpc_GraphTopologySubscription, completion: ((CallResult) -> Void)?) throws -> Lnrpc_LightningSubscribeChannelGraphCall {
    return try Lnrpc_LightningSubscribeChannelGraphCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func debugLevel(_ request: Lnrpc_DebugLevelRequest) throws -> Lnrpc_DebugLevelResponse {
    return try Lnrpc_LightningDebugLevelCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func debugLevel(_ request: Lnrpc_DebugLevelRequest, completion: @escaping (Lnrpc_DebugLevelResponse?, CallResult) -> Void) throws -> Lnrpc_LightningDebugLevelCall {
    return try Lnrpc_LightningDebugLevelCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func feeReport(_ request: Lnrpc_FeeReportRequest) throws -> Lnrpc_FeeReportResponse {
    return try Lnrpc_LightningFeeReportCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func feeReport(_ request: Lnrpc_FeeReportRequest, completion: @escaping (Lnrpc_FeeReportResponse?, CallResult) -> Void) throws -> Lnrpc_LightningFeeReportCall {
    return try Lnrpc_LightningFeeReportCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func updateChannelPolicy(_ request: Lnrpc_PolicyUpdateRequest) throws -> Lnrpc_PolicyUpdateResponse {
    return try Lnrpc_LightningUpdateChannelPolicyCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func updateChannelPolicy(_ request: Lnrpc_PolicyUpdateRequest, completion: @escaping (Lnrpc_PolicyUpdateResponse?, CallResult) -> Void) throws -> Lnrpc_LightningUpdateChannelPolicyCall {
    return try Lnrpc_LightningUpdateChannelPolicyCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

  /// Synchronous. Unary.
  internal func forwardingHistory(_ request: Lnrpc_ForwardingHistoryRequest) throws -> Lnrpc_ForwardingHistoryResponse {
    return try Lnrpc_LightningForwardingHistoryCallBase(channel)
      .run(request: request, metadata: metadata)
  }
  /// Asynchronous. Unary.
  internal func forwardingHistory(_ request: Lnrpc_ForwardingHistoryRequest, completion: @escaping (Lnrpc_ForwardingHistoryResponse?, CallResult) -> Void) throws -> Lnrpc_LightningForwardingHistoryCall {
    return try Lnrpc_LightningForwardingHistoryCallBase(channel)
      .start(request: request, metadata: metadata, completion: completion)
  }

}

/// To build a server, implement a class that conforms to this protocol.
/// If one of the methods returning `ServerStatus?` returns nil,
/// it is expected that you have already returned a status to the client by means of `session.close`.
internal protocol Lnrpc_WalletUnlockerProvider: ServiceProvider {
  func genSeed(request: Lnrpc_GenSeedRequest, session: Lnrpc_WalletUnlockerGenSeedSession) throws -> Lnrpc_GenSeedResponse
  func initWallet(request: Lnrpc_InitWalletRequest, session: Lnrpc_WalletUnlockerInitWalletSession) throws -> Lnrpc_InitWalletResponse
  func unlockWallet(request: Lnrpc_UnlockWalletRequest, session: Lnrpc_WalletUnlockerUnlockWalletSession) throws -> Lnrpc_UnlockWalletResponse
  func changePassword(request: Lnrpc_ChangePasswordRequest, session: Lnrpc_WalletUnlockerChangePasswordSession) throws -> Lnrpc_ChangePasswordResponse
}

extension Lnrpc_WalletUnlockerProvider {
  internal var serviceName: String { return "lnrpc.WalletUnlocker" }

  /// Determines and calls the appropriate request handler, depending on the request's method.
  /// Throws `HandleMethodError.unknownMethod` for methods not handled by this service.
  internal func handleMethod(_ method: String, handler: Handler) throws -> ServerStatus? {
    switch method {
    case "/lnrpc.WalletUnlocker/GenSeed":
      return try Lnrpc_WalletUnlockerGenSeedSessionBase(
        handler: handler,
        providerBlock: { try self.genSeed(request: $0, session: $1 as! Lnrpc_WalletUnlockerGenSeedSessionBase) })
          .run()
    case "/lnrpc.WalletUnlocker/InitWallet":
      return try Lnrpc_WalletUnlockerInitWalletSessionBase(
        handler: handler,
        providerBlock: { try self.initWallet(request: $0, session: $1 as! Lnrpc_WalletUnlockerInitWalletSessionBase) })
          .run()
    case "/lnrpc.WalletUnlocker/UnlockWallet":
      return try Lnrpc_WalletUnlockerUnlockWalletSessionBase(
        handler: handler,
        providerBlock: { try self.unlockWallet(request: $0, session: $1 as! Lnrpc_WalletUnlockerUnlockWalletSessionBase) })
          .run()
    case "/lnrpc.WalletUnlocker/ChangePassword":
      return try Lnrpc_WalletUnlockerChangePasswordSessionBase(
        handler: handler,
        providerBlock: { try self.changePassword(request: $0, session: $1 as! Lnrpc_WalletUnlockerChangePasswordSessionBase) })
          .run()
    default:
      throw HandleMethodError.unknownMethod
    }
  }
}

internal protocol Lnrpc_WalletUnlockerGenSeedSession: ServerSessionUnary {}

fileprivate final class Lnrpc_WalletUnlockerGenSeedSessionBase: ServerSessionUnaryBase<Lnrpc_GenSeedRequest, Lnrpc_GenSeedResponse>, Lnrpc_WalletUnlockerGenSeedSession {}

internal protocol Lnrpc_WalletUnlockerInitWalletSession: ServerSessionUnary {}

fileprivate final class Lnrpc_WalletUnlockerInitWalletSessionBase: ServerSessionUnaryBase<Lnrpc_InitWalletRequest, Lnrpc_InitWalletResponse>, Lnrpc_WalletUnlockerInitWalletSession {}

internal protocol Lnrpc_WalletUnlockerUnlockWalletSession: ServerSessionUnary {}

fileprivate final class Lnrpc_WalletUnlockerUnlockWalletSessionBase: ServerSessionUnaryBase<Lnrpc_UnlockWalletRequest, Lnrpc_UnlockWalletResponse>, Lnrpc_WalletUnlockerUnlockWalletSession {}

internal protocol Lnrpc_WalletUnlockerChangePasswordSession: ServerSessionUnary {}

fileprivate final class Lnrpc_WalletUnlockerChangePasswordSessionBase: ServerSessionUnaryBase<Lnrpc_ChangePasswordRequest, Lnrpc_ChangePasswordResponse>, Lnrpc_WalletUnlockerChangePasswordSession {}

/// To build a server, implement a class that conforms to this protocol.
/// If one of the methods returning `ServerStatus?` returns nil,
/// it is expected that you have already returned a status to the client by means of `session.close`.
internal protocol Lnrpc_LightningProvider: ServiceProvider {
  func walletBalance(request: Lnrpc_WalletBalanceRequest, session: Lnrpc_LightningWalletBalanceSession) throws -> Lnrpc_WalletBalanceResponse
  func channelBalance(request: Lnrpc_ChannelBalanceRequest, session: Lnrpc_LightningChannelBalanceSession) throws -> Lnrpc_ChannelBalanceResponse
  func getTransactions(request: Lnrpc_GetTransactionsRequest, session: Lnrpc_LightningGetTransactionsSession) throws -> Lnrpc_TransactionDetails
  func sendCoins(request: Lnrpc_SendCoinsRequest, session: Lnrpc_LightningSendCoinsSession) throws -> Lnrpc_SendCoinsResponse
  func subscribeTransactions(request: Lnrpc_GetTransactionsRequest, session: Lnrpc_LightningSubscribeTransactionsSession) throws -> ServerStatus?
  func sendMany(request: Lnrpc_SendManyRequest, session: Lnrpc_LightningSendManySession) throws -> Lnrpc_SendManyResponse
  func newAddress(request: Lnrpc_NewAddressRequest, session: Lnrpc_LightningNewAddressSession) throws -> Lnrpc_NewAddressResponse
  func signMessage(request: Lnrpc_SignMessageRequest, session: Lnrpc_LightningSignMessageSession) throws -> Lnrpc_SignMessageResponse
  func verifyMessage(request: Lnrpc_VerifyMessageRequest, session: Lnrpc_LightningVerifyMessageSession) throws -> Lnrpc_VerifyMessageResponse
  func connectPeer(request: Lnrpc_ConnectPeerRequest, session: Lnrpc_LightningConnectPeerSession) throws -> Lnrpc_ConnectPeerResponse
  func disconnectPeer(request: Lnrpc_DisconnectPeerRequest, session: Lnrpc_LightningDisconnectPeerSession) throws -> Lnrpc_DisconnectPeerResponse
  func listPeers(request: Lnrpc_ListPeersRequest, session: Lnrpc_LightningListPeersSession) throws -> Lnrpc_ListPeersResponse
  func getInfo(request: Lnrpc_GetInfoRequest, session: Lnrpc_LightningGetInfoSession) throws -> Lnrpc_GetInfoResponse
  func pendingChannels(request: Lnrpc_PendingChannelsRequest, session: Lnrpc_LightningPendingChannelsSession) throws -> Lnrpc_PendingChannelsResponse
  func listChannels(request: Lnrpc_ListChannelsRequest, session: Lnrpc_LightningListChannelsSession) throws -> Lnrpc_ListChannelsResponse
  func closedChannels(request: Lnrpc_ClosedChannelsRequest, session: Lnrpc_LightningClosedChannelsSession) throws -> Lnrpc_ClosedChannelsResponse
  func openChannelSync(request: Lnrpc_OpenChannelRequest, session: Lnrpc_LightningOpenChannelSyncSession) throws -> Lnrpc_ChannelPoint
  func openChannel(request: Lnrpc_OpenChannelRequest, session: Lnrpc_LightningOpenChannelSession) throws -> ServerStatus?
  func closeChannel(request: Lnrpc_CloseChannelRequest, session: Lnrpc_LightningCloseChannelSession) throws -> ServerStatus?
  func abandonChannel(request: Lnrpc_AbandonChannelRequest, session: Lnrpc_LightningAbandonChannelSession) throws -> Lnrpc_AbandonChannelResponse
  func sendPayment(session: Lnrpc_LightningSendPaymentSession) throws -> ServerStatus?
  func sendPaymentSync(request: Lnrpc_SendRequest, session: Lnrpc_LightningSendPaymentSyncSession) throws -> Lnrpc_SendResponse
  func sendToRoute(session: Lnrpc_LightningSendToRouteSession) throws -> ServerStatus?
  func sendToRouteSync(request: Lnrpc_SendToRouteRequest, session: Lnrpc_LightningSendToRouteSyncSession) throws -> Lnrpc_SendResponse
  func addInvoice(request: Lnrpc_Invoice, session: Lnrpc_LightningAddInvoiceSession) throws -> Lnrpc_AddInvoiceResponse
  func listInvoices(request: Lnrpc_ListInvoiceRequest, session: Lnrpc_LightningListInvoicesSession) throws -> Lnrpc_ListInvoiceResponse
  func lookupInvoice(request: Lnrpc_PaymentHash, session: Lnrpc_LightningLookupInvoiceSession) throws -> Lnrpc_Invoice
  func subscribeInvoices(request: Lnrpc_InvoiceSubscription, session: Lnrpc_LightningSubscribeInvoicesSession) throws -> ServerStatus?
  func decodePayReq(request: Lnrpc_PayReqString, session: Lnrpc_LightningDecodePayReqSession) throws -> Lnrpc_PayReq
  func listPayments(request: Lnrpc_ListPaymentsRequest, session: Lnrpc_LightningListPaymentsSession) throws -> Lnrpc_ListPaymentsResponse
  func deleteAllPayments(request: Lnrpc_DeleteAllPaymentsRequest, session: Lnrpc_LightningDeleteAllPaymentsSession) throws -> Lnrpc_DeleteAllPaymentsResponse
  func describeGraph(request: Lnrpc_ChannelGraphRequest, session: Lnrpc_LightningDescribeGraphSession) throws -> Lnrpc_ChannelGraph
  func getChanInfo(request: Lnrpc_ChanInfoRequest, session: Lnrpc_LightningGetChanInfoSession) throws -> Lnrpc_ChannelEdge
  func getNodeInfo(request: Lnrpc_NodeInfoRequest, session: Lnrpc_LightningGetNodeInfoSession) throws -> Lnrpc_NodeInfo
  func queryRoutes(request: Lnrpc_QueryRoutesRequest, session: Lnrpc_LightningQueryRoutesSession) throws -> Lnrpc_QueryRoutesResponse
  func getNetworkInfo(request: Lnrpc_NetworkInfoRequest, session: Lnrpc_LightningGetNetworkInfoSession) throws -> Lnrpc_NetworkInfo
  func stopDaemon(request: Lnrpc_StopRequest, session: Lnrpc_LightningStopDaemonSession) throws -> Lnrpc_StopResponse
  func subscribeChannelGraph(request: Lnrpc_GraphTopologySubscription, session: Lnrpc_LightningSubscribeChannelGraphSession) throws -> ServerStatus?
  func debugLevel(request: Lnrpc_DebugLevelRequest, session: Lnrpc_LightningDebugLevelSession) throws -> Lnrpc_DebugLevelResponse
  func feeReport(request: Lnrpc_FeeReportRequest, session: Lnrpc_LightningFeeReportSession) throws -> Lnrpc_FeeReportResponse
  func updateChannelPolicy(request: Lnrpc_PolicyUpdateRequest, session: Lnrpc_LightningUpdateChannelPolicySession) throws -> Lnrpc_PolicyUpdateResponse
  func forwardingHistory(request: Lnrpc_ForwardingHistoryRequest, session: Lnrpc_LightningForwardingHistorySession) throws -> Lnrpc_ForwardingHistoryResponse
}

extension Lnrpc_LightningProvider {
  internal var serviceName: String { return "lnrpc.Lightning" }

  /// Determines and calls the appropriate request handler, depending on the request's method.
  /// Throws `HandleMethodError.unknownMethod` for methods not handled by this service.
  internal func handleMethod(_ method: String, handler: Handler) throws -> ServerStatus? {
    switch method {
    case "/lnrpc.Lightning/WalletBalance":
      return try Lnrpc_LightningWalletBalanceSessionBase(
        handler: handler,
        providerBlock: { try self.walletBalance(request: $0, session: $1 as! Lnrpc_LightningWalletBalanceSessionBase) })
          .run()
    case "/lnrpc.Lightning/ChannelBalance":
      return try Lnrpc_LightningChannelBalanceSessionBase(
        handler: handler,
        providerBlock: { try self.channelBalance(request: $0, session: $1 as! Lnrpc_LightningChannelBalanceSessionBase) })
          .run()
    case "/lnrpc.Lightning/GetTransactions":
      return try Lnrpc_LightningGetTransactionsSessionBase(
        handler: handler,
        providerBlock: { try self.getTransactions(request: $0, session: $1 as! Lnrpc_LightningGetTransactionsSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendCoins":
      return try Lnrpc_LightningSendCoinsSessionBase(
        handler: handler,
        providerBlock: { try self.sendCoins(request: $0, session: $1 as! Lnrpc_LightningSendCoinsSessionBase) })
          .run()
    case "/lnrpc.Lightning/SubscribeTransactions":
      return try Lnrpc_LightningSubscribeTransactionsSessionBase(
        handler: handler,
        providerBlock: { try self.subscribeTransactions(request: $0, session: $1 as! Lnrpc_LightningSubscribeTransactionsSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendMany":
      return try Lnrpc_LightningSendManySessionBase(
        handler: handler,
        providerBlock: { try self.sendMany(request: $0, session: $1 as! Lnrpc_LightningSendManySessionBase) })
          .run()
    case "/lnrpc.Lightning/NewAddress":
      return try Lnrpc_LightningNewAddressSessionBase(
        handler: handler,
        providerBlock: { try self.newAddress(request: $0, session: $1 as! Lnrpc_LightningNewAddressSessionBase) })
          .run()
    case "/lnrpc.Lightning/SignMessage":
      return try Lnrpc_LightningSignMessageSessionBase(
        handler: handler,
        providerBlock: { try self.signMessage(request: $0, session: $1 as! Lnrpc_LightningSignMessageSessionBase) })
          .run()
    case "/lnrpc.Lightning/VerifyMessage":
      return try Lnrpc_LightningVerifyMessageSessionBase(
        handler: handler,
        providerBlock: { try self.verifyMessage(request: $0, session: $1 as! Lnrpc_LightningVerifyMessageSessionBase) })
          .run()
    case "/lnrpc.Lightning/ConnectPeer":
      return try Lnrpc_LightningConnectPeerSessionBase(
        handler: handler,
        providerBlock: { try self.connectPeer(request: $0, session: $1 as! Lnrpc_LightningConnectPeerSessionBase) })
          .run()
    case "/lnrpc.Lightning/DisconnectPeer":
      return try Lnrpc_LightningDisconnectPeerSessionBase(
        handler: handler,
        providerBlock: { try self.disconnectPeer(request: $0, session: $1 as! Lnrpc_LightningDisconnectPeerSessionBase) })
          .run()
    case "/lnrpc.Lightning/ListPeers":
      return try Lnrpc_LightningListPeersSessionBase(
        handler: handler,
        providerBlock: { try self.listPeers(request: $0, session: $1 as! Lnrpc_LightningListPeersSessionBase) })
          .run()
    case "/lnrpc.Lightning/GetInfo":
      return try Lnrpc_LightningGetInfoSessionBase(
        handler: handler,
        providerBlock: { try self.getInfo(request: $0, session: $1 as! Lnrpc_LightningGetInfoSessionBase) })
          .run()
    case "/lnrpc.Lightning/PendingChannels":
      return try Lnrpc_LightningPendingChannelsSessionBase(
        handler: handler,
        providerBlock: { try self.pendingChannels(request: $0, session: $1 as! Lnrpc_LightningPendingChannelsSessionBase) })
          .run()
    case "/lnrpc.Lightning/ListChannels":
      return try Lnrpc_LightningListChannelsSessionBase(
        handler: handler,
        providerBlock: { try self.listChannels(request: $0, session: $1 as! Lnrpc_LightningListChannelsSessionBase) })
          .run()
    case "/lnrpc.Lightning/ClosedChannels":
      return try Lnrpc_LightningClosedChannelsSessionBase(
        handler: handler,
        providerBlock: { try self.closedChannels(request: $0, session: $1 as! Lnrpc_LightningClosedChannelsSessionBase) })
          .run()
    case "/lnrpc.Lightning/OpenChannelSync":
      return try Lnrpc_LightningOpenChannelSyncSessionBase(
        handler: handler,
        providerBlock: { try self.openChannelSync(request: $0, session: $1 as! Lnrpc_LightningOpenChannelSyncSessionBase) })
          .run()
    case "/lnrpc.Lightning/OpenChannel":
      return try Lnrpc_LightningOpenChannelSessionBase(
        handler: handler,
        providerBlock: { try self.openChannel(request: $0, session: $1 as! Lnrpc_LightningOpenChannelSessionBase) })
          .run()
    case "/lnrpc.Lightning/CloseChannel":
      return try Lnrpc_LightningCloseChannelSessionBase(
        handler: handler,
        providerBlock: { try self.closeChannel(request: $0, session: $1 as! Lnrpc_LightningCloseChannelSessionBase) })
          .run()
    case "/lnrpc.Lightning/AbandonChannel":
      return try Lnrpc_LightningAbandonChannelSessionBase(
        handler: handler,
        providerBlock: { try self.abandonChannel(request: $0, session: $1 as! Lnrpc_LightningAbandonChannelSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendPayment":
      return try Lnrpc_LightningSendPaymentSessionBase(
        handler: handler,
        providerBlock: { try self.sendPayment(session: $0 as! Lnrpc_LightningSendPaymentSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendPaymentSync":
      return try Lnrpc_LightningSendPaymentSyncSessionBase(
        handler: handler,
        providerBlock: { try self.sendPaymentSync(request: $0, session: $1 as! Lnrpc_LightningSendPaymentSyncSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendToRoute":
      return try Lnrpc_LightningSendToRouteSessionBase(
        handler: handler,
        providerBlock: { try self.sendToRoute(session: $0 as! Lnrpc_LightningSendToRouteSessionBase) })
          .run()
    case "/lnrpc.Lightning/SendToRouteSync":
      return try Lnrpc_LightningSendToRouteSyncSessionBase(
        handler: handler,
        providerBlock: { try self.sendToRouteSync(request: $0, session: $1 as! Lnrpc_LightningSendToRouteSyncSessionBase) })
          .run()
    case "/lnrpc.Lightning/AddInvoice":
      return try Lnrpc_LightningAddInvoiceSessionBase(
        handler: handler,
        providerBlock: { try self.addInvoice(request: $0, session: $1 as! Lnrpc_LightningAddInvoiceSessionBase) })
          .run()
    case "/lnrpc.Lightning/ListInvoices":
      return try Lnrpc_LightningListInvoicesSessionBase(
        handler: handler,
        providerBlock: { try self.listInvoices(request: $0, session: $1 as! Lnrpc_LightningListInvoicesSessionBase) })
          .run()
    case "/lnrpc.Lightning/LookupInvoice":
      return try Lnrpc_LightningLookupInvoiceSessionBase(
        handler: handler,
        providerBlock: { try self.lookupInvoice(request: $0, session: $1 as! Lnrpc_LightningLookupInvoiceSessionBase) })
          .run()
    case "/lnrpc.Lightning/SubscribeInvoices":
      return try Lnrpc_LightningSubscribeInvoicesSessionBase(
        handler: handler,
        providerBlock: { try self.subscribeInvoices(request: $0, session: $1 as! Lnrpc_LightningSubscribeInvoicesSessionBase) })
          .run()
    case "/lnrpc.Lightning/DecodePayReq":
      return try Lnrpc_LightningDecodePayReqSessionBase(
        handler: handler,
        providerBlock: { try self.decodePayReq(request: $0, session: $1 as! Lnrpc_LightningDecodePayReqSessionBase) })
          .run()
    case "/lnrpc.Lightning/ListPayments":
      return try Lnrpc_LightningListPaymentsSessionBase(
        handler: handler,
        providerBlock: { try self.listPayments(request: $0, session: $1 as! Lnrpc_LightningListPaymentsSessionBase) })
          .run()
    case "/lnrpc.Lightning/DeleteAllPayments":
      return try Lnrpc_LightningDeleteAllPaymentsSessionBase(
        handler: handler,
        providerBlock: { try self.deleteAllPayments(request: $0, session: $1 as! Lnrpc_LightningDeleteAllPaymentsSessionBase) })
          .run()
    case "/lnrpc.Lightning/DescribeGraph":
      return try Lnrpc_LightningDescribeGraphSessionBase(
        handler: handler,
        providerBlock: { try self.describeGraph(request: $0, session: $1 as! Lnrpc_LightningDescribeGraphSessionBase) })
          .run()
    case "/lnrpc.Lightning/GetChanInfo":
      return try Lnrpc_LightningGetChanInfoSessionBase(
        handler: handler,
        providerBlock: { try self.getChanInfo(request: $0, session: $1 as! Lnrpc_LightningGetChanInfoSessionBase) })
          .run()
    case "/lnrpc.Lightning/GetNodeInfo":
      return try Lnrpc_LightningGetNodeInfoSessionBase(
        handler: handler,
        providerBlock: { try self.getNodeInfo(request: $0, session: $1 as! Lnrpc_LightningGetNodeInfoSessionBase) })
          .run()
    case "/lnrpc.Lightning/QueryRoutes":
      return try Lnrpc_LightningQueryRoutesSessionBase(
        handler: handler,
        providerBlock: { try self.queryRoutes(request: $0, session: $1 as! Lnrpc_LightningQueryRoutesSessionBase) })
          .run()
    case "/lnrpc.Lightning/GetNetworkInfo":
      return try Lnrpc_LightningGetNetworkInfoSessionBase(
        handler: handler,
        providerBlock: { try self.getNetworkInfo(request: $0, session: $1 as! Lnrpc_LightningGetNetworkInfoSessionBase) })
          .run()
    case "/lnrpc.Lightning/StopDaemon":
      return try Lnrpc_LightningStopDaemonSessionBase(
        handler: handler,
        providerBlock: { try self.stopDaemon(request: $0, session: $1 as! Lnrpc_LightningStopDaemonSessionBase) })
          .run()
    case "/lnrpc.Lightning/SubscribeChannelGraph":
      return try Lnrpc_LightningSubscribeChannelGraphSessionBase(
        handler: handler,
        providerBlock: { try self.subscribeChannelGraph(request: $0, session: $1 as! Lnrpc_LightningSubscribeChannelGraphSessionBase) })
          .run()
    case "/lnrpc.Lightning/DebugLevel":
      return try Lnrpc_LightningDebugLevelSessionBase(
        handler: handler,
        providerBlock: { try self.debugLevel(request: $0, session: $1 as! Lnrpc_LightningDebugLevelSessionBase) })
          .run()
    case "/lnrpc.Lightning/FeeReport":
      return try Lnrpc_LightningFeeReportSessionBase(
        handler: handler,
        providerBlock: { try self.feeReport(request: $0, session: $1 as! Lnrpc_LightningFeeReportSessionBase) })
          .run()
    case "/lnrpc.Lightning/UpdateChannelPolicy":
      return try Lnrpc_LightningUpdateChannelPolicySessionBase(
        handler: handler,
        providerBlock: { try self.updateChannelPolicy(request: $0, session: $1 as! Lnrpc_LightningUpdateChannelPolicySessionBase) })
          .run()
    case "/lnrpc.Lightning/ForwardingHistory":
      return try Lnrpc_LightningForwardingHistorySessionBase(
        handler: handler,
        providerBlock: { try self.forwardingHistory(request: $0, session: $1 as! Lnrpc_LightningForwardingHistorySessionBase) })
          .run()
    default:
      throw HandleMethodError.unknownMethod
    }
  }
}

internal protocol Lnrpc_LightningWalletBalanceSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningWalletBalanceSessionBase: ServerSessionUnaryBase<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>, Lnrpc_LightningWalletBalanceSession {}

internal protocol Lnrpc_LightningChannelBalanceSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningChannelBalanceSessionBase: ServerSessionUnaryBase<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>, Lnrpc_LightningChannelBalanceSession {}

internal protocol Lnrpc_LightningGetTransactionsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningGetTransactionsSessionBase: ServerSessionUnaryBase<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>, Lnrpc_LightningGetTransactionsSession {}

internal protocol Lnrpc_LightningSendCoinsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningSendCoinsSessionBase: ServerSessionUnaryBase<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>, Lnrpc_LightningSendCoinsSession {}

internal protocol Lnrpc_LightningSubscribeTransactionsSession: ServerSessionServerStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_Transaction, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_Transaction, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSubscribeTransactionsSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_Transaction, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeTransactionsSessionBase: ServerSessionServerStreamingBase<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>, Lnrpc_LightningSubscribeTransactionsSession {}

internal protocol Lnrpc_LightningSendManySession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningSendManySessionBase: ServerSessionUnaryBase<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>, Lnrpc_LightningSendManySession {}

internal protocol Lnrpc_LightningNewAddressSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningNewAddressSessionBase: ServerSessionUnaryBase<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>, Lnrpc_LightningNewAddressSession {}

internal protocol Lnrpc_LightningSignMessageSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningSignMessageSessionBase: ServerSessionUnaryBase<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>, Lnrpc_LightningSignMessageSession {}

internal protocol Lnrpc_LightningVerifyMessageSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningVerifyMessageSessionBase: ServerSessionUnaryBase<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>, Lnrpc_LightningVerifyMessageSession {}

internal protocol Lnrpc_LightningConnectPeerSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningConnectPeerSessionBase: ServerSessionUnaryBase<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>, Lnrpc_LightningConnectPeerSession {}

internal protocol Lnrpc_LightningDisconnectPeerSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningDisconnectPeerSessionBase: ServerSessionUnaryBase<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>, Lnrpc_LightningDisconnectPeerSession {}

internal protocol Lnrpc_LightningListPeersSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningListPeersSessionBase: ServerSessionUnaryBase<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>, Lnrpc_LightningListPeersSession {}

internal protocol Lnrpc_LightningGetInfoSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningGetInfoSessionBase: ServerSessionUnaryBase<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>, Lnrpc_LightningGetInfoSession {}

internal protocol Lnrpc_LightningPendingChannelsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningPendingChannelsSessionBase: ServerSessionUnaryBase<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>, Lnrpc_LightningPendingChannelsSession {}

internal protocol Lnrpc_LightningListChannelsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningListChannelsSessionBase: ServerSessionUnaryBase<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>, Lnrpc_LightningListChannelsSession {}

internal protocol Lnrpc_LightningClosedChannelsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningClosedChannelsSessionBase: ServerSessionUnaryBase<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>, Lnrpc_LightningClosedChannelsSession {}

internal protocol Lnrpc_LightningOpenChannelSyncSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningOpenChannelSyncSessionBase: ServerSessionUnaryBase<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>, Lnrpc_LightningOpenChannelSyncSession {}

internal protocol Lnrpc_LightningOpenChannelSession: ServerSessionServerStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_OpenStatusUpdate, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_OpenStatusUpdate, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningOpenChannelSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_OpenStatusUpdate, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningOpenChannelSessionBase: ServerSessionServerStreamingBase<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>, Lnrpc_LightningOpenChannelSession {}

internal protocol Lnrpc_LightningCloseChannelSession: ServerSessionServerStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_CloseStatusUpdate, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_CloseStatusUpdate, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningCloseChannelSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_CloseStatusUpdate, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningCloseChannelSessionBase: ServerSessionServerStreamingBase<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>, Lnrpc_LightningCloseChannelSession {}

internal protocol Lnrpc_LightningAbandonChannelSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningAbandonChannelSessionBase: ServerSessionUnaryBase<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>, Lnrpc_LightningAbandonChannelSession {}

internal protocol Lnrpc_LightningSendPaymentSession: ServerSessionBidirectionalStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_SendRequest?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_SendRequest?>) -> Void) throws

  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_SendResponse, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_SendResponse, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSendPaymentSession {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_SendRequest? { return try self._receive(timeout: timeout) }
}

internal extension Lnrpc_LightningSendPaymentSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_SendResponse, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSendPaymentSessionBase: ServerSessionBidirectionalStreamingBase<Lnrpc_SendRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendPaymentSession {}

internal protocol Lnrpc_LightningSendPaymentSyncSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningSendPaymentSyncSessionBase: ServerSessionUnaryBase<Lnrpc_SendRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendPaymentSyncSession {}

internal protocol Lnrpc_LightningSendToRouteSession: ServerSessionBidirectionalStreaming {
  /// Do not call this directly, call `receive()` in the protocol extension below instead.
  func _receive(timeout: DispatchTime) throws -> Lnrpc_SendToRouteRequest?
  /// Call this to wait for a result. Nonblocking.
  func receive(completion: @escaping (ResultOrRPCError<Lnrpc_SendToRouteRequest?>) -> Void) throws

  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_SendResponse, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_SendResponse, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSendToRouteSession {
  /// Call this to wait for a result. Blocking.
  func receive(timeout: DispatchTime = .distantFuture) throws -> Lnrpc_SendToRouteRequest? { return try self._receive(timeout: timeout) }
}

internal extension Lnrpc_LightningSendToRouteSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_SendResponse, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSendToRouteSessionBase: ServerSessionBidirectionalStreamingBase<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendToRouteSession {}

internal protocol Lnrpc_LightningSendToRouteSyncSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningSendToRouteSyncSessionBase: ServerSessionUnaryBase<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>, Lnrpc_LightningSendToRouteSyncSession {}

internal protocol Lnrpc_LightningAddInvoiceSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningAddInvoiceSessionBase: ServerSessionUnaryBase<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>, Lnrpc_LightningAddInvoiceSession {}

internal protocol Lnrpc_LightningListInvoicesSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningListInvoicesSessionBase: ServerSessionUnaryBase<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>, Lnrpc_LightningListInvoicesSession {}

internal protocol Lnrpc_LightningLookupInvoiceSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningLookupInvoiceSessionBase: ServerSessionUnaryBase<Lnrpc_PaymentHash, Lnrpc_Invoice>, Lnrpc_LightningLookupInvoiceSession {}

internal protocol Lnrpc_LightningSubscribeInvoicesSession: ServerSessionServerStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_Invoice, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_Invoice, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSubscribeInvoicesSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_Invoice, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeInvoicesSessionBase: ServerSessionServerStreamingBase<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>, Lnrpc_LightningSubscribeInvoicesSession {}

internal protocol Lnrpc_LightningDecodePayReqSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningDecodePayReqSessionBase: ServerSessionUnaryBase<Lnrpc_PayReqString, Lnrpc_PayReq>, Lnrpc_LightningDecodePayReqSession {}

internal protocol Lnrpc_LightningListPaymentsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningListPaymentsSessionBase: ServerSessionUnaryBase<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>, Lnrpc_LightningListPaymentsSession {}

internal protocol Lnrpc_LightningDeleteAllPaymentsSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningDeleteAllPaymentsSessionBase: ServerSessionUnaryBase<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>, Lnrpc_LightningDeleteAllPaymentsSession {}

internal protocol Lnrpc_LightningDescribeGraphSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningDescribeGraphSessionBase: ServerSessionUnaryBase<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>, Lnrpc_LightningDescribeGraphSession {}

internal protocol Lnrpc_LightningGetChanInfoSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningGetChanInfoSessionBase: ServerSessionUnaryBase<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>, Lnrpc_LightningGetChanInfoSession {}

internal protocol Lnrpc_LightningGetNodeInfoSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningGetNodeInfoSessionBase: ServerSessionUnaryBase<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>, Lnrpc_LightningGetNodeInfoSession {}

internal protocol Lnrpc_LightningQueryRoutesSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningQueryRoutesSessionBase: ServerSessionUnaryBase<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>, Lnrpc_LightningQueryRoutesSession {}

internal protocol Lnrpc_LightningGetNetworkInfoSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningGetNetworkInfoSessionBase: ServerSessionUnaryBase<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>, Lnrpc_LightningGetNetworkInfoSession {}

internal protocol Lnrpc_LightningStopDaemonSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningStopDaemonSessionBase: ServerSessionUnaryBase<Lnrpc_StopRequest, Lnrpc_StopResponse>, Lnrpc_LightningStopDaemonSession {}

internal protocol Lnrpc_LightningSubscribeChannelGraphSession: ServerSessionServerStreaming {
  /// Send a message to the stream. Nonblocking.
  func send(_ message: Lnrpc_GraphTopologyUpdate, completion: @escaping (Error?) -> Void) throws
  /// Do not call this directly, call `send()` in the protocol extension below instead.
  func _send(_ message: Lnrpc_GraphTopologyUpdate, timeout: DispatchTime) throws

  /// Close the connection and send the status. Non-blocking.
  /// This method should be called if and only if your request handler returns a nil value instead of a server status;
  /// otherwise SwiftGRPC will take care of sending the status for you.
  func close(withStatus status: ServerStatus, completion: (() -> Void)?) throws
}

internal extension Lnrpc_LightningSubscribeChannelGraphSession {
  /// Send a message to the stream and wait for the send operation to finish. Blocking.
  func send(_ message: Lnrpc_GraphTopologyUpdate, timeout: DispatchTime = .distantFuture) throws { try self._send(message, timeout: timeout) }
}

fileprivate final class Lnrpc_LightningSubscribeChannelGraphSessionBase: ServerSessionServerStreamingBase<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>, Lnrpc_LightningSubscribeChannelGraphSession {}

internal protocol Lnrpc_LightningDebugLevelSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningDebugLevelSessionBase: ServerSessionUnaryBase<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>, Lnrpc_LightningDebugLevelSession {}

internal protocol Lnrpc_LightningFeeReportSession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningFeeReportSessionBase: ServerSessionUnaryBase<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>, Lnrpc_LightningFeeReportSession {}

internal protocol Lnrpc_LightningUpdateChannelPolicySession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningUpdateChannelPolicySessionBase: ServerSessionUnaryBase<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>, Lnrpc_LightningUpdateChannelPolicySession {}

internal protocol Lnrpc_LightningForwardingHistorySession: ServerSessionUnary {}

fileprivate final class Lnrpc_LightningForwardingHistorySessionBase: ServerSessionUnaryBase<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>, Lnrpc_LightningForwardingHistorySession {}

