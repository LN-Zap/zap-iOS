// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: routerrpc/router.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Routerrpc_PaymentState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///*
  ///Payment is still in flight.
  case inFlight // = 0

  ///*
  ///Payment completed successfully.
  case succeeded // = 1

  ///*
  ///There are more routes to try, but the payment timeout was exceeded.
  case failedTimeout // = 2

  ///*
  ///All possible routes were tried and failed permanently. Or were no
  ///routes to the destination at all.
  case failedNoRoute // = 3

  ///*
  ///A non-recoverable error has occured.
  case failedError // = 4

  ///*
  ///Payment details incorrect (unknown hash, invalid amt or
  ///invalid final cltv delta)
  case failedIncorrectPaymentDetails // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .inFlight
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inFlight
    case 1: self = .succeeded
    case 2: self = .failedTimeout
    case 3: self = .failedNoRoute
    case 4: self = .failedError
    case 5: self = .failedIncorrectPaymentDetails
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .inFlight: return 0
    case .succeeded: return 1
    case .failedTimeout: return 2
    case .failedNoRoute: return 3
    case .failedError: return 4
    case .failedIncorrectPaymentDetails: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Routerrpc_PaymentState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_PaymentState] = [
    .inFlight,
    .succeeded,
    .failedTimeout,
    .failedNoRoute,
    .failedError,
    .failedIncorrectPaymentDetails,
  ]
}

#endif  // swift(>=4.2)

struct Routerrpc_SendPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the payment recipient
  var dest: Data = SwiftProtobuf.Internal.emptyData

  //// Number of satoshis to send.
  var amt: Int64 = 0

  //// The hash to use within the payment's HTLC
  var paymentHash: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///The CLTV delta from the current height that should be used to set the
  ///timelock for the final hop.
  var finalCltvDelta: Int32 = 0

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient. The amount in the payment request may be zero. In
  ///that case it is required to set the amt field as well. If no payment request
  ///is specified, the following fields are required: dest, amt and payment_hash.
  var paymentRequest: String = String()

  ///*
  ///An upper limit on the amount of time we should spend when attempting to
  ///fulfill the payment. This is expressed in seconds. If we cannot make a
  ///successful payment within this time frame, an error will be returned.
  ///This field must be non-zero.
  var timeoutSeconds: Int32 = 0

  ///*
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///If this field is left to the default value of 0, only zero-fee routes will
  ///be considered. This usually means single hop routes connecting directly to
  ///the destination. To send the payment without a fee limit, use max int here.
  var feeLimitSat: Int64 = 0

  ///*
  ///The channel id of the channel that must be taken to the first hop. If zero,
  ///any channel may be used.
  var outgoingChanID: UInt64 = 0

  ///* 
  ///An optional maximum total time lock for the route. If zero, there is no
  ///maximum enforced.
  var cltvLimit: Int32 = 0

  ///*
  ///Optional route hints to reach the destination through private channels.
  var routeHints: [Lnrpc_RouteHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_TrackPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The hash of the payment to look up.
  var paymentHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_PaymentStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Current state the payment is in.
  var state: Routerrpc_PaymentState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///*
  ///The pre-image of the payment when state is SUCCEEDED.
  var preimage: Data {
    get {return _storage._preimage}
    set {_uniqueStorage()._preimage = newValue}
  }

  ///*
  ///The taken route when state is SUCCEEDED.
  var route: Lnrpc_Route {
    get {return _storage._route ?? Lnrpc_Route()}
    set {_uniqueStorage()._route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return _storage._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {_uniqueStorage()._route = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Routerrpc_RouteFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The destination once wishes to obtain a routing fee quote to.
  var dest: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///The amount one wishes to send to the target destination.
  var amtSat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_RouteFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A lower bound of the estimated fee to the target destination within the
  ///network, expressed in milli-satoshis.
  var routingFeeMsat: Int64 = 0

  ///*
  ///An estimate of the worst case time delay that can occur. Note that callers
  ///will still need to factor in the final CLTV delta of the last hop into this
  ///value.
  var timeLockDelay: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_SendToRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment hash to use for the HTLC.
  var paymentHash: Data {
    get {return _storage._paymentHash}
    set {_uniqueStorage()._paymentHash = newValue}
  }

  //// Route that should be used to attempt to complete the payment.
  var route: Lnrpc_Route {
    get {return _storage._route ?? Lnrpc_Route()}
    set {_uniqueStorage()._route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return _storage._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {_uniqueStorage()._route = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Routerrpc_SendToRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The preimage obtained by making the payment.
  var preimage: Data {
    get {return _storage._preimage}
    set {_uniqueStorage()._preimage = newValue}
  }

  //// The failure message in case the payment failed.
  var failure: Routerrpc_Failure {
    get {return _storage._failure ?? Routerrpc_Failure()}
    set {_uniqueStorage()._failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return _storage._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {_uniqueStorage()._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Routerrpc_Failure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Failure code as defined in the Lightning spec
  var code: Routerrpc_Failure.FailureCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  //// An optional channel update message.
  var channelUpdate: Routerrpc_ChannelUpdate {
    get {return _storage._channelUpdate ?? Routerrpc_ChannelUpdate()}
    set {_uniqueStorage()._channelUpdate = newValue}
  }
  /// Returns true if `channelUpdate` has been explicitly set.
  var hasChannelUpdate: Bool {return _storage._channelUpdate != nil}
  /// Clears the value of `channelUpdate`. Subsequent reads from it will return its default value.
  mutating func clearChannelUpdate() {_uniqueStorage()._channelUpdate = nil}

  //// A failure type-dependent htlc value.
  var htlcMsat: UInt64 {
    get {return _storage._htlcMsat}
    set {_uniqueStorage()._htlcMsat = newValue}
  }

  //// The sha256 sum of the onion payload.
  var onionSha256: Data {
    get {return _storage._onionSha256}
    set {_uniqueStorage()._onionSha256 = newValue}
  }

  //// A failure type-dependent cltv expiry value.
  var cltvExpiry: UInt32 {
    get {return _storage._cltvExpiry}
    set {_uniqueStorage()._cltvExpiry = newValue}
  }

  //// A failure type-dependent flags value.
  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  ///*
  ///The position in the path of the intermediate or final node that generated
  ///the failure message. Position zero is the sender node.
  var failureSourceIndex: UInt32 {
    get {return _storage._failureSourceIndex}
    set {_uniqueStorage()._failureSourceIndex = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FailureCode: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///*
    ///The numbers assigned in this enumeration match the failure codes as
    ///defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
    ///a RESERVED value is added.
    case reserved // = 0
    case unknownPaymentHash // = 1
    case incorrectPaymentAmount // = 2
    case finalIncorrectCltvExpiry // = 3
    case finalIncorrectHtlcAmount // = 4
    case finalExpiryTooSoon // = 5
    case invalidRealm // = 6
    case expiryTooSoon // = 7
    case invalidOnionVersion // = 8
    case invalidOnionHmac // = 9
    case invalidOnionKey // = 10
    case amountBelowMinimum // = 11
    case feeInsufficient // = 12
    case incorrectCltvExpiry // = 13
    case channelDisabled // = 14
    case temporaryChannelFailure // = 15
    case requiredNodeFeatureMissing // = 16
    case requiredChannelFeatureMissing // = 17
    case unknownNextPeer // = 18
    case temporaryNodeFailure // = 19
    case permanentNodeFailure // = 20
    case permanentChannelFailure // = 21

    ///*
    ///The error source is known, but the failure itself couldn't be decoded.
    case unknownFailure // = 998

    ///*
    ///An unreadable failure result is returned if the received failure message
    ///cannot be decrypted. In that case the error source is unknown.
    case unreadableFailure // = 999
    case UNRECOGNIZED(Int)

    init() {
      self = .reserved
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reserved
      case 1: self = .unknownPaymentHash
      case 2: self = .incorrectPaymentAmount
      case 3: self = .finalIncorrectCltvExpiry
      case 4: self = .finalIncorrectHtlcAmount
      case 5: self = .finalExpiryTooSoon
      case 6: self = .invalidRealm
      case 7: self = .expiryTooSoon
      case 8: self = .invalidOnionVersion
      case 9: self = .invalidOnionHmac
      case 10: self = .invalidOnionKey
      case 11: self = .amountBelowMinimum
      case 12: self = .feeInsufficient
      case 13: self = .incorrectCltvExpiry
      case 14: self = .channelDisabled
      case 15: self = .temporaryChannelFailure
      case 16: self = .requiredNodeFeatureMissing
      case 17: self = .requiredChannelFeatureMissing
      case 18: self = .unknownNextPeer
      case 19: self = .temporaryNodeFailure
      case 20: self = .permanentNodeFailure
      case 21: self = .permanentChannelFailure
      case 998: self = .unknownFailure
      case 999: self = .unreadableFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reserved: return 0
      case .unknownPaymentHash: return 1
      case .incorrectPaymentAmount: return 2
      case .finalIncorrectCltvExpiry: return 3
      case .finalIncorrectHtlcAmount: return 4
      case .finalExpiryTooSoon: return 5
      case .invalidRealm: return 6
      case .expiryTooSoon: return 7
      case .invalidOnionVersion: return 8
      case .invalidOnionHmac: return 9
      case .invalidOnionKey: return 10
      case .amountBelowMinimum: return 11
      case .feeInsufficient: return 12
      case .incorrectCltvExpiry: return 13
      case .channelDisabled: return 14
      case .temporaryChannelFailure: return 15
      case .requiredNodeFeatureMissing: return 16
      case .requiredChannelFeatureMissing: return 17
      case .unknownNextPeer: return 18
      case .temporaryNodeFailure: return 19
      case .permanentNodeFailure: return 20
      case .permanentChannelFailure: return 21
      case .unknownFailure: return 998
      case .unreadableFailure: return 999
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Routerrpc_Failure.FailureCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_Failure.FailureCode] = [
    .reserved,
    .unknownPaymentHash,
    .incorrectPaymentAmount,
    .finalIncorrectCltvExpiry,
    .finalIncorrectHtlcAmount,
    .finalExpiryTooSoon,
    .invalidRealm,
    .expiryTooSoon,
    .invalidOnionVersion,
    .invalidOnionHmac,
    .invalidOnionKey,
    .amountBelowMinimum,
    .feeInsufficient,
    .incorrectCltvExpiry,
    .channelDisabled,
    .temporaryChannelFailure,
    .requiredNodeFeatureMissing,
    .requiredChannelFeatureMissing,
    .unknownNextPeer,
    .temporaryNodeFailure,
    .permanentNodeFailure,
    .permanentChannelFailure,
    .unknownFailure,
    .unreadableFailure,
  ]
}

#endif  // swift(>=4.2)

struct Routerrpc_ChannelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The signature that validates the announced data and proves the ownership
  ///of node id.
  var signature: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///The target chain that this channel was opened within. This value
  ///should be the genesis hash of the target chain. Along with the short
  ///channel ID, this uniquely identifies the channel globally in a
  ///blockchain.
  var chainHash: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///The unique description of the funding transaction.
  var chanID: UInt64 = 0

  ///*
  ///A timestamp that allows ordering in the case of multiple announcements.
  ///We should ignore the message if timestamp is not greater than the
  ///last-received.
  var timestamp: UInt32 = 0

  ///*
  ///The bitfield that describes whether optional fields are present in this
  ///update. Currently, the least-significant bit must be set to 1 if the
  ///optional field MaxHtlc is present.
  var messageFlags: UInt32 = 0

  ///*
  ///The bitfield that describes additional meta-data concerning how the
  ///update is to be interpreted. Currently, the least-significant bit must be
  ///set to 0 if the creating node corresponds to the first node in the
  ///previously sent channel announcement and 1 otherwise. If the second bit
  ///is set, then the channel is set to be disabled.
  var channelFlags: UInt32 = 0

  ///*
  ///The minimum number of blocks this node requires to be added to the expiry
  ///of HTLCs. This is a security parameter determined by the node operator.
  ///This value represents the required gap between the time locks of the
  ///incoming and outgoing HTLC's set to this node.
  var timeLockDelta: UInt32 = 0

  ///*
  ///The minimum HTLC value which will be accepted.
  var htlcMinimumMsat: UInt64 = 0

  ///*
  ///The base fee that must be used for incoming HTLC's to this particular
  ///channel. This value will be tacked onto the required for a payment
  ///independent of the size of the payment.
  var baseFee: UInt32 = 0

  ///*
  ///The fee rate that will be charged per millionth of a satoshi.
  var feeRate: UInt32 = 0

  ///*
  ///The maximum HTLC value which will be accepted.
  var htlcMaximumMsat: UInt64 = 0

  ///*
  ///The set of data that was appended to this message, some of which we may
  ///not actually know how to iterate or parse. By holding onto this data, we
  ///ensure that we're able to properly validate the set of signatures that
  ///cover these new fields, and ensure we're able to make upgrades to the
  ///network in a forwards compatible manner.
  var extraOpaqueData: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_ResetMissionControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_ResetMissionControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_QueryMissionControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// QueryMissionControlResponse contains mission control state per node.
struct Routerrpc_QueryMissionControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [Routerrpc_NodeHistory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// NodeHistory contains the mission control state for a particular node.
struct Routerrpc_NodeHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Node pubkey
  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  //// Time stamp of last failure. Set to zero if no failure happened yet.
  var lastFailTime: Int64 = 0

  //// Estimation of success probability for channels not in the channel array.
  var otherChanSuccessProb: Float = 0

  //// Historical information of particular channels.
  var channels: [Routerrpc_ChannelHistory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// NodeHistory contains the mission control state for a particular channel.
struct Routerrpc_ChannelHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Short channel id
  var channelID: UInt64 = 0

  //// Time stamp of last failure.
  var lastFailTime: Int64 = 0

  //// Minimum penalization amount.
  var minPenalizeAmtSat: Int64 = 0

  //// Estimation of success probability for this channel.
  var successProb: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "routerrpc"

extension Routerrpc_PaymentState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN_FLIGHT"),
    1: .same(proto: "SUCCEEDED"),
    2: .same(proto: "FAILED_TIMEOUT"),
    3: .same(proto: "FAILED_NO_ROUTE"),
    4: .same(proto: "FAILED_ERROR"),
    5: .same(proto: "FAILED_INCORRECT_PAYMENT_DETAILS"),
  ]
}

extension Routerrpc_SendPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .same(proto: "amt"),
    3: .standard(proto: "payment_hash"),
    4: .standard(proto: "final_cltv_delta"),
    5: .standard(proto: "payment_request"),
    6: .standard(proto: "timeout_seconds"),
    7: .standard(proto: "fee_limit_sat"),
    8: .standard(proto: "outgoing_chan_id"),
    9: .standard(proto: "cltv_limit"),
    10: .same(proto: "route_hints"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.dest)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amt)
      case 3: try decoder.decodeSingularBytesField(value: &self.paymentHash)
      case 4: try decoder.decodeSingularInt32Field(value: &self.finalCltvDelta)
      case 5: try decoder.decodeSingularStringField(value: &self.paymentRequest)
      case 6: try decoder.decodeSingularInt32Field(value: &self.timeoutSeconds)
      case 7: try decoder.decodeSingularInt64Field(value: &self.feeLimitSat)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.outgoingChanID)
      case 9: try decoder.decodeSingularInt32Field(value: &self.cltvLimit)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.routeHints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularBytesField(value: self.dest, fieldNumber: 1)
    }
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 2)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 3)
    }
    if self.finalCltvDelta != 0 {
      try visitor.visitSingularInt32Field(value: self.finalCltvDelta, fieldNumber: 4)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 5)
    }
    if self.timeoutSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSeconds, fieldNumber: 6)
    }
    if self.feeLimitSat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimitSat, fieldNumber: 7)
    }
    if self.outgoingChanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingChanID, fieldNumber: 8)
    }
    if self.cltvLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.cltvLimit, fieldNumber: 9)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendPaymentRequest, rhs: Routerrpc_SendPaymentRequest) -> Bool {
    if lhs.dest != rhs.dest {return false}
    if lhs.amt != rhs.amt {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.finalCltvDelta != rhs.finalCltvDelta {return false}
    if lhs.paymentRequest != rhs.paymentRequest {return false}
    if lhs.timeoutSeconds != rhs.timeoutSeconds {return false}
    if lhs.feeLimitSat != rhs.feeLimitSat {return false}
    if lhs.outgoingChanID != rhs.outgoingChanID {return false}
    if lhs.cltvLimit != rhs.cltvLimit {return false}
    if lhs.routeHints != rhs.routeHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_TrackPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.paymentHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_TrackPaymentRequest, rhs: Routerrpc_TrackPaymentRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_PaymentStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "preimage"),
    3: .same(proto: "route"),
  ]

  fileprivate class _StorageClass {
    var _state: Routerrpc_PaymentState = .inFlight
    var _preimage: Data = SwiftProtobuf.Internal.emptyData
    var _route: Lnrpc_Route? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _state = source._state
      _preimage = source._preimage
      _route = source._route
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._state)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._preimage)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._route)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._state != .inFlight {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 1)
      }
      if !_storage._preimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._preimage, fieldNumber: 2)
      }
      if let v = _storage._route {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_PaymentStatus, rhs: Routerrpc_PaymentStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._state != rhs_storage._state {return false}
        if _storage._preimage != rhs_storage._preimage {return false}
        if _storage._route != rhs_storage._route {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_RouteFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "amt_sat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.dest)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amtSat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularBytesField(value: self.dest, fieldNumber: 1)
    }
    if self.amtSat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtSat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_RouteFeeRequest, rhs: Routerrpc_RouteFeeRequest) -> Bool {
    if lhs.dest != rhs.dest {return false}
    if lhs.amtSat != rhs.amtSat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_RouteFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "routing_fee_msat"),
    2: .standard(proto: "time_lock_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.routingFeeMsat)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timeLockDelay)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.routingFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.routingFeeMsat, fieldNumber: 1)
    }
    if self.timeLockDelay != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockDelay, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_RouteFeeResponse, rhs: Routerrpc_RouteFeeResponse) -> Bool {
    if lhs.routingFeeMsat != rhs.routingFeeMsat {return false}
    if lhs.timeLockDelay != rhs.timeLockDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SendToRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .same(proto: "route"),
  ]

  fileprivate class _StorageClass {
    var _paymentHash: Data = SwiftProtobuf.Internal.emptyData
    var _route: Lnrpc_Route? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paymentHash = source._paymentHash
      _route = source._route
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._paymentHash)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._route)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._paymentHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentHash, fieldNumber: 1)
      }
      if let v = _storage._route {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendToRouteRequest, rhs: Routerrpc_SendToRouteRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paymentHash != rhs_storage._paymentHash {return false}
        if _storage._route != rhs_storage._route {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SendToRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preimage"),
    2: .same(proto: "failure"),
  ]

  fileprivate class _StorageClass {
    var _preimage: Data = SwiftProtobuf.Internal.emptyData
    var _failure: Routerrpc_Failure? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _preimage = source._preimage
      _failure = source._failure
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._preimage)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._failure)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._preimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._preimage, fieldNumber: 1)
      }
      if let v = _storage._failure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendToRouteResponse, rhs: Routerrpc_SendToRouteResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._preimage != rhs_storage._preimage {return false}
        if _storage._failure != rhs_storage._failure {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Failure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .standard(proto: "channel_update"),
    4: .standard(proto: "htlc_msat"),
    5: .standard(proto: "onion_sha_256"),
    6: .standard(proto: "cltv_expiry"),
    7: .same(proto: "flags"),
    8: .standard(proto: "failure_source_index"),
  ]

  fileprivate class _StorageClass {
    var _code: Routerrpc_Failure.FailureCode = .reserved
    var _channelUpdate: Routerrpc_ChannelUpdate? = nil
    var _htlcMsat: UInt64 = 0
    var _onionSha256: Data = SwiftProtobuf.Internal.emptyData
    var _cltvExpiry: UInt32 = 0
    var _flags: UInt32 = 0
    var _failureSourceIndex: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _channelUpdate = source._channelUpdate
      _htlcMsat = source._htlcMsat
      _onionSha256 = source._onionSha256
      _cltvExpiry = source._cltvExpiry
      _flags = source._flags
      _failureSourceIndex = source._failureSourceIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._channelUpdate)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._htlcMsat)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._onionSha256)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._cltvExpiry)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._failureSourceIndex)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .reserved {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._channelUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._htlcMsat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._htlcMsat, fieldNumber: 4)
      }
      if !_storage._onionSha256.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._onionSha256, fieldNumber: 5)
      }
      if _storage._cltvExpiry != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cltvExpiry, fieldNumber: 6)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 7)
      }
      if _storage._failureSourceIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._failureSourceIndex, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_Failure, rhs: Routerrpc_Failure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._channelUpdate != rhs_storage._channelUpdate {return false}
        if _storage._htlcMsat != rhs_storage._htlcMsat {return false}
        if _storage._onionSha256 != rhs_storage._onionSha256 {return false}
        if _storage._cltvExpiry != rhs_storage._cltvExpiry {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._failureSourceIndex != rhs_storage._failureSourceIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_Failure.FailureCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESERVED"),
    1: .same(proto: "UNKNOWN_PAYMENT_HASH"),
    2: .same(proto: "INCORRECT_PAYMENT_AMOUNT"),
    3: .same(proto: "FINAL_INCORRECT_CLTV_EXPIRY"),
    4: .same(proto: "FINAL_INCORRECT_HTLC_AMOUNT"),
    5: .same(proto: "FINAL_EXPIRY_TOO_SOON"),
    6: .same(proto: "INVALID_REALM"),
    7: .same(proto: "EXPIRY_TOO_SOON"),
    8: .same(proto: "INVALID_ONION_VERSION"),
    9: .same(proto: "INVALID_ONION_HMAC"),
    10: .same(proto: "INVALID_ONION_KEY"),
    11: .same(proto: "AMOUNT_BELOW_MINIMUM"),
    12: .same(proto: "FEE_INSUFFICIENT"),
    13: .same(proto: "INCORRECT_CLTV_EXPIRY"),
    14: .same(proto: "CHANNEL_DISABLED"),
    15: .same(proto: "TEMPORARY_CHANNEL_FAILURE"),
    16: .same(proto: "REQUIRED_NODE_FEATURE_MISSING"),
    17: .same(proto: "REQUIRED_CHANNEL_FEATURE_MISSING"),
    18: .same(proto: "UNKNOWN_NEXT_PEER"),
    19: .same(proto: "TEMPORARY_NODE_FAILURE"),
    20: .same(proto: "PERMANENT_NODE_FAILURE"),
    21: .same(proto: "PERMANENT_CHANNEL_FAILURE"),
    998: .same(proto: "UNKNOWN_FAILURE"),
    999: .same(proto: "UNREADABLE_FAILURE"),
  ]
}

extension Routerrpc_ChannelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "chain_hash"),
    3: .standard(proto: "chan_id"),
    4: .same(proto: "timestamp"),
    10: .standard(proto: "message_flags"),
    5: .standard(proto: "channel_flags"),
    6: .standard(proto: "time_lock_delta"),
    7: .standard(proto: "htlc_minimum_msat"),
    8: .standard(proto: "base_fee"),
    9: .standard(proto: "fee_rate"),
    11: .standard(proto: "htlc_maximum_msat"),
    12: .standard(proto: "extra_opaque_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signature)
      case 2: try decoder.decodeSingularBytesField(value: &self.chainHash)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.timestamp)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.channelFlags)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.htlcMinimumMsat)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.baseFee)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.feeRate)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.messageFlags)
      case 11: try decoder.decodeSingularUInt64Field(value: &self.htlcMaximumMsat)
      case 12: try decoder.decodeSingularBytesField(value: &self.extraOpaqueData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.chainHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.chainHash, fieldNumber: 2)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.channelFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelFlags, fieldNumber: 5)
    }
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 6)
    }
    if self.htlcMinimumMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcMinimumMsat, fieldNumber: 7)
    }
    if self.baseFee != 0 {
      try visitor.visitSingularUInt32Field(value: self.baseFee, fieldNumber: 8)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeRate, fieldNumber: 9)
    }
    if self.messageFlags != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageFlags, fieldNumber: 10)
    }
    if self.htlcMaximumMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcMaximumMsat, fieldNumber: 11)
    }
    if !self.extraOpaqueData.isEmpty {
      try visitor.visitSingularBytesField(value: self.extraOpaqueData, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ChannelUpdate, rhs: Routerrpc_ChannelUpdate) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.chainHash != rhs.chainHash {return false}
    if lhs.chanID != rhs.chanID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.messageFlags != rhs.messageFlags {return false}
    if lhs.channelFlags != rhs.channelFlags {return false}
    if lhs.timeLockDelta != rhs.timeLockDelta {return false}
    if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {return false}
    if lhs.baseFee != rhs.baseFee {return false}
    if lhs.feeRate != rhs.feeRate {return false}
    if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {return false}
    if lhs.extraOpaqueData != rhs.extraOpaqueData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ResetMissionControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetMissionControlRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ResetMissionControlRequest, rhs: Routerrpc_ResetMissionControlRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ResetMissionControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetMissionControlResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ResetMissionControlResponse, rhs: Routerrpc_ResetMissionControlResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryMissionControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMissionControlRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryMissionControlRequest, rhs: Routerrpc_QueryMissionControlRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryMissionControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMissionControlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryMissionControlResponse, rhs: Routerrpc_QueryMissionControlResponse) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_NodeHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "last_fail_time"),
    3: .same(proto: "other_chan_success_prob"),
    4: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 2: try decoder.decodeSingularInt64Field(value: &self.lastFailTime)
      case 3: try decoder.decodeSingularFloatField(value: &self.otherChanSuccessProb)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.channels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if self.lastFailTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastFailTime, fieldNumber: 2)
    }
    if self.otherChanSuccessProb != 0 {
      try visitor.visitSingularFloatField(value: self.otherChanSuccessProb, fieldNumber: 3)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_NodeHistory, rhs: Routerrpc_NodeHistory) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.lastFailTime != rhs.lastFailTime {return false}
    if lhs.otherChanSuccessProb != rhs.otherChanSuccessProb {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ChannelHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_id"),
    2: .same(proto: "last_fail_time"),
    3: .same(proto: "min_penalize_amt_sat"),
    4: .same(proto: "success_prob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.channelID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.lastFailTime)
      case 3: try decoder.decodeSingularInt64Field(value: &self.minPenalizeAmtSat)
      case 4: try decoder.decodeSingularFloatField(value: &self.successProb)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    if self.lastFailTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastFailTime, fieldNumber: 2)
    }
    if self.minPenalizeAmtSat != 0 {
      try visitor.visitSingularInt64Field(value: self.minPenalizeAmtSat, fieldNumber: 3)
    }
    if self.successProb != 0 {
      try visitor.visitSingularFloatField(value: self.successProb, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ChannelHistory, rhs: Routerrpc_ChannelHistory) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.lastFailTime != rhs.lastFailTime {return false}
    if lhs.minPenalizeAmtSat != rhs.minPenalizeAmtSat {return false}
    if lhs.successProb != rhs.successProb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
