// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///* 
///`AddressType` has to be one of:
///
///- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
///- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
enum Lnrpc_AddressType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case witnessPubkeyHash // = 0
  case nestedPubkeyHash // = 1
  case unusedWitnessPubkeyHash // = 2
  case unusedNestedPubkeyHash // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .witnessPubkeyHash
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .witnessPubkeyHash
    case 1: self = .nestedPubkeyHash
    case 2: self = .unusedWitnessPubkeyHash
    case 3: self = .unusedNestedPubkeyHash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .witnessPubkeyHash: return 0
    case .nestedPubkeyHash: return 1
    case .unusedWitnessPubkeyHash: return 2
    case .unusedNestedPubkeyHash: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Lnrpc_AddressType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_AddressType] = [
    .witnessPubkeyHash,
    .nestedPubkeyHash,
    .unusedWitnessPubkeyHash,
    .unusedNestedPubkeyHash
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_GenSeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed.
  var aezeedPassphrase: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///seed_entropy is an optional 16-bytes generated via CSPRNG. If not
  ///specified, then a fresh set of randomness will be used to create the seed.
  var seedEntropy: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GenSeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This field is optional, as if not
  ///provided, then the daemon will generate a new cipher seed for the user.
  ///Otherwise, then the daemon will attempt to recover the wallet state linked
  ///to this cipher seed.
  var cipherSeedMnemonic: [String] = []

  ///*
  ///enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
  ///cipher text before run through our mnemonic encoding scheme.
  var encipheredSeed: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InitWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///wallet_password is the passphrase that should be used to encrypt the
  ///wallet. This MUST be at least 8 chars in length. After creation, this
  ///password is required to unlock the daemon.
  var walletPassword: Data {
    get { return _storage._walletPassword }
    set { _uniqueStorage()._walletPassword = newValue }
  }

  ///*
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This may have been generated by the
  ///GenSeed method, or be an existing seed.
  var cipherSeedMnemonic: [String] {
    get { return _storage._cipherSeedMnemonic }
    set { _uniqueStorage()._cipherSeedMnemonic = newValue }
  }

  ///*
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed.
  var aezeedPassphrase: Data {
    get { return _storage._aezeedPassphrase }
    set { _uniqueStorage()._aezeedPassphrase = newValue }
  }

  ///*
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///individual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 {
    get { return _storage._recoveryWindow }
    set { _uniqueStorage()._recoveryWindow = newValue }
  }

  ///*
  ///channel_backups is an optional argument that allows clients to recover the
  ///settled funds within a set of channels. This should be populated if the
  ///user was unable to close out all channels and sweep funds before partial or
  ///total data loss occurred. If specified, then after on-chain recovery of
  ///funds, lnd begin to carry out the data loss recovery protocol in order to
  ///recover the funds in each channel from a remote force closed transaction.
  var channelBackups: Lnrpc_ChanBackupSnapshot {
    get { return _storage._channelBackups ?? Lnrpc_ChanBackupSnapshot() }
    set { _uniqueStorage()._channelBackups = newValue }
  }
  /// Returns true if `channelBackups` has been explicitly set.
  var hasChannelBackups: Bool { return _storage._channelBackups != nil }
  /// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
  mutating func clearChannelBackups() { _uniqueStorage()._channelBackups = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_InitWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_UnlockWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///wallet_password should be the current valid passphrase for the daemon. This
  ///will be required to decrypt on-disk material that the daemon requires to
  ///function properly.
  var walletPassword: Data {
    get { return _storage._walletPassword }
    set { _uniqueStorage()._walletPassword = newValue }
  }

  ///*
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 {
    get { return _storage._recoveryWindow }
    set { _uniqueStorage()._recoveryWindow = newValue }
  }

  ///*
  ///channel_backups is an optional argument that allows clients to recover the
  ///settled funds within a set of channels. This should be populated if the
  ///user was unable to close out all channels and sweep funds before partial or
  ///total data loss occurred. If specified, then after on-chain recovery of
  ///funds, lnd begin to carry out the data loss recovery protocol in order to
  ///recover the funds in each channel from a remote force closed transaction.
  var channelBackups: Lnrpc_ChanBackupSnapshot {
    get { return _storage._channelBackups ?? Lnrpc_ChanBackupSnapshot() }
    set { _uniqueStorage()._channelBackups = newValue }
  }
  /// Returns true if `channelBackups` has been explicitly set.
  var hasChannelBackups: Bool { return _storage._channelBackups != nil }
  /// Clears the value of `channelBackups`. Subsequent reads from it will return its default value.
  mutating func clearChannelBackups() { _uniqueStorage()._channelBackups = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_UnlockWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChangePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///current_password should be the current valid passphrase used to unlock the
  ///daemon.
  var currentPassword: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///new_password should be the new passphrase that will be needed to unlock the
  ///daemon.
  var newPassword: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChangePasswordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Utxo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The type of address
  var type: Lnrpc_AddressType {
    get { return _storage._type }
    set { _uniqueStorage()._type = newValue }
  }

  //// The address
  var address: String {
    get { return _storage._address }
    set { _uniqueStorage()._address = newValue }
  }

  //// The value of the unspent coin in satoshis
  var amountSat: Int64 {
    get { return _storage._amountSat }
    set { _uniqueStorage()._amountSat = newValue }
  }

  //// The pkscript in hex
  var pkScript: String {
    get { return _storage._pkScript }
    set { _uniqueStorage()._pkScript = newValue }
  }

  //// The outpoint in format txid:n
  var outpoint: Lnrpc_OutPoint {
    get { return _storage._outpoint ?? Lnrpc_OutPoint() }
    set { _uniqueStorage()._outpoint = newValue }
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool { return _storage._outpoint != nil }
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() { _uniqueStorage()._outpoint = nil }

  //// The number of confirmations for the Utxo
  var confirmations: Int64 {
    get { return _storage._confirmations }
    set { _uniqueStorage()._confirmations = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The transaction hash
  var txHash: String = String()

  //// The transaction amount, denominated in satoshis
  var amount: Int64 = 0

  //// The number of confirmations
  var numConfirmations: Int32 = 0

  //// The hash of the block this transaction was included in
  var blockHash: String = String()

  //// The height of the block this transaction was included in
  var blockHeight: Int32 = 0

  //// Timestamp of this transaction 
  var timeStamp: Int64 = 0

  //// Fees paid for this transaction
  var totalFees: Int64 = 0

  //// Addresses that received funds for this transaction
  var destAddresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_TransactionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of transactions relevant to the wallet.
  var transactions: [Lnrpc_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limit: Lnrpc_FeeLimit.OneOf_Limit?

  //// The fee limit expressed as a fixed amount of satoshis.
  var fixed: Int64 {
    get {
      if case .fixed(let v)? = limit { return v }
      return 0
    }
    set { limit = .fixed(newValue) }
  }

  //// The fee limit expressed as a percentage of the payment amount.
  var percent: Int64 {
    get {
      if case .percent(let v)? = limit { return v }
      return 0
    }
    set { limit = .percent(newValue) }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Limit: Equatable {
    //// The fee limit expressed as a fixed amount of satoshis.
    case fixed(Int64)
    //// The fee limit expressed as a percentage of the payment amount.
    case percent(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_FeeLimit.OneOf_Limit, rhs: Lnrpc_FeeLimit.OneOf_Limit) -> Bool {
      switch (lhs, rhs) {
      case (.fixed(let l), .fixed(let r)): return l == r
      case (.percent(let l), .percent(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_SendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the payment recipient
  var dest: Data {
    get { return _storage._dest }
    set { _uniqueStorage()._dest = newValue }
  }

  //// The hex-encoded identity pubkey of the payment recipient
  var destString: String {
    get { return _storage._destString }
    set { _uniqueStorage()._destString = newValue }
  }

  //// Number of satoshis to send.
  var amt: Int64 {
    get { return _storage._amt }
    set { _uniqueStorage()._amt = newValue }
  }

  //// The hash to use within the payment's HTLC
  var paymentHash: Data {
    get { return _storage._paymentHash }
    set { _uniqueStorage()._paymentHash = newValue }
  }

  //// The hex-encoded hash to use within the payment's HTLC
  var paymentHashString: String {
    get { return _storage._paymentHashString }
    set { _uniqueStorage()._paymentHashString = newValue }
  }

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String {
    get { return _storage._paymentRequest }
    set { _uniqueStorage()._paymentRequest = newValue }
  }

  ///*
  ///The CLTV delta from the current height that should be used to set the
  ///timelock for the final hop.
  var finalCltvDelta: Int32 {
    get { return _storage._finalCltvDelta }
    set { _uniqueStorage()._finalCltvDelta = newValue }
  }

  ///*
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///This value can be represented either as a percentage of the amount being
  ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
  ///send the payment.
  var feeLimit: Lnrpc_FeeLimit {
    get { return _storage._feeLimit ?? Lnrpc_FeeLimit() }
    set { _uniqueStorage()._feeLimit = newValue }
  }
  /// Returns true if `feeLimit` has been explicitly set.
  var hasFeeLimit: Bool { return _storage._feeLimit != nil }
  /// Clears the value of `feeLimit`. Subsequent reads from it will return its default value.
  mutating func clearFeeLimit() { _uniqueStorage()._feeLimit = nil }

  ///*
  ///The channel id of the channel that must be taken to the first hop. If zero,
  ///any channel may be used.
  var outgoingChanID: UInt64 {
    get { return _storage._outgoingChanID }
    set { _uniqueStorage()._outgoingChanID = newValue }
  }

  ///* 
  ///An optional maximum total time lock for the route. If zero, there is no
  ///maximum enforced.
  var cltvLimit: UInt32 {
    get { return _storage._cltvLimit }
    set { _uniqueStorage()._cltvLimit = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_SendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentError: String {
    get { return _storage._paymentError }
    set { _uniqueStorage()._paymentError = newValue }
  }

  var paymentPreimage: Data {
    get { return _storage._paymentPreimage }
    set { _uniqueStorage()._paymentPreimage = newValue }
  }

  var paymentRoute: Lnrpc_Route {
    get { return _storage._paymentRoute ?? Lnrpc_Route() }
    set { _uniqueStorage()._paymentRoute = newValue }
  }
  /// Returns true if `paymentRoute` has been explicitly set.
  var hasPaymentRoute: Bool { return _storage._paymentRoute != nil }
  /// Clears the value of `paymentRoute`. Subsequent reads from it will return its default value.
  mutating func clearPaymentRoute() { _uniqueStorage()._paymentRoute = nil }

  var paymentHash: Data {
    get { return _storage._paymentHash }
    set { _uniqueStorage()._paymentHash = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_SendToRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment hash to use for the HTLC.
  var paymentHash: Data {
    get { return _storage._paymentHash }
    set { _uniqueStorage()._paymentHash = newValue }
  }

  //// An optional hex-encoded payment hash to be used for the HTLC.
  var paymentHashString: String {
    get { return _storage._paymentHashString }
    set { _uniqueStorage()._paymentHashString = newValue }
  }

  ///*
  ///Deprecated. The set of routes that should be used to attempt to complete the
  ///payment. The possibility to pass in multiple routes is deprecated and 
  ///instead the single route field below should be used in combination with the 
  ///streaming variant of SendToRoute.
  var routes: [Lnrpc_Route] {
    get { return _storage._routes }
    set { _uniqueStorage()._routes = newValue }
  }

  //// Route that should be used to attempt to complete the payment.
  var route: Lnrpc_Route {
    get { return _storage._route ?? Lnrpc_Route() }
    set { _uniqueStorage()._route = newValue }
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool { return _storage._route != nil }
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() { _uniqueStorage()._route = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundingTxid: Lnrpc_ChannelPoint.OneOf_FundingTxid?

  //// Txid of the funding transaction
  var fundingTxidBytes: Data {
    get {
      if case .fundingTxidBytes(let v)? = fundingTxid { return v }
      return SwiftProtobuf.Internal.emptyData
    }
    set { fundingTxid = .fundingTxidBytes(newValue) }
  }

  //// Hex-encoded string representing the funding transaction
  var fundingTxidStr: String {
    get {
      if case .fundingTxidStr(let v)? = fundingTxid { return v }
      return String()
    }
    set { fundingTxid = .fundingTxidStr(newValue) }
  }

  //// The index of the output of the funding transaction
  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_FundingTxid: Equatable {
    //// Txid of the funding transaction
    case fundingTxidBytes(Data)
    //// Hex-encoded string representing the funding transaction
    case fundingTxidStr(String)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_ChannelPoint.OneOf_FundingTxid, rhs: Lnrpc_ChannelPoint.OneOf_FundingTxid) -> Bool {
      switch (lhs, rhs) {
      case (.fundingTxidBytes(let l), .fundingTxidBytes(let r)): return l == r
      case (.fundingTxidStr(let l), .fundingTxidStr(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Lnrpc_OutPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Raw bytes representing the transaction id.
  var txidBytes: Data = SwiftProtobuf.Internal.emptyData

  //// Reversed, hex-encoded string representing the transaction id.
  var txidStr: String = String()

  //// The index of the output on the transaction.
  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_LightningAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the Lightning node
  var pubkey: String = String()

  //// The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
  var host: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The map from addresses to amounts for the transaction.
  var addrToAmount: Dictionary<String, Int64> = [:]

  //// The target number of blocks that this transaction should be confirmed by.
  var targetConf: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The total fee in satoshis.
  var feeSat: Int64 = 0

  //// The fee rate in satoshi/byte.
  var feerateSatPerByte: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The map from addresses to amounts
  var addrToAmount: Dictionary<String, Int64> = [:]

  //// The target number of blocks that this transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
  var satPerByte: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The id of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The address to send coins to 
  var addr: String = String()

  //// The amount in satoshis to send
  var amount: Int64 = 0

  //// The target number of blocks that this transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
  var satPerByte: Int64 = 0

  ///*
  ///If set, then the amount field will be ignored, and lnd will attempt to
  ///send all the coins under control of the internal wallet to the specified
  ///address.
  var sendAll: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The transaction ID of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListUnspentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  //// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListUnspentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of utxos
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NewAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The address type
  var type: Lnrpc_AddressType = .witnessPubkeyHash

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NewAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The newly generated wallet address
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The message to be signed
  var msg: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The signature for the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The message over which the signature is to be verified
  var msg: Data = SwiftProtobuf.Internal.emptyData

  //// The signature to be verified over the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Whether the signature was valid over the given message
  var valid: Bool = false

  //// The pubkey recovered from the signature
  var pubkey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Lightning address of the peer, in the format `<pubkey>@host`
  var addr: Lnrpc_LightningAddress {
    get { return _storage._addr ?? Lnrpc_LightningAddress() }
    set { _uniqueStorage()._addr = newValue }
  }
  /// Returns true if `addr` has been explicitly set.
  var hasAddr: Bool { return _storage._addr != nil }
  /// Clears the value of `addr`. Subsequent reads from it will return its default value.
  mutating func clearAddr() { _uniqueStorage()._addr = nil }

  ///* If set, the daemon will attempt to persistently connect to the target
  /// peer.  Otherwise, the call will be synchronous. 
  var perm: Bool {
    get { return _storage._perm }
    set { _uniqueStorage()._perm = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ConnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The pubkey of the node to disconnect from
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_HTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var incoming: Bool = false

  var amount: Int64 = 0

  var hashLock: Data = SwiftProtobuf.Internal.emptyData

  var expirationHeight: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Whether this channel is active or not
  var active: Bool {
    get { return _storage._active }
    set { _uniqueStorage()._active = newValue }
  }

  //// The identity pubkey of the remote node
  var remotePubkey: String {
    get { return _storage._remotePubkey }
    set { _uniqueStorage()._remotePubkey = newValue }
  }

  ///*
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: String {
    get { return _storage._channelPoint }
    set { _uniqueStorage()._channelPoint = newValue }
  }

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get { return _storage._chanID }
    set { _uniqueStorage()._chanID = newValue }
  }

  //// The total amount of funds held in this channel
  var capacity: Int64 {
    get { return _storage._capacity }
    set { _uniqueStorage()._capacity = newValue }
  }

  //// This node's current balance in this channel
  var localBalance: Int64 {
    get { return _storage._localBalance }
    set { _uniqueStorage()._localBalance = newValue }
  }

  //// The counterparty's current balance in this channel
  var remoteBalance: Int64 {
    get { return _storage._remoteBalance }
    set { _uniqueStorage()._remoteBalance = newValue }
  }

  ///*
  ///The amount calculated to be paid in fees for the current set of commitment
  ///transactions. The fee amount is persisted with the channel in order to
  ///allow the fee amount to be removed and recalculated with each channel state
  ///update, including updates that happen after a system restart.
  var commitFee: Int64 {
    get { return _storage._commitFee }
    set { _uniqueStorage()._commitFee = newValue }
  }

  //// The weight of the commitment transaction
  var commitWeight: Int64 {
    get { return _storage._commitWeight }
    set { _uniqueStorage()._commitWeight = newValue }
  }

  ///*
  ///The required number of satoshis per kilo-weight that the requester will pay
  ///at all times, for both the funding transaction and commitment transaction.
  ///This value can later be updated once the channel is open.
  var feePerKw: Int64 {
    get { return _storage._feePerKw }
    set { _uniqueStorage()._feePerKw = newValue }
  }

  //// The unsettled balance in this channel
  var unsettledBalance: Int64 {
    get { return _storage._unsettledBalance }
    set { _uniqueStorage()._unsettledBalance = newValue }
  }

  ///*
  ///The total number of satoshis we've sent within this channel.
  var totalSatoshisSent: Int64 {
    get { return _storage._totalSatoshisSent }
    set { _uniqueStorage()._totalSatoshisSent = newValue }
  }

  ///*
  ///The total number of satoshis we've received within this channel.
  var totalSatoshisReceived: Int64 {
    get { return _storage._totalSatoshisReceived }
    set { _uniqueStorage()._totalSatoshisReceived = newValue }
  }

  ///*
  ///The total number of updates conducted within this channel.
  var numUpdates: UInt64 {
    get { return _storage._numUpdates }
    set { _uniqueStorage()._numUpdates = newValue }
  }

  ///*
  ///The list of active, uncleared HTLCs currently pending within the channel.
  var pendingHtlcs: [Lnrpc_HTLC] {
    get { return _storage._pendingHtlcs }
    set { _uniqueStorage()._pendingHtlcs = newValue }
  }

  ///*
  ///The CSV delay expressed in relative blocks. If the channel is force closed,
  ///we will need to wait for this many blocks before we can regain our funds.
  var csvDelay: UInt32 {
    get { return _storage._csvDelay }
    set { _uniqueStorage()._csvDelay = newValue }
  }

  //// Whether this channel is advertised to the network or not.
  var `private`: Bool {
    get { return _storage._private }
    set { _uniqueStorage()._private = newValue }
  }

  //// True if we were the ones that created the channel.
  var initiator: Bool {
    get { return _storage._initiator }
    set { _uniqueStorage()._initiator = newValue }
  }

  //// A set of flags showing the current state of the cahnnel.
  var chanStatusFlags: String {
    get { return _storage._chanStatusFlags }
    set { _uniqueStorage()._chanStatusFlags = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ListChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeOnly: Bool = false

  var inactiveOnly: Bool = false

  var publicOnly: Bool = false

  var privateOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of active channels
  var channels: [Lnrpc_Channel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelCloseSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The outpoint (txid:index) of the funding transaction. 
  var channelPoint: String = String()

  ////  The unique channel ID for the channel. 
  var chanID: UInt64 = 0

  //// The hash of the genesis block that this channel resides within.
  var chainHash: String = String()

  //// The txid of the transaction which ultimately closed this channel.
  var closingTxHash: String = String()

  //// Public key of the remote peer that we formerly had a channel with.
  var remotePubkey: String = String()

  //// Total capacity of the channel.
  var capacity: Int64 = 0

  //// Height at which the funding transaction was spent.
  var closeHeight: UInt32 = 0

  //// Settled balance at the time of channel closure
  var settledBalance: Int64 = 0

  //// The sum of all the time-locked outputs at the time of channel closure
  var timeLockedBalance: Int64 = 0

  //// Details on how the channel was closed.
  var closeType: Lnrpc_ChannelCloseSummary.ClosureType = .cooperativeClose

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ClosureType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case cooperativeClose // = 0
    case localForceClose // = 1
    case remoteForceClose // = 2
    case breachClose // = 3
    case fundingCanceled // = 4
    case abandoned // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .cooperativeClose
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cooperativeClose
      case 1: self = .localForceClose
      case 2: self = .remoteForceClose
      case 3: self = .breachClose
      case 4: self = .fundingCanceled
      case 5: self = .abandoned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cooperativeClose: return 0
      case .localForceClose: return 1
      case .remoteForceClose: return 2
      case .breachClose: return 3
      case .fundingCanceled: return 4
      case .abandoned: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_ChannelCloseSummary.ClosureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ChannelCloseSummary.ClosureType] = [
    .cooperativeClose,
    .localForceClose,
    .remoteForceClose,
    .breachClose,
    .fundingCanceled,
    .abandoned
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_ClosedChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cooperative: Bool = false

  var localForce: Bool = false

  var remoteForce: Bool = false

  var breach: Bool = false

  var fundingCanceled: Bool = false

  var abandoned: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ClosedChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Lnrpc_ChannelCloseSummary] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Peer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the peer
  var pubKey: String = String()

  //// Network address of the peer; eg `127.0.0.1:10011`
  var address: String = String()

  //// Bytes of data transmitted to this peer
  var bytesSent: UInt64 = 0

  //// Bytes of data transmitted from this peer
  var bytesRecv: UInt64 = 0

  //// Satoshis sent to this peer
  var satSent: Int64 = 0

  //// Satoshis received from this peer
  var satRecv: Int64 = 0

  //// A channel is inbound if the counterparty initiated the channel
  var inbound: Bool = false

  //// Ping time to this peer
  var pingTime: Int64 = 0

  /// The type of sync we are currently performing with this peer.
  var syncType: Lnrpc_Peer.SyncType = .unknownSync

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SyncType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///*
    ///Denotes that we cannot determine the peer's current sync type.
    case unknownSync // = 0

    ///*
    ///Denotes that we are actively receiving new graph updates from the peer.
    case activeSync // = 1

    ///*
    ///Denotes that we are not receiving new graph updates from the peer.
    case passiveSync // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownSync
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSync
      case 1: self = .activeSync
      case 2: self = .passiveSync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownSync: return 0
      case .activeSync: return 1
      case .passiveSync: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Lnrpc_Peer.SyncType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Peer.SyncType] = [
    .unknownSync,
    .activeSync,
    .passiveSync
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_ListPeersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPeersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of currently connected peers
  var peers: [Lnrpc_Peer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the current node.
  var identityPubkey: String = String()

  //// If applicable, the alias of the current node, e.g. "bob"
  var alias: String = String()

  //// Number of pending channels
  var numPendingChannels: UInt32 = 0

  //// Number of active channels
  var numActiveChannels: UInt32 = 0

  //// Number of peers
  var numPeers: UInt32 = 0

  //// The node's current view of the height of the best block
  var blockHeight: UInt32 = 0

  //// The node's current view of the hash of the best block
  var blockHash: String = String()

  //// Whether the wallet's view is synced to the main chain
  var syncedToChain: Bool = false

  ///* 
  ///Whether the current node is connected to testnet. This field is 
  ///deprecated and the network field should be used instead 
  var testnet: Bool = false

  //// The URIs of the current node.
  var uris: [String] = []

  //// Timestamp of the block best known to the wallet
  var bestHeaderTimestamp: Int64 = 0

  //// The version of the LND software that the node is running.
  var version: String = String()

  //// Number of inactive channels
  var numInactiveChannels: UInt32 = 0

  //// A list of active chains the node is connected to
  var chains: [Lnrpc_Chain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Chain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The blockchain the node is on (eg bitcoin, litecoin)
  var chain: String = String()

  //// The network the node is on (eg regtest, testnet, mainnet)
  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConfirmationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockSha: Data = SwiftProtobuf.Internal.emptyData

  var blockHeight: Int32 = 0

  var numConfsLeft: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelOpenUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPoint: Lnrpc_ChannelPoint {
    get { return _storage._channelPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._channelPoint = newValue }
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool { return _storage._channelPoint != nil }
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() { _uniqueStorage()._channelPoint = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelCloseUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closingTxid: Data = SwiftProtobuf.Internal.emptyData

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CloseChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: Lnrpc_ChannelPoint {
    get { return _storage._channelPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._channelPoint = newValue }
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool { return _storage._channelPoint != nil }
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() { _uniqueStorage()._channelPoint = nil }

  //// If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
  var force: Bool {
    get { return _storage._force }
    set { _uniqueStorage()._force = newValue }
  }

  //// The target number of blocks that the closure transaction should be confirmed by.
  var targetConf: Int32 {
    get { return _storage._targetConf }
    set { _uniqueStorage()._targetConf = newValue }
  }

  //// A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
  var satPerByte: Int64 {
    get { return _storage._satPerByte }
    set { _uniqueStorage()._satPerByte = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_CloseStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: OneOf_Update? {
    get { return _storage._update }
    set { _uniqueStorage()._update = newValue }
  }

  var closePending: Lnrpc_PendingUpdate {
    get {
      if case .closePending(let v)? = _storage._update { return v }
      return Lnrpc_PendingUpdate()
    }
    set { _uniqueStorage()._update = .closePending(newValue) }
  }

  var chanClose: Lnrpc_ChannelCloseUpdate {
    get {
      if case .chanClose(let v)? = _storage._update { return v }
      return Lnrpc_ChannelCloseUpdate()
    }
    set { _uniqueStorage()._update = .chanClose(newValue) }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case closePending(Lnrpc_PendingUpdate)
    case chanClose(Lnrpc_ChannelCloseUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_CloseStatusUpdate.OneOf_Update, rhs: Lnrpc_CloseStatusUpdate.OneOf_Update) -> Bool {
      switch (lhs, rhs) {
      case (.closePending(let l), .closePending(let r)): return l == r
      case (.chanClose(let l), .chanClose(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PendingUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = SwiftProtobuf.Internal.emptyData

  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_OpenChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The pubkey of the node to open a channel with
  var nodePubkey: Data = SwiftProtobuf.Internal.emptyData

  //// The hex encoded pubkey of the node to open a channel with
  var nodePubkeyString: String = String()

  //// The number of satoshis the wallet should commit to the channel
  var localFundingAmount: Int64 = 0

  //// The number of satoshis to push to the remote side as part of the initial commitment state
  var pushSat: Int64 = 0

  //// The target number of blocks that the funding transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
  var satPerByte: Int64 = 0

  //// Whether this channel should be private, not announced to the greater network.
  var `private`: Bool = false

  //// The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
  var minHtlcMsat: Int64 = 0

  //// The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
  var remoteCsvDelay: UInt32 = 0

  //// The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
  var minConfs: Int32 = 0

  //// Whether unconfirmed outputs should be used as inputs for the funding transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_OpenStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: OneOf_Update? {
    get { return _storage._update }
    set { _uniqueStorage()._update = newValue }
  }

  var chanPending: Lnrpc_PendingUpdate {
    get {
      if case .chanPending(let v)? = _storage._update { return v }
      return Lnrpc_PendingUpdate()
    }
    set { _uniqueStorage()._update = .chanPending(newValue) }
  }

  var chanOpen: Lnrpc_ChannelOpenUpdate {
    get {
      if case .chanOpen(let v)? = _storage._update { return v }
      return Lnrpc_ChannelOpenUpdate()
    }
    set { _uniqueStorage()._update = .chanOpen(newValue) }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case chanPending(Lnrpc_PendingUpdate)
    case chanOpen(Lnrpc_ChannelOpenUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_OpenStatusUpdate.OneOf_Update, rhs: Lnrpc_OpenStatusUpdate.OneOf_Update) -> Bool {
      switch (lhs, rhs) {
      case (.chanPending(let l), .chanPending(let r)): return l == r
      case (.chanOpen(let l), .chanOpen(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PendingHTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The direction within the channel that the htlc was sent
  var incoming: Bool = false

  //// The total value of the htlc
  var amount: Int64 = 0

  //// The final output to be swept back to the user's wallet
  var outpoint: String = String()

  //// The next block height at which we can spend the current stage
  var maturityHeight: UInt32 = 0

  ///*
  ///The number of blocks remaining until the current stage can be swept.
  ///Negative values indicate how many blocks have passed since becoming
  ///mature.
  var blocksTilMaturity: Int32 = 0

  //// Indicates whether the htlc is in its first or second stage of recovery
  var stage: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The balance in satoshis encumbered in pending channels
  var totalLimboBalance: Int64 = 0

  //// Channels pending opening
  var pendingOpenChannels: [Lnrpc_PendingChannelsResponse.PendingOpenChannel] = []

  //// Channels pending closing
  var pendingClosingChannels: [Lnrpc_PendingChannelsResponse.ClosedChannel] = []

  //// Channels pending force closing
  var pendingForceClosingChannels: [Lnrpc_PendingChannelsResponse.ForceClosedChannel] = []

  //// Channels waiting for closing tx to confirm
  var waitingCloseChannels: [Lnrpc_PendingChannelsResponse.WaitingCloseChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PendingChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var remoteNodePub: String = String()

    var channelPoint: String = String()

    var capacity: Int64 = 0

    var localBalance: Int64 = 0

    var remoteBalance: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PendingOpenChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get { return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel() }
      set { _uniqueStorage()._channel = newValue }
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool { return _storage._channel != nil }
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() { _uniqueStorage()._channel = nil }

    //// The height at which this channel will be confirmed
    var confirmationHeight: UInt32 {
      get { return _storage._confirmationHeight }
      set { _uniqueStorage()._confirmationHeight = newValue }
    }

    ///*
    ///The amount calculated to be paid in fees for the current set of
    ///commitment transactions. The fee amount is persisted with the channel
    ///in order to allow the fee amount to be removed and recalculated with
    ///each channel state update, including updates that happen after a system
    ///restart.
    var commitFee: Int64 {
      get { return _storage._commitFee }
      set { _uniqueStorage()._commitFee = newValue }
    }

    //// The weight of the commitment transaction
    var commitWeight: Int64 {
      get { return _storage._commitWeight }
      set { _uniqueStorage()._commitWeight = newValue }
    }

    ///*
    ///The required number of satoshis per kilo-weight that the requester will
    ///pay at all times, for both the funding transaction and commitment
    ///transaction. This value can later be updated once the channel is open.
    var feePerKw: Int64 {
      get { return _storage._feePerKw }
      set { _uniqueStorage()._feePerKw = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct WaitingCloseChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel waiting for closing tx to confirm
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get { return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel() }
      set { _uniqueStorage()._channel = newValue }
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool { return _storage._channel != nil }
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() { _uniqueStorage()._channel = nil }

    //// The balance in satoshis encumbered in this channel
    var limboBalance: Int64 {
      get { return _storage._limboBalance }
      set { _uniqueStorage()._limboBalance = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel to be closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get { return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel() }
      set { _uniqueStorage()._channel = newValue }
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool { return _storage._channel != nil }
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() { _uniqueStorage()._channel = nil }

    //// The transaction id of the closing transaction
    var closingTxid: String {
      get { return _storage._closingTxid }
      set { _uniqueStorage()._closingTxid = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ForceClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel to be force closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get { return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel() }
      set { _uniqueStorage()._channel = newValue }
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool { return _storage._channel != nil }
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() { _uniqueStorage()._channel = nil }

    //// The transaction id of the closing transaction
    var closingTxid: String {
      get { return _storage._closingTxid }
      set { _uniqueStorage()._closingTxid = newValue }
    }

    //// The balance in satoshis encumbered in this pending channel
    var limboBalance: Int64 {
      get { return _storage._limboBalance }
      set { _uniqueStorage()._limboBalance = newValue }
    }

    //// The height at which funds can be sweeped into the wallet
    var maturityHeight: UInt32 {
      get { return _storage._maturityHeight }
      set { _uniqueStorage()._maturityHeight = newValue }
    }

    ///
    ///Remaining # of blocks until the commitment output can be swept.
    ///Negative values indicate how many blocks have passed since becoming
    ///mature.
    var blocksTilMaturity: Int32 {
      get { return _storage._blocksTilMaturity }
      set { _uniqueStorage()._blocksTilMaturity = newValue }
    }

    //// The total value of funds successfully recovered from this channel
    var recoveredBalance: Int64 {
      get { return _storage._recoveredBalance }
      set { _uniqueStorage()._recoveredBalance = newValue }
    }

    var pendingHtlcs: [Lnrpc_PendingHTLC] {
      get { return _storage._pendingHtlcs }
      set { _uniqueStorage()._pendingHtlcs = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Lnrpc_ChannelEventSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelEventUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: OneOf_Channel? {
    get { return _storage._channel }
    set { _uniqueStorage()._channel = newValue }
  }

  var openChannel: Lnrpc_Channel {
    get {
      if case .openChannel(let v)? = _storage._channel { return v }
      return Lnrpc_Channel()
    }
    set { _uniqueStorage()._channel = .openChannel(newValue) }
  }

  var closedChannel: Lnrpc_ChannelCloseSummary {
    get {
      if case .closedChannel(let v)? = _storage._channel { return v }
      return Lnrpc_ChannelCloseSummary()
    }
    set { _uniqueStorage()._channel = .closedChannel(newValue) }
  }

  var activeChannel: Lnrpc_ChannelPoint {
    get {
      if case .activeChannel(let v)? = _storage._channel { return v }
      return Lnrpc_ChannelPoint()
    }
    set { _uniqueStorage()._channel = .activeChannel(newValue) }
  }

  var inactiveChannel: Lnrpc_ChannelPoint {
    get {
      if case .inactiveChannel(let v)? = _storage._channel { return v }
      return Lnrpc_ChannelPoint()
    }
    set { _uniqueStorage()._channel = .inactiveChannel(newValue) }
  }

  var type: Lnrpc_ChannelEventUpdate.UpdateType {
    get { return _storage._type }
    set { _uniqueStorage()._type = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Channel: Equatable {
    case openChannel(Lnrpc_Channel)
    case closedChannel(Lnrpc_ChannelCloseSummary)
    case activeChannel(Lnrpc_ChannelPoint)
    case inactiveChannel(Lnrpc_ChannelPoint)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_ChannelEventUpdate.OneOf_Channel, rhs: Lnrpc_ChannelEventUpdate.OneOf_Channel) -> Bool {
      switch (lhs, rhs) {
      case (.openChannel(let l), .openChannel(let r)): return l == r
      case (.closedChannel(let l), .closedChannel(let r)): return l == r
      case (.activeChannel(let l), .activeChannel(let r)): return l == r
      case (.inactiveChannel(let l), .inactiveChannel(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum UpdateType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case openChannel // = 0
    case closedChannel // = 1
    case activeChannel // = 2
    case inactiveChannel // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .openChannel
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .openChannel
      case 1: self = .closedChannel
      case 2: self = .activeChannel
      case 3: self = .inactiveChannel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .openChannel: return 0
      case .closedChannel: return 1
      case .activeChannel: return 2
      case .inactiveChannel: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Lnrpc_ChannelEventUpdate.UpdateType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_ChannelEventUpdate.UpdateType] = [
    .openChannel,
    .closedChannel,
    .activeChannel,
    .inactiveChannel
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_WalletBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WalletBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The balance of the wallet
  var totalBalance: Int64 = 0

  //// The confirmed balance of a wallet(with >= 1 confirmations)
  var confirmedBalance: Int64 = 0

  //// The unconfirmed balance of a wallet(with 0 confirmations)
  var unconfirmedBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Sum of channels balances denominated in satoshis
  var balance: Int64 = 0

  //// Sum of channels pending balances denominated in satoshis
  var pendingOpenBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_QueryRoutesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The 33-byte hex-encoded public key for the payment destination
  var pubKey: String {
    get { return _storage._pubKey }
    set { _uniqueStorage()._pubKey = newValue }
  }

  //// The amount to send expressed in satoshis
  var amt: Int64 {
    get { return _storage._amt }
    set { _uniqueStorage()._amt = newValue }
  }

  ///*
  ///Deprecated. The max number of routes to return. In the future, QueryRoutes
  ///will only return a single route.
  var numRoutes: Int32 {
    get { return _storage._numRoutes }
    set { _uniqueStorage()._numRoutes = newValue }
  }

  //// An optional CLTV delta from the current height that should be used for the timelock of the final hop
  var finalCltvDelta: Int32 {
    get { return _storage._finalCltvDelta }
    set { _uniqueStorage()._finalCltvDelta = newValue }
  }

  ///*
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///This value can be represented either as a percentage of the amount being
  ///sent, or as a fixed amount of the maximum fee the user is willing the pay to
  ///send the payment.
  var feeLimit: Lnrpc_FeeLimit {
    get { return _storage._feeLimit ?? Lnrpc_FeeLimit() }
    set { _uniqueStorage()._feeLimit = newValue }
  }
  /// Returns true if `feeLimit` has been explicitly set.
  var hasFeeLimit: Bool { return _storage._feeLimit != nil }
  /// Clears the value of `feeLimit`. Subsequent reads from it will return its default value.
  mutating func clearFeeLimit() { _uniqueStorage()._feeLimit = nil }

  ///*
  ///A list of nodes to ignore during path finding.
  var ignoredNodes: [Data] {
    get { return _storage._ignoredNodes }
    set { _uniqueStorage()._ignoredNodes = newValue }
  }

  ///*
  ///A list of edges to ignore during path finding.
  var ignoredEdges: [Lnrpc_EdgeLocator] {
    get { return _storage._ignoredEdges }
    set { _uniqueStorage()._ignoredEdges = newValue }
  }

  ///*
  ///The source node where the request route should originated from. If empty,
  ///self is assumed.
  var sourcePubKey: String {
    get { return _storage._sourcePubKey }
    set { _uniqueStorage()._sourcePubKey = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_EdgeLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The short channel id of this edge.
  var channelID: UInt64 = 0

  ///*
  ///The direction of this edge. If direction_reverse is false, the direction
  ///of this edge is from the channel endpoint with the lexicographically smaller
  ///pub key to the endpoint with the larger pub key. If direction_reverse is
  ///is true, the edge goes the other way.
  var directionReverse: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_QueryRoutesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routes: [Lnrpc_Route] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Hop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var chanCapacity: Int64 = 0

  var amtToForward: Int64 = 0

  var fee: Int64 = 0

  var expiry: UInt32 = 0

  var amtToForwardMsat: Int64 = 0

  var feeMsat: Int64 = 0

  ///*
  ///An optional public key of the hop. If the public key is given, the payment
  ///can be executed without relying on a copy of the channel graph.
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///A path through the channel graph which runs over one or more channels in
///succession. This struct carries all the information required to craft the
///Sphinx onion packet, and send the payment along the first hop in the path. A
///route is only selected as valid if all the channels have sufficient capacity to
///carry the initial payment amount after fees are accounted for.
struct Lnrpc_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The cumulative (final) time lock across the entire route.  This is the CLTV
  ///value that should be extended to the first hop in the route. All other hops
  ///will decrement the time-lock as advertised, leaving enough time for all
  ///hops to wait for or present the payment preimage to complete the payment.
  var totalTimeLock: UInt32 = 0

  ///*
  ///The sum of the fees paid at each hop within the final route.  In the case
  ///of a one-hop payment, this value will be zero as we don't need to pay a fee
  ///it ourself.
  var totalFees: Int64 = 0

  ///*
  ///The total amount of funds required to complete a payment over this route.
  ///This value includes the cumulative fees at each hop. As a result, the HTLC
  ///extended to the first-hop in the route will need to have at least this many
  ///satoshis, otherwise the route will fail at an intermediate node due to an
  ///insufficient amount of fees.
  var totalAmt: Int64 = 0

  ///*
  ///Contains details concerning the specific forwarding details at each hop.
  var hops: [Lnrpc_Hop] = []

  ///*
  ///The total fees in millisatoshis.
  var totalFeesMsat: Int64 = 0

  ///*
  ///The total amount in millisatoshis.
  var totalAmtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The 33-byte hex-encoded compressed public of the target node 
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///An individual vertex/node within the channel graph. A node is
  ///connected to other nodes by one or more channel edges emanating from it. As
  ///the graph is directed, a node will also have an incoming edge attached to
  ///it for each outgoing edge.
  var node: Lnrpc_LightningNode {
    get { return _storage._node ?? Lnrpc_LightningNode() }
    set { _uniqueStorage()._node = newValue }
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool { return _storage._node != nil }
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() { _uniqueStorage()._node = nil }

  var numChannels: UInt32 {
    get { return _storage._numChannels }
    set { _uniqueStorage()._numChannels = newValue }
  }

  var totalCapacity: Int64 {
    get { return _storage._totalCapacity }
    set { _uniqueStorage()._totalCapacity = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///An individual vertex/node within the channel graph. A node is
///connected to other nodes by one or more channel edges emanating from it. As the
///graph is directed, a node will also have an incoming edge attached to it for
///each outgoing edge.
struct Lnrpc_LightningNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdate: UInt32 = 0

  var pubKey: String = String()

  var alias: String = String()

  var addresses: [Lnrpc_NodeAddress] = []

  var color: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RoutingPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeLockDelta: UInt32 = 0

  var minHtlc: Int64 = 0

  var feeBaseMsat: Int64 = 0

  var feeRateMilliMsat: Int64 = 0

  var disabled: Bool = false

  var maxHtlcMsat: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///A fully authenticated channel along with all its unique attributes.
///Once an authenticated channel announcement has been processed on the network,
///then an instance of ChannelEdgeInfo encapsulating the channels attributes is
///stored. The other portions relevant to routing policy of a channel are stored
///within a ChannelEdgePolicy for each direction of the channel.
struct Lnrpc_ChannelEdge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var channelID: UInt64 {
    get { return _storage._channelID }
    set { _uniqueStorage()._channelID = newValue }
  }

  var chanPoint: String {
    get { return _storage._chanPoint }
    set { _uniqueStorage()._chanPoint = newValue }
  }

  var lastUpdate: UInt32 {
    get { return _storage._lastUpdate }
    set { _uniqueStorage()._lastUpdate = newValue }
  }

  var node1Pub: String {
    get { return _storage._node1Pub }
    set { _uniqueStorage()._node1Pub = newValue }
  }

  var node2Pub: String {
    get { return _storage._node2Pub }
    set { _uniqueStorage()._node2Pub = newValue }
  }

  var capacity: Int64 {
    get { return _storage._capacity }
    set { _uniqueStorage()._capacity = newValue }
  }

  var node1Policy: Lnrpc_RoutingPolicy {
    get { return _storage._node1Policy ?? Lnrpc_RoutingPolicy() }
    set { _uniqueStorage()._node1Policy = newValue }
  }
  /// Returns true if `node1Policy` has been explicitly set.
  var hasNode1Policy: Bool { return _storage._node1Policy != nil }
  /// Clears the value of `node1Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode1Policy() { _uniqueStorage()._node1Policy = nil }

  var node2Policy: Lnrpc_RoutingPolicy {
    get { return _storage._node2Policy ?? Lnrpc_RoutingPolicy() }
    set { _uniqueStorage()._node2Policy = newValue }
  }
  /// Returns true if `node2Policy` has been explicitly set.
  var hasNode2Policy: Bool { return _storage._node2Policy != nil }
  /// Clears the value of `node2Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode2Policy() { _uniqueStorage()._node2Policy = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///Whether unannounced channels are included in the response or not. If set,
  ///unannounced channels are included. Unannounced channels are both private
  ///channels, and public channels that are not yet announced to the network.
  var includeUnannounced: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// Returns a new instance of the directed channel graph.
struct Lnrpc_ChannelGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of `LightningNode`s in this channel graph
  var nodes: [Lnrpc_LightningNode] = []

  //// The list of `ChannelEdge`s in this channel graph
  var edges: [Lnrpc_ChannelEdge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var graphDiameter: UInt32 = 0

  var avgOutDegree: Double = 0

  var maxOutDegree: UInt32 = 0

  var numNodes: UInt32 = 0

  var numChannels: UInt32 = 0

  var totalNetworkCapacity: Int64 = 0

  var avgChannelSize: Double = 0

  var minChannelSize: Int64 = 0

  var maxChannelSize: Int64 = 0

  var medianChannelSizeSat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologySubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologyUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeUpdates: [Lnrpc_NodeUpdate] = []

  var channelUpdates: [Lnrpc_ChannelEdgeUpdate] = []

  var closedChans: [Lnrpc_ClosedChannelUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var identityKey: String = String()

  var globalFeatures: Data = SwiftProtobuf.Internal.emptyData

  var alias: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelEdgeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get { return _storage._chanID }
    set { _uniqueStorage()._chanID = newValue }
  }

  var chanPoint: Lnrpc_ChannelPoint {
    get { return _storage._chanPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._chanPoint = newValue }
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool { return _storage._chanPoint != nil }
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() { _uniqueStorage()._chanPoint = nil }

  var capacity: Int64 {
    get { return _storage._capacity }
    set { _uniqueStorage()._capacity = newValue }
  }

  var routingPolicy: Lnrpc_RoutingPolicy {
    get { return _storage._routingPolicy ?? Lnrpc_RoutingPolicy() }
    set { _uniqueStorage()._routingPolicy = newValue }
  }
  /// Returns true if `routingPolicy` has been explicitly set.
  var hasRoutingPolicy: Bool { return _storage._routingPolicy != nil }
  /// Clears the value of `routingPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRoutingPolicy() { _uniqueStorage()._routingPolicy = nil }

  var advertisingNode: String {
    get { return _storage._advertisingNode }
    set { _uniqueStorage()._advertisingNode = newValue }
  }

  var connectingNode: String {
    get { return _storage._connectingNode }
    set { _uniqueStorage()._connectingNode = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ClosedChannelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get { return _storage._chanID }
    set { _uniqueStorage()._chanID = newValue }
  }

  var capacity: Int64 {
    get { return _storage._capacity }
    set { _uniqueStorage()._capacity = newValue }
  }

  var closedHeight: UInt32 {
    get { return _storage._closedHeight }
    set { _uniqueStorage()._closedHeight = newValue }
  }

  var chanPoint: Lnrpc_ChannelPoint {
    get { return _storage._chanPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._chanPoint = newValue }
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool { return _storage._chanPoint != nil }
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() { _uniqueStorage()._chanPoint = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_HopHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The public key of the node at the start of the channel.
  var nodeID: String = String()

  //// The unique identifier of the channel.
  var chanID: UInt64 = 0

  //// The base fee of the channel denominated in millisatoshis.
  var feeBaseMsat: UInt32 = 0

  ///*
  ///The fee rate of the channel for sending one satoshi across it denominated in
  ///millionths of a satoshi.
  var feeProportionalMillionths: UInt32 = 0

  //// The time-lock delta of the channel.
  var cltvExpiryDelta: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RouteHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A list of hop hints that when chained together can assist in reaching a
  ///specific destination.
  var hopHints: [Lnrpc_HopHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Invoice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///An optional memo to attach along with the invoice. Used for record keeping
  ///purposes for the invoice's creator, and will also be set in the description
  ///field of the encoded payment request if the description_hash field is not
  ///being used.
  var memo: String {
    get { return _storage._memo }
    set { _uniqueStorage()._memo = newValue }
  }

  ///* Deprecated. An optional cryptographic receipt of payment which is not
  ///implemented.
  var receipt: Data {
    get { return _storage._receipt }
    set { _uniqueStorage()._receipt = newValue }
  }

  ///*
  ///The hex-encoded preimage (32 byte) which will allow settling an incoming
  ///HTLC payable to this preimage
  var rPreimage: Data {
    get { return _storage._rPreimage }
    set { _uniqueStorage()._rPreimage = newValue }
  }

  //// The hash of the preimage
  var rHash: Data {
    get { return _storage._rHash }
    set { _uniqueStorage()._rHash = newValue }
  }

  //// The value of this invoice in satoshis
  var value: Int64 {
    get { return _storage._value }
    set { _uniqueStorage()._value = newValue }
  }

  //// Whether this invoice has been fulfilled
  var settled: Bool {
    get { return _storage._settled }
    set { _uniqueStorage()._settled = newValue }
  }

  //// When this invoice was created
  var creationDate: Int64 {
    get { return _storage._creationDate }
    set { _uniqueStorage()._creationDate = newValue }
  }

  //// When this invoice was settled
  var settleDate: Int64 {
    get { return _storage._settleDate }
    set { _uniqueStorage()._settleDate = newValue }
  }

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String {
    get { return _storage._paymentRequest }
    set { _uniqueStorage()._paymentRequest = newValue }
  }

  ///*
  ///Hash (SHA-256) of a description of the payment. Used if the description of
  ///payment (memo) is too long to naturally fit within the description field
  ///of an encoded payment request.
  var descriptionHash: Data {
    get { return _storage._descriptionHash }
    set { _uniqueStorage()._descriptionHash = newValue }
  }

  //// Payment request expiry time in seconds. Default is 3600 (1 hour).
  var expiry: Int64 {
    get { return _storage._expiry }
    set { _uniqueStorage()._expiry = newValue }
  }

  //// Fallback on-chain address.
  var fallbackAddr: String {
    get { return _storage._fallbackAddr }
    set { _uniqueStorage()._fallbackAddr = newValue }
  }

  //// Delta to use for the time-lock of the CLTV extended to the final hop.
  var cltvExpiry: UInt64 {
    get { return _storage._cltvExpiry }
    set { _uniqueStorage()._cltvExpiry = newValue }
  }

  ///*
  ///Route hints that can each be individually used to assist in reaching the
  ///invoice's destination.
  var routeHints: [Lnrpc_RouteHint] {
    get { return _storage._routeHints }
    set { _uniqueStorage()._routeHints = newValue }
  }

  //// Whether this invoice should include routing hints for private channels.
  var `private`: Bool {
    get { return _storage._private }
    set { _uniqueStorage()._private = newValue }
  }

  ///*
  ///The "add" index of this invoice. Each newly created invoice will increment
  ///this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all added
  ///invoices with an add_index greater than this one.
  var addIndex: UInt64 {
    get { return _storage._addIndex }
    set { _uniqueStorage()._addIndex = newValue }
  }

  ///*
  ///The "settle" index of this invoice. Each newly settled invoice will
  ///increment this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all
  ///settled invoices with an settle_index greater than this one.
  var settleIndex: UInt64 {
    get { return _storage._settleIndex }
    set { _uniqueStorage()._settleIndex = newValue }
  }

  //// Deprecated, use amt_paid_sat or amt_paid_msat.
  var amtPaid: Int64 {
    get { return _storage._amtPaid }
    set { _uniqueStorage()._amtPaid = newValue }
  }

  ///*
  ///The amount that was accepted for this invoice, in satoshis. This will ONLY
  ///be set if this invoice has been settled. We provide this field as if the
  ///invoice was created with a zero value, then we need to record what amount
  ///was ultimately accepted. Additionally, it's possible that the sender paid
  ///MORE that was specified in the original invoice. So we'll record that here
  ///as well.
  var amtPaidSat: Int64 {
    get { return _storage._amtPaidSat }
    set { _uniqueStorage()._amtPaidSat = newValue }
  }

  ///*
  ///The amount that was accepted for this invoice, in millisatoshis. This will
  ///ONLY be set if this invoice has been settled. We provide this field as if
  ///the invoice was created with a zero value, then we need to record what
  ///amount was ultimately accepted. Additionally, it's possible that the sender
  ///paid MORE that was specified in the original invoice. So we'll record that
  ///here as well.
  var amtPaidMsat: Int64 {
    get { return _storage._amtPaidMsat }
    set { _uniqueStorage()._amtPaidMsat = newValue }
  }

  ///*
  ///The state the invoice is in.
  var state: Lnrpc_Invoice.InvoiceState {
    get { return _storage._state }
    set { _uniqueStorage()._state = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InvoiceState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `open` // = 0
    case settled // = 1
    case canceled // = 2
    case accepted // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .open
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .open
      case 1: self = .settled
      case 2: self = .canceled
      case 3: self = .accepted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .open: return 0
      case .settled: return 1
      case .canceled: return 2
      case .accepted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Lnrpc_Invoice.InvoiceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Lnrpc_Invoice.InvoiceState] = [
    .open,
    .settled,
    .canceled,
    .accepted
  ]
}

#endif  // swift(>=4.2)

struct Lnrpc_AddInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rHash: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  ///*
  ///The "add" index of this invoice. Each newly created invoice will increment
  ///this index making it monotonically increasing. Callers to the
  ///SubscribeInvoices call can use this to instantly get notified of all added
  ///invoices with an add_index greater than this one.
  var addIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PaymentHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The hex-encoded payment hash of the invoice to be looked up. The passed
  ///payment hash must be exactly 32 bytes, otherwise an error is returned.
  var rHashStr: String = String()

  //// The payment hash of the invoice to be looked up.
  var rHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// If set, only unsettled invoices will be returned in the response.
  var pendingOnly: Bool = false

  ///*
  ///The index of an invoice that will be used as either the start or end of a
  ///query to determine which invoices should be returned in the response.
  var indexOffset: UInt64 = 0

  //// The max number of invoices to return in the response to this query.
  var numMaxInvoices: UInt64 = 0

  ///*
  ///If set, the invoices returned will result from seeking backwards from the
  ///specified index offset. This can be used to paginate backwards.
  var reversed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A list of invoices from the time slice of the time series specified in the
  ///request.
  var invoices: [Lnrpc_Invoice] = []

  ///*
  ///The index of the last item in the set of returned invoices. This can be used
  ///to seek further, pagination style.
  var lastIndexOffset: UInt64 = 0

  ///*
  ///The index of the last item in the set of returned invoices. This can be used
  ///to seek backwards, pagination style.
  var firstIndexOffset: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InvoiceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///If specified (non-zero), then we'll first start by sending out
  ///notifications for all added indexes with an add_index greater than this
  ///value. This allows callers to catch up on any events they missed while they
  ///weren't connected to the streaming RPC.
  var addIndex: UInt64 = 0

  ///*
  ///If specified (non-zero), then we'll first start by sending out
  ///notifications for all settled indexes with an settle_index greater than
  ///this value. This allows callers to catch up on any events they missed while
  ///they weren't connected to the streaming RPC.
  var settleIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment hash
  var paymentHash: String = String()

  //// Deprecated, use value_sat or value_msat.
  var value: Int64 = 0

  //// The date of this payment
  var creationDate: Int64 = 0

  //// The path this payment took
  var path: [String] = []

  //// The fee paid for this payment in satoshis
  var fee: Int64 = 0

  //// The payment preimage
  var paymentPreimage: String = String()

  //// The value of the payment in satoshis
  var valueSat: Int64 = 0

  //// The value of the payment in milli-satoshis
  var valueMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of payments
  var payments: [Lnrpc_Payment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AbandonChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPoint: Lnrpc_ChannelPoint {
    get { return _storage._channelPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._channelPoint = newValue }
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool { return _storage._channelPoint != nil }
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() { _uniqueStorage()._channelPoint = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_AbandonChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var show: Bool = false

  var levelSpec: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subSystems: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReqString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment request string to be decoded
  var payReq: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String = String()

  var paymentHash: String = String()

  var numSatoshis: Int64 = 0

  var timestamp: Int64 = 0

  var expiry: Int64 = 0

  var description_p: String = String()

  var descriptionHash: String = String()

  var fallbackAddr: String = String()

  var cltvExpiry: Int64 = 0

  var routeHints: [Lnrpc_RouteHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelFeeReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The channel that this fee report belongs to.
  var chanPoint: String = String()

  //// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 = 0

  //// The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
  var feePerMil: Int64 = 0

  //// The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
  var feeRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// An array of channel fee reports which describes the current fee schedule for each channel.
  var channelFees: [Lnrpc_ChannelFeeReport] = []

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
  var dayFeeSum: UInt64 = 0

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
  var weekFeeSum: UInt64 = 0

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
  var monthFeeSum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PolicyUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: OneOf_Scope? {
    get { return _storage._scope }
    set { _uniqueStorage()._scope = newValue }
  }

  //// If set, then this update applies to all currently active channels.
  var global: Bool {
    get {
      if case .global(let v)? = _storage._scope { return v }
      return false
    }
    set { _uniqueStorage()._scope = .global(newValue) }
  }

  //// If set, this update will target a specific channel.
  var chanPoint: Lnrpc_ChannelPoint {
    get {
      if case .chanPoint(let v)? = _storage._scope { return v }
      return Lnrpc_ChannelPoint()
    }
    set { _uniqueStorage()._scope = .chanPoint(newValue) }
  }

  //// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 {
    get { return _storage._baseFeeMsat }
    set { _uniqueStorage()._baseFeeMsat = newValue }
  }

  //// The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
  var feeRate: Double {
    get { return _storage._feeRate }
    set { _uniqueStorage()._feeRate = newValue }
  }

  //// The required timelock delta for HTLCs forwarded over the channel.
  var timeLockDelta: UInt32 {
    get { return _storage._timeLockDelta }
    set { _uniqueStorage()._timeLockDelta = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Scope: Equatable {
    //// If set, then this update applies to all currently active channels.
    case global(Bool)
    //// If set, this update will target a specific channel.
    case chanPoint(Lnrpc_ChannelPoint)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope, rhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope) -> Bool {
      switch (lhs, rhs) {
      case (.global(let l), .global(let r)): return l == r
      case (.chanPoint(let l), .chanPoint(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PolicyUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
  var startTime: UInt64 = 0

  //// End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
  var endTime: UInt64 = 0

  //// Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
  var indexOffset: UInt32 = 0

  //// The max number of events to return in the response to this query.
  var numMaxEvents: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Timestamp is the time (unix epoch offset) that this circuit was completed.
  var timestamp: UInt64 = 0

  //// The incoming channel ID that carried the HTLC that created the circuit.
  var chanIDIn: UInt64 = 0

  //// The outgoing channel ID that carried the preimage that completed the circuit.
  var chanIDOut: UInt64 = 0

  //// The total amount (in satoshis) of the incoming HTLC that created half the circuit.
  var amtIn: UInt64 = 0

  //// The total amount (in satoshis) of the outgoing HTLC that created the second half of the circuit.
  var amtOut: UInt64 = 0

  //// The total fee (in satoshis) that this payment circuit carried.
  var fee: UInt64 = 0

  //// The total fee (in milli-satoshis) that this payment circuit carried.
  var feeMsat: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of forwarding events from the time slice of the time series specified in the request.
  var forwardingEvents: [Lnrpc_ForwardingEvent] = []

  //// The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
  var lastOffsetIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ExportChannelBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The target chanenl point to obtain a back up for.
  var chanPoint: Lnrpc_ChannelPoint {
    get { return _storage._chanPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._chanPoint = newValue }
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool { return _storage._chanPoint != nil }
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() { _uniqueStorage()._chanPoint = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelBackup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///Identifies the channel that this backup belongs to.
  var chanPoint: Lnrpc_ChannelPoint {
    get { return _storage._chanPoint ?? Lnrpc_ChannelPoint() }
    set { _uniqueStorage()._chanPoint = newValue }
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool { return _storage._chanPoint != nil }
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() { _uniqueStorage()._chanPoint = nil }

  ///*
  ///Is an encrypted single-chan backup. this can be passed to
  ///RestoreChannelBackups, or the WalletUnlocker Innit and Unlock methods in
  ///order to trigger the recovery protocol.
  var chanBackup: Data {
    get { return _storage._chanBackup }
    set { _uniqueStorage()._chanBackup = newValue }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_MultiChanBackup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///Is the set of all channels that are included in this multi-channel backup.
  var chanPoints: [Lnrpc_ChannelPoint] = []

  ///*
  ///A single encrypted blob containing all the static channel backups of the
  ///channel listed above. This can be stored as a single file or blob, and
  ///safely be replaced with any prior/future versions.
  var multiChanBackup: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanBackupExportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanBackupSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The set of new channels that have been added since the last channel backup
  ///snapshot was requested.
  var singleChanBackups: Lnrpc_ChannelBackups {
    get { return _storage._singleChanBackups ?? Lnrpc_ChannelBackups() }
    set { _uniqueStorage()._singleChanBackups = newValue }
  }
  /// Returns true if `singleChanBackups` has been explicitly set.
  var hasSingleChanBackups: Bool { return _storage._singleChanBackups != nil }
  /// Clears the value of `singleChanBackups`. Subsequent reads from it will return its default value.
  mutating func clearSingleChanBackups() { _uniqueStorage()._singleChanBackups = nil }

  ///*
  ///A multi-channel backup that covers all open channels currently known to
  ///lnd.
  var multiChanBackup: Lnrpc_MultiChanBackup {
    get { return _storage._multiChanBackup ?? Lnrpc_MultiChanBackup() }
    set { _uniqueStorage()._multiChanBackup = newValue }
  }
  /// Returns true if `multiChanBackup` has been explicitly set.
  var hasMultiChanBackup: Bool { return _storage._multiChanBackup != nil }
  /// Clears the value of `multiChanBackup`. Subsequent reads from it will return its default value.
  mutating func clearMultiChanBackup() { _uniqueStorage()._multiChanBackup = nil }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelBackups {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A set of single-chan static channel backups.
  var chanBackups: [Lnrpc_ChannelBackup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RestoreChanBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var backup: OneOf_Backup? {
    get { return _storage._backup }
    set { _uniqueStorage()._backup = newValue }
  }

  var chanBackups: Lnrpc_ChannelBackups {
    get {
      if case .chanBackups(let v)? = _storage._backup { return v }
      return Lnrpc_ChannelBackups()
    }
    set { _uniqueStorage()._backup = .chanBackups(newValue) }
  }

  var multiChanBackup: Data {
    get {
      if case .multiChanBackup(let v)? = _storage._backup { return v }
      return SwiftProtobuf.Internal.emptyData
    }
    set { _uniqueStorage()._backup = .multiChanBackup(newValue) }
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Backup: Equatable {
    case chanBackups(Lnrpc_ChannelBackups)
    case multiChanBackup(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Lnrpc_RestoreChanBackupRequest.OneOf_Backup, rhs: Lnrpc_RestoreChanBackupRequest.OneOf_Backup) -> Bool {
      switch (lhs, rhs) {
      case (.chanBackups(let l), .chanBackups(let r)): return l == r
      case (.multiChanBackup(let l), .multiChanBackup(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_RestoreBackupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBackupSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyChanBackupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "lnrpc"

extension Lnrpc_AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WITNESS_PUBKEY_HASH"),
    1: .same(proto: "NESTED_PUBKEY_HASH"),
    2: .same(proto: "UNUSED_WITNESS_PUBKEY_HASH"),
    3: .same(proto: "UNUSED_NESTED_PUBKEY_HASH")
  ]
}

extension Lnrpc_GenSeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aezeed_passphrase"),
    2: .standard(proto: "seed_entropy")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.aezeedPassphrase)
      case 2: try decoder.decodeSingularBytesField(value: &self.seedEntropy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aezeedPassphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.aezeedPassphrase, fieldNumber: 1)
    }
    if !self.seedEntropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.seedEntropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GenSeedRequest, rhs: Lnrpc_GenSeedRequest) -> Bool {
    if lhs.aezeedPassphrase != rhs.aezeedPassphrase { return false }
    if lhs.seedEntropy != rhs.seedEntropy { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GenSeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cipher_seed_mnemonic"),
    2: .standard(proto: "enciphered_seed")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.cipherSeedMnemonic)
      case 2: try decoder.decodeSingularBytesField(value: &self.encipheredSeed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cipherSeedMnemonic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSeedMnemonic, fieldNumber: 1)
    }
    if !self.encipheredSeed.isEmpty {
      try visitor.visitSingularBytesField(value: self.encipheredSeed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GenSeedResponse, rhs: Lnrpc_GenSeedResponse) -> Bool {
    if lhs.cipherSeedMnemonic != rhs.cipherSeedMnemonic { return false }
    if lhs.encipheredSeed != rhs.encipheredSeed { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_InitWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "cipher_seed_mnemonic"),
    3: .standard(proto: "aezeed_passphrase"),
    4: .standard(proto: "recovery_window"),
    5: .standard(proto: "channel_backups")
  ]

  fileprivate class _StorageClass {
    var _walletPassword: Data = SwiftProtobuf.Internal.emptyData
    var _cipherSeedMnemonic: [String] = []
    var _aezeedPassphrase: Data = SwiftProtobuf.Internal.emptyData
    var _recoveryWindow: Int32 = 0
    var _channelBackups: Lnrpc_ChanBackupSnapshot?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _walletPassword = source._walletPassword
      _cipherSeedMnemonic = source._cipherSeedMnemonic
      _aezeedPassphrase = source._aezeedPassphrase
      _recoveryWindow = source._recoveryWindow
      _channelBackups = source._channelBackups
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._walletPassword)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._cipherSeedMnemonic)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._aezeedPassphrase)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._recoveryWindow)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._channelBackups)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._walletPassword.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._walletPassword, fieldNumber: 1)
      }
      if !_storage._cipherSeedMnemonic.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cipherSeedMnemonic, fieldNumber: 2)
      }
      if !_storage._aezeedPassphrase.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._aezeedPassphrase, fieldNumber: 3)
      }
      if _storage._recoveryWindow != 0 {
        try visitor.visitSingularInt32Field(value: _storage._recoveryWindow, fieldNumber: 4)
      }
      if let v = _storage._channelBackups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InitWalletRequest, rhs: Lnrpc_InitWalletRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._walletPassword != rhs_storage._walletPassword { return false }
        if _storage._cipherSeedMnemonic != rhs_storage._cipherSeedMnemonic { return false }
        if _storage._aezeedPassphrase != rhs_storage._aezeedPassphrase { return false }
        if _storage._recoveryWindow != rhs_storage._recoveryWindow { return false }
        if _storage._channelBackups != rhs_storage._channelBackups { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_InitWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InitWalletResponse, rhs: Lnrpc_InitWalletResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_UnlockWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "recovery_window"),
    3: .standard(proto: "channel_backups")
  ]

  fileprivate class _StorageClass {
    var _walletPassword: Data = SwiftProtobuf.Internal.emptyData
    var _recoveryWindow: Int32 = 0
    var _channelBackups: Lnrpc_ChanBackupSnapshot?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _walletPassword = source._walletPassword
      _recoveryWindow = source._recoveryWindow
      _channelBackups = source._channelBackups
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._walletPassword)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._recoveryWindow)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._channelBackups)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._walletPassword.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._walletPassword, fieldNumber: 1)
      }
      if _storage._recoveryWindow != 0 {
        try visitor.visitSingularInt32Field(value: _storage._recoveryWindow, fieldNumber: 2)
      }
      if let v = _storage._channelBackups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_UnlockWalletRequest, rhs: Lnrpc_UnlockWalletRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._walletPassword != rhs_storage._walletPassword { return false }
        if _storage._recoveryWindow != rhs_storage._recoveryWindow { return false }
        if _storage._channelBackups != rhs_storage._channelBackups { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_UnlockWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_UnlockWalletResponse, rhs: Lnrpc_UnlockWalletResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_password"),
    2: .standard(proto: "new_password")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.currentPassword)
      case 2: try decoder.decodeSingularBytesField(value: &self.newPassword)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.currentPassword, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.newPassword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChangePasswordRequest, rhs: Lnrpc_ChangePasswordRequest) -> Bool {
    if lhs.currentPassword != rhs.currentPassword { return false }
    if lhs.newPassword != rhs.newPassword { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChangePasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePasswordResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChangePasswordResponse, rhs: Lnrpc_ChangePasswordResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Utxo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Utxo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "type", json: "address_type"),
    2: .same(proto: "address"),
    3: .same(proto: "amount_sat"),
    4: .same(proto: "pk_script"),
    5: .same(proto: "outpoint"),
    6: .same(proto: "confirmations")
  ]

  fileprivate class _StorageClass {
    var _type: Lnrpc_AddressType = .witnessPubkeyHash
    var _address: String = String()
    var _amountSat: Int64 = 0
    var _pkScript: String = String()
    var _outpoint: Lnrpc_OutPoint?
    var _confirmations: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _address = source._address
      _amountSat = source._amountSat
      _pkScript = source._pkScript
      _outpoint = source._outpoint
      _confirmations = source._confirmations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._amountSat)
        case 4: try decoder.decodeSingularStringField(value: &_storage._pkScript)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._outpoint)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._confirmations)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .witnessPubkeyHash {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if _storage._amountSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amountSat, fieldNumber: 3)
      }
      if !_storage._pkScript.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pkScript, fieldNumber: 4)
      }
      if let v = _storage._outpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._confirmations != 0 {
        try visitor.visitSingularInt64Field(value: _storage._confirmations, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Utxo, rhs: Lnrpc_Utxo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type { return false }
        if _storage._address != rhs_storage._address { return false }
        if _storage._amountSat != rhs_storage._amountSat { return false }
        if _storage._pkScript != rhs_storage._pkScript { return false }
        if _storage._outpoint != rhs_storage._outpoint { return false }
        if _storage._confirmations != rhs_storage._confirmations { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx_hash"),
    2: .same(proto: "amount"),
    3: .same(proto: "num_confirmations"),
    4: .same(proto: "block_hash"),
    5: .same(proto: "block_height"),
    6: .same(proto: "time_stamp"),
    7: .same(proto: "total_fees"),
    8: .same(proto: "dest_addresses")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txHash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.numConfirmations)
      case 4: try decoder.decodeSingularStringField(value: &self.blockHash)
      case 5: try decoder.decodeSingularInt32Field(value: &self.blockHeight)
      case 6: try decoder.decodeSingularInt64Field(value: &self.timeStamp)
      case 7: try decoder.decodeSingularInt64Field(value: &self.totalFees)
      case 8: try decoder.decodeRepeatedStringField(value: &self.destAddresses)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.numConfirmations != 0 {
      try visitor.visitSingularInt32Field(value: self.numConfirmations, fieldNumber: 3)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 4)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 5)
    }
    if self.timeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timeStamp, fieldNumber: 6)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 7)
    }
    if !self.destAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destAddresses, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Transaction, rhs: Lnrpc_Transaction) -> Bool {
    if lhs.txHash != rhs.txHash { return false }
    if lhs.amount != rhs.amount { return false }
    if lhs.numConfirmations != rhs.numConfirmations { return false }
    if lhs.blockHash != rhs.blockHash { return false }
    if lhs.blockHeight != rhs.blockHeight { return false }
    if lhs.timeStamp != rhs.timeStamp { return false }
    if lhs.totalFees != rhs.totalFees { return false }
    if lhs.destAddresses != rhs.destAddresses { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GetTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetTransactionsRequest, rhs: Lnrpc_GetTransactionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_TransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_TransactionDetails, rhs: Lnrpc_TransactionDetails) -> Bool {
    if lhs.transactions != rhs.transactions { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_FeeLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixed"),
    2: .same(proto: "percent")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.limit != nil { try decoder.handleConflictingOneOf() }
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v { self.limit = .fixed(v) }
      case 2:
        if self.limit != nil { try decoder.handleConflictingOneOf() }
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v { self.limit = .percent(v) }
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.limit {
    case .fixed(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    case .percent(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeLimit, rhs: Lnrpc_FeeLimit) -> Bool {
    if lhs.limit != rhs.limit { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "dest_string"),
    3: .same(proto: "amt"),
    4: .standard(proto: "payment_hash"),
    5: .standard(proto: "payment_hash_string"),
    6: .standard(proto: "payment_request"),
    7: .standard(proto: "final_cltv_delta"),
    8: .standard(proto: "fee_limit"),
    9: .standard(proto: "outgoing_chan_id"),
    10: .standard(proto: "cltv_limit")
  ]

  fileprivate class _StorageClass {
    var _dest: Data = SwiftProtobuf.Internal.emptyData
    var _destString: String = String()
    var _amt: Int64 = 0
    var _paymentHash: Data = SwiftProtobuf.Internal.emptyData
    var _paymentHashString: String = String()
    var _paymentRequest: String = String()
    var _finalCltvDelta: Int32 = 0
    var _feeLimit: Lnrpc_FeeLimit?
    var _outgoingChanID: UInt64 = 0
    var _cltvLimit: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dest = source._dest
      _destString = source._destString
      _amt = source._amt
      _paymentHash = source._paymentHash
      _paymentHashString = source._paymentHashString
      _paymentRequest = source._paymentRequest
      _finalCltvDelta = source._finalCltvDelta
      _feeLimit = source._feeLimit
      _outgoingChanID = source._outgoingChanID
      _cltvLimit = source._cltvLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._dest)
        case 2: try decoder.decodeSingularStringField(value: &_storage._destString)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._amt)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._paymentHash)
        case 5: try decoder.decodeSingularStringField(value: &_storage._paymentHashString)
        case 6: try decoder.decodeSingularStringField(value: &_storage._paymentRequest)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._finalCltvDelta)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._feeLimit)
        case 9: try decoder.decodeSingularUInt64Field(value: &_storage._outgoingChanID)
        case 10: try decoder.decodeSingularUInt32Field(value: &_storage._cltvLimit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._dest.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dest, fieldNumber: 1)
      }
      if !_storage._destString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destString, fieldNumber: 2)
      }
      if _storage._amt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amt, fieldNumber: 3)
      }
      if !_storage._paymentHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentHash, fieldNumber: 4)
      }
      if !_storage._paymentHashString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentHashString, fieldNumber: 5)
      }
      if !_storage._paymentRequest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentRequest, fieldNumber: 6)
      }
      if _storage._finalCltvDelta != 0 {
        try visitor.visitSingularInt32Field(value: _storage._finalCltvDelta, fieldNumber: 7)
      }
      if let v = _storage._feeLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._outgoingChanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outgoingChanID, fieldNumber: 9)
      }
      if _storage._cltvLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cltvLimit, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendRequest, rhs: Lnrpc_SendRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dest != rhs_storage._dest { return false }
        if _storage._destString != rhs_storage._destString { return false }
        if _storage._amt != rhs_storage._amt { return false }
        if _storage._paymentHash != rhs_storage._paymentHash { return false }
        if _storage._paymentHashString != rhs_storage._paymentHashString { return false }
        if _storage._paymentRequest != rhs_storage._paymentRequest { return false }
        if _storage._finalCltvDelta != rhs_storage._finalCltvDelta { return false }
        if _storage._feeLimit != rhs_storage._feeLimit { return false }
        if _storage._outgoingChanID != rhs_storage._outgoingChanID { return false }
        if _storage._cltvLimit != rhs_storage._cltvLimit { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment_error"),
    2: .same(proto: "payment_preimage"),
    3: .same(proto: "payment_route"),
    4: .same(proto: "payment_hash")
  ]

  fileprivate class _StorageClass {
    var _paymentError: String = String()
    var _paymentPreimage: Data = SwiftProtobuf.Internal.emptyData
    var _paymentRoute: Lnrpc_Route?
    var _paymentHash: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paymentError = source._paymentError
      _paymentPreimage = source._paymentPreimage
      _paymentRoute = source._paymentRoute
      _paymentHash = source._paymentHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._paymentError)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._paymentPreimage)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._paymentRoute)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._paymentHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._paymentError.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentError, fieldNumber: 1)
      }
      if !_storage._paymentPreimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentPreimage, fieldNumber: 2)
      }
      if let v = _storage._paymentRoute {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._paymentHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentHash, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendResponse, rhs: Lnrpc_SendResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paymentError != rhs_storage._paymentError { return false }
        if _storage._paymentPreimage != rhs_storage._paymentPreimage { return false }
        if _storage._paymentRoute != rhs_storage._paymentRoute { return false }
        if _storage._paymentHash != rhs_storage._paymentHash { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendToRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .standard(proto: "payment_hash_string"),
    3: .same(proto: "routes"),
    4: .same(proto: "route")
  ]

  fileprivate class _StorageClass {
    var _paymentHash: Data = SwiftProtobuf.Internal.emptyData
    var _paymentHashString: String = String()
    var _routes: [Lnrpc_Route] = []
    var _route: Lnrpc_Route?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paymentHash = source._paymentHash
      _paymentHashString = source._paymentHashString
      _routes = source._routes
      _route = source._route
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._paymentHash)
        case 2: try decoder.decodeSingularStringField(value: &_storage._paymentHashString)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._routes)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._route)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._paymentHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentHash, fieldNumber: 1)
      }
      if !_storage._paymentHashString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentHashString, fieldNumber: 2)
      }
      if !_storage._routes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routes, fieldNumber: 3)
      }
      if let v = _storage._route {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendToRouteRequest, rhs: Lnrpc_SendToRouteRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paymentHash != rhs_storage._paymentHash { return false }
        if _storage._paymentHashString != rhs_storage._paymentHashString { return false }
        if _storage._routes != rhs_storage._routes { return false }
        if _storage._route != rhs_storage._route { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "funding_txid_bytes"),
    2: .same(proto: "funding_txid_str"),
    3: .same(proto: "output_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.fundingTxid != nil { try decoder.handleConflictingOneOf() }
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v { self.fundingTxid = .fundingTxidBytes(v) }
      case 2:
        if self.fundingTxid != nil { try decoder.handleConflictingOneOf() }
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v { self.fundingTxid = .fundingTxidStr(v) }
      case 3: try decoder.decodeSingularUInt32Field(value: &self.outputIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.fundingTxid {
    case .fundingTxidBytes(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    case .fundingTxidStr(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelPoint, rhs: Lnrpc_ChannelPoint) -> Bool {
    if lhs.fundingTxid != rhs.fundingTxid { return false }
    if lhs.outputIndex != rhs.outputIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_OutPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid_bytes"),
    2: .same(proto: "txid_str"),
    3: .same(proto: "output_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txidBytes)
      case 2: try decoder.decodeSingularStringField(value: &self.txidStr)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.outputIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txidBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.txidBytes, fieldNumber: 1)
    }
    if !self.txidStr.isEmpty {
      try visitor.visitSingularStringField(value: self.txidStr, fieldNumber: 2)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OutPoint, rhs: Lnrpc_OutPoint) -> Bool {
    if lhs.txidBytes != rhs.txidBytes { return false }
    if lhs.txidStr != rhs.txidStr { return false }
    if lhs.outputIndex != rhs.outputIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_LightningAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "host")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.host)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_LightningAddress, rhs: Lnrpc_LightningAddress) -> Bool {
    if lhs.pubkey != rhs.pubkey { return false }
    if lhs.host != rhs.host { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AddrToAmount"),
    2: .standard(proto: "target_conf")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self, value: &self.addrToAmount)
      case 2: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrToAmount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self, value: self.addrToAmount, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EstimateFeeRequest, rhs: Lnrpc_EstimateFeeRequest) -> Bool {
    if lhs.addrToAmount != rhs.addrToAmount { return false }
    if lhs.targetConf != rhs.targetConf { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee_sat"),
    2: .same(proto: "feerate_sat_per_byte")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.feeSat)
      case 2: try decoder.decodeSingularInt64Field(value: &self.feerateSatPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.feeSat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeSat, fieldNumber: 1)
    }
    if self.feerateSatPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.feerateSatPerByte, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EstimateFeeResponse, rhs: Lnrpc_EstimateFeeResponse) -> Bool {
    if lhs.feeSat != rhs.feeSat { return false }
    if lhs.feerateSatPerByte != rhs.feerateSatPerByte { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendManyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AddrToAmount"),
    3: .standard(proto: "target_conf"),
    5: .standard(proto: "sat_per_byte")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self, value: &self.addrToAmount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 5: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrToAmount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self, value: self.addrToAmount, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendManyRequest, rhs: Lnrpc_SendManyRequest) -> Bool {
    if lhs.addrToAmount != rhs.addrToAmount { return false }
    if lhs.targetConf != rhs.targetConf { return false }
    if lhs.satPerByte != rhs.satPerByte { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendManyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendManyResponse, rhs: Lnrpc_SendManyResponse) -> Bool {
    if lhs.txid != rhs.txid { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendCoinsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "amount"),
    3: .standard(proto: "target_conf"),
    5: .standard(proto: "sat_per_byte"),
    6: .standard(proto: "send_all")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.addr)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 5: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      case 6: try decoder.decodeSingularBoolField(value: &self.sendAll)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    if self.sendAll != false {
      try visitor.visitSingularBoolField(value: self.sendAll, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCoinsRequest, rhs: Lnrpc_SendCoinsRequest) -> Bool {
    if lhs.addr != rhs.addr { return false }
    if lhs.amount != rhs.amount { return false }
    if lhs.targetConf != rhs.targetConf { return false }
    if lhs.satPerByte != rhs.satPerByte { return false }
    if lhs.sendAll != rhs.sendAll { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SendCoinsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SendCoinsResponse, rhs: Lnrpc_SendCoinsResponse) -> Bool {
    if lhs.txid != rhs.txid { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.minConfs)
      case 2: try decoder.decodeSingularInt32Field(value: &self.maxConfs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListUnspentRequest, rhs: Lnrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs { return false }
    if lhs.maxConfs != rhs.maxConfs { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.utxos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListUnspentResponse, rhs: Lnrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NewAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .witnessPubkeyHash {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NewAddressRequest, rhs: Lnrpc_NewAddressRequest) -> Bool {
    if lhs.type != rhs.type { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NewAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NewAddressResponse, rhs: Lnrpc_NewAddressResponse) -> Bool {
    if lhs.address != rhs.address { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SignMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SignMessageRequest, rhs: Lnrpc_SignMessageRequest) -> Bool {
    if lhs.msg != rhs.msg { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_SignMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_SignMessageResponse, rhs: Lnrpc_SignMessageResponse) -> Bool {
    if lhs.signature != rhs.signature { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_VerifyMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "signature")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.msg)
      case 2: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyMessageRequest, rhs: Lnrpc_VerifyMessageRequest) -> Bool {
    if lhs.msg != rhs.msg { return false }
    if lhs.signature != rhs.signature { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_VerifyMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .same(proto: "pubkey")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.valid)
      case 2: try decoder.decodeSingularStringField(value: &self.pubkey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyMessageResponse, rhs: Lnrpc_VerifyMessageResponse) -> Bool {
    if lhs.valid != rhs.valid { return false }
    if lhs.pubkey != rhs.pubkey { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ConnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "perm")
  ]

  fileprivate class _StorageClass {
    var _addr: Lnrpc_LightningAddress?
    var _perm: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _addr = source._addr
      _perm = source._perm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._addr)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._perm)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._addr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._perm != false {
        try visitor.visitSingularBoolField(value: _storage._perm, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConnectPeerRequest, rhs: Lnrpc_ConnectPeerRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._addr != rhs_storage._addr { return false }
        if _storage._perm != rhs_storage._perm { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ConnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConnectPeerResponse, rhs: Lnrpc_ConnectPeerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DisconnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pub_key")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DisconnectPeerRequest, rhs: Lnrpc_DisconnectPeerRequest) -> Bool {
    if lhs.pubKey != rhs.pubKey { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DisconnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DisconnectPeerResponse, rhs: Lnrpc_DisconnectPeerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_HTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .same(proto: "hash_lock"),
    4: .same(proto: "expiration_height")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.incoming)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularBytesField(value: &self.hashLock)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.expirationHeight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.hashLock.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashLock, fieldNumber: 3)
    }
    if self.expirationHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.expirationHeight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_HTLC, rhs: Lnrpc_HTLC) -> Bool {
    if lhs.incoming != rhs.incoming { return false }
    if lhs.amount != rhs.amount { return false }
    if lhs.hashLock != rhs.hashLock { return false }
    if lhs.expirationHeight != rhs.expirationHeight { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "remote_pubkey"),
    3: .same(proto: "channel_point"),
    4: .same(proto: "chan_id"),
    5: .same(proto: "capacity"),
    6: .same(proto: "local_balance"),
    7: .same(proto: "remote_balance"),
    8: .same(proto: "commit_fee"),
    9: .same(proto: "commit_weight"),
    10: .same(proto: "fee_per_kw"),
    11: .same(proto: "unsettled_balance"),
    12: .same(proto: "total_satoshis_sent"),
    13: .same(proto: "total_satoshis_received"),
    14: .same(proto: "num_updates"),
    15: .same(proto: "pending_htlcs"),
    16: .same(proto: "csv_delay"),
    17: .same(proto: "private"),
    18: .same(proto: "initiator"),
    19: .same(proto: "chan_status_flags")
  ]

  fileprivate class _StorageClass {
    var _active: Bool = false
    var _remotePubkey: String = String()
    var _channelPoint: String = String()
    var _chanID: UInt64 = 0
    var _capacity: Int64 = 0
    var _localBalance: Int64 = 0
    var _remoteBalance: Int64 = 0
    var _commitFee: Int64 = 0
    var _commitWeight: Int64 = 0
    var _feePerKw: Int64 = 0
    var _unsettledBalance: Int64 = 0
    var _totalSatoshisSent: Int64 = 0
    var _totalSatoshisReceived: Int64 = 0
    var _numUpdates: UInt64 = 0
    var _pendingHtlcs: [Lnrpc_HTLC] = []
    var _csvDelay: UInt32 = 0
    var _private: Bool = false
    var _initiator: Bool = false
    var _chanStatusFlags: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _active = source._active
      _remotePubkey = source._remotePubkey
      _channelPoint = source._channelPoint
      _chanID = source._chanID
      _capacity = source._capacity
      _localBalance = source._localBalance
      _remoteBalance = source._remoteBalance
      _commitFee = source._commitFee
      _commitWeight = source._commitWeight
      _feePerKw = source._feePerKw
      _unsettledBalance = source._unsettledBalance
      _totalSatoshisSent = source._totalSatoshisSent
      _totalSatoshisReceived = source._totalSatoshisReceived
      _numUpdates = source._numUpdates
      _pendingHtlcs = source._pendingHtlcs
      _csvDelay = source._csvDelay
      _private = source._private
      _initiator = source._initiator
      _chanStatusFlags = source._chanStatusFlags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._active)
        case 2: try decoder.decodeSingularStringField(value: &_storage._remotePubkey)
        case 3: try decoder.decodeSingularStringField(value: &_storage._channelPoint)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._localBalance)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._remoteBalance)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._commitFee)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._commitWeight)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._feePerKw)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._unsettledBalance)
        case 12: try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisSent)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisReceived)
        case 14: try decoder.decodeSingularUInt64Field(value: &_storage._numUpdates)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs)
        case 16: try decoder.decodeSingularUInt32Field(value: &_storage._csvDelay)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._private)
        case 18: try decoder.decodeSingularBoolField(value: &_storage._initiator)
        case 19: try decoder.decodeSingularStringField(value: &_storage._chanStatusFlags)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._active != false {
        try visitor.visitSingularBoolField(value: _storage._active, fieldNumber: 1)
      }
      if !_storage._remotePubkey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remotePubkey, fieldNumber: 2)
      }
      if !_storage._channelPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelPoint, fieldNumber: 3)
      }
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 4)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 5)
      }
      if _storage._localBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._localBalance, fieldNumber: 6)
      }
      if _storage._remoteBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remoteBalance, fieldNumber: 7)
      }
      if _storage._commitFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitFee, fieldNumber: 8)
      }
      if _storage._commitWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitWeight, fieldNumber: 9)
      }
      if _storage._feePerKw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerKw, fieldNumber: 10)
      }
      if _storage._unsettledBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unsettledBalance, fieldNumber: 11)
      }
      if _storage._totalSatoshisSent != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisSent, fieldNumber: 12)
      }
      if _storage._totalSatoshisReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisReceived, fieldNumber: 13)
      }
      if _storage._numUpdates != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numUpdates, fieldNumber: 14)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 15)
      }
      if _storage._csvDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._csvDelay, fieldNumber: 16)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 17)
      }
      if _storage._initiator != false {
        try visitor.visitSingularBoolField(value: _storage._initiator, fieldNumber: 18)
      }
      if !_storage._chanStatusFlags.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chanStatusFlags, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Channel, rhs: Lnrpc_Channel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._active != rhs_storage._active { return false }
        if _storage._remotePubkey != rhs_storage._remotePubkey { return false }
        if _storage._channelPoint != rhs_storage._channelPoint { return false }
        if _storage._chanID != rhs_storage._chanID { return false }
        if _storage._capacity != rhs_storage._capacity { return false }
        if _storage._localBalance != rhs_storage._localBalance { return false }
        if _storage._remoteBalance != rhs_storage._remoteBalance { return false }
        if _storage._commitFee != rhs_storage._commitFee { return false }
        if _storage._commitWeight != rhs_storage._commitWeight { return false }
        if _storage._feePerKw != rhs_storage._feePerKw { return false }
        if _storage._unsettledBalance != rhs_storage._unsettledBalance { return false }
        if _storage._totalSatoshisSent != rhs_storage._totalSatoshisSent { return false }
        if _storage._totalSatoshisReceived != rhs_storage._totalSatoshisReceived { return false }
        if _storage._numUpdates != rhs_storage._numUpdates { return false }
        if _storage._pendingHtlcs != rhs_storage._pendingHtlcs { return false }
        if _storage._csvDelay != rhs_storage._csvDelay { return false }
        if _storage._private != rhs_storage._private { return false }
        if _storage._initiator != rhs_storage._initiator { return false }
        if _storage._chanStatusFlags != rhs_storage._chanStatusFlags { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_only"),
    2: .standard(proto: "inactive_only"),
    3: .standard(proto: "public_only"),
    4: .standard(proto: "private_only")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.activeOnly)
      case 2: try decoder.decodeSingularBoolField(value: &self.inactiveOnly)
      case 3: try decoder.decodeSingularBoolField(value: &self.publicOnly)
      case 4: try decoder.decodeSingularBoolField(value: &self.privateOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeOnly != false {
      try visitor.visitSingularBoolField(value: self.activeOnly, fieldNumber: 1)
    }
    if self.inactiveOnly != false {
      try visitor.visitSingularBoolField(value: self.inactiveOnly, fieldNumber: 2)
    }
    if self.publicOnly != false {
      try visitor.visitSingularBoolField(value: self.publicOnly, fieldNumber: 3)
    }
    if self.privateOnly != false {
      try visitor.visitSingularBoolField(value: self.privateOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListChannelsRequest, rhs: Lnrpc_ListChannelsRequest) -> Bool {
    if lhs.activeOnly != rhs.activeOnly { return false }
    if lhs.inactiveOnly != rhs.inactiveOnly { return false }
    if lhs.publicOnly != rhs.publicOnly { return false }
    if lhs.privateOnly != rhs.privateOnly { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .same(proto: "channels")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 11: try decoder.decodeRepeatedMessageField(value: &self.channels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListChannelsResponse, rhs: Lnrpc_ListChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelCloseSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCloseSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_point"),
    2: .same(proto: "chan_id"),
    3: .same(proto: "chain_hash"),
    4: .same(proto: "closing_tx_hash"),
    5: .same(proto: "remote_pubkey"),
    6: .same(proto: "capacity"),
    7: .same(proto: "close_height"),
    8: .same(proto: "settled_balance"),
    9: .same(proto: "time_locked_balance"),
    10: .same(proto: "close_type")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.channelPoint)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 3: try decoder.decodeSingularStringField(value: &self.chainHash)
      case 4: try decoder.decodeSingularStringField(value: &self.closingTxHash)
      case 5: try decoder.decodeSingularStringField(value: &self.remotePubkey)
      case 6: try decoder.decodeSingularInt64Field(value: &self.capacity)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.closeHeight)
      case 8: try decoder.decodeSingularInt64Field(value: &self.settledBalance)
      case 9: try decoder.decodeSingularInt64Field(value: &self.timeLockedBalance)
      case 10: try decoder.decodeSingularEnumField(value: &self.closeType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 1)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 2)
    }
    if !self.chainHash.isEmpty {
      try visitor.visitSingularStringField(value: self.chainHash, fieldNumber: 3)
    }
    if !self.closingTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.closingTxHash, fieldNumber: 4)
    }
    if !self.remotePubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.remotePubkey, fieldNumber: 5)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 6)
    }
    if self.closeHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.closeHeight, fieldNumber: 7)
    }
    if self.settledBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.settledBalance, fieldNumber: 8)
    }
    if self.timeLockedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockedBalance, fieldNumber: 9)
    }
    if self.closeType != .cooperativeClose {
      try visitor.visitSingularEnumField(value: self.closeType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelCloseSummary, rhs: Lnrpc_ChannelCloseSummary) -> Bool {
    if lhs.channelPoint != rhs.channelPoint { return false }
    if lhs.chanID != rhs.chanID { return false }
    if lhs.chainHash != rhs.chainHash { return false }
    if lhs.closingTxHash != rhs.closingTxHash { return false }
    if lhs.remotePubkey != rhs.remotePubkey { return false }
    if lhs.capacity != rhs.capacity { return false }
    if lhs.closeHeight != rhs.closeHeight { return false }
    if lhs.settledBalance != rhs.settledBalance { return false }
    if lhs.timeLockedBalance != rhs.timeLockedBalance { return false }
    if lhs.closeType != rhs.closeType { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelCloseSummary.ClosureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COOPERATIVE_CLOSE"),
    1: .same(proto: "LOCAL_FORCE_CLOSE"),
    2: .same(proto: "REMOTE_FORCE_CLOSE"),
    3: .same(proto: "BREACH_CLOSE"),
    4: .same(proto: "FUNDING_CANCELED"),
    5: .same(proto: "ABANDONED")
  ]
}

extension Lnrpc_ClosedChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cooperative"),
    2: .standard(proto: "local_force"),
    3: .standard(proto: "remote_force"),
    4: .same(proto: "breach"),
    5: .standard(proto: "funding_canceled"),
    6: .same(proto: "abandoned")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.cooperative)
      case 2: try decoder.decodeSingularBoolField(value: &self.localForce)
      case 3: try decoder.decodeSingularBoolField(value: &self.remoteForce)
      case 4: try decoder.decodeSingularBoolField(value: &self.breach)
      case 5: try decoder.decodeSingularBoolField(value: &self.fundingCanceled)
      case 6: try decoder.decodeSingularBoolField(value: &self.abandoned)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cooperative != false {
      try visitor.visitSingularBoolField(value: self.cooperative, fieldNumber: 1)
    }
    if self.localForce != false {
      try visitor.visitSingularBoolField(value: self.localForce, fieldNumber: 2)
    }
    if self.remoteForce != false {
      try visitor.visitSingularBoolField(value: self.remoteForce, fieldNumber: 3)
    }
    if self.breach != false {
      try visitor.visitSingularBoolField(value: self.breach, fieldNumber: 4)
    }
    if self.fundingCanceled != false {
      try visitor.visitSingularBoolField(value: self.fundingCanceled, fieldNumber: 5)
    }
    if self.abandoned != false {
      try visitor.visitSingularBoolField(value: self.abandoned, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelsRequest, rhs: Lnrpc_ClosedChannelsRequest) -> Bool {
    if lhs.cooperative != rhs.cooperative { return false }
    if lhs.localForce != rhs.localForce { return false }
    if lhs.remoteForce != rhs.remoteForce { return false }
    if lhs.breach != rhs.breach { return false }
    if lhs.fundingCanceled != rhs.fundingCanceled { return false }
    if lhs.abandoned != rhs.abandoned { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ClosedChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.channels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelsResponse, rhs: Lnrpc_ClosedChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Peer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pub_key"),
    3: .same(proto: "address"),
    4: .same(proto: "bytes_sent"),
    5: .same(proto: "bytes_recv"),
    6: .same(proto: "sat_sent"),
    7: .same(proto: "sat_recv"),
    8: .same(proto: "inbound"),
    9: .same(proto: "ping_time"),
    10: .same(proto: "sync_type")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 3: try decoder.decodeSingularStringField(value: &self.address)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.bytesSent)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.bytesRecv)
      case 6: try decoder.decodeSingularInt64Field(value: &self.satSent)
      case 7: try decoder.decodeSingularInt64Field(value: &self.satRecv)
      case 8: try decoder.decodeSingularBoolField(value: &self.inbound)
      case 9: try decoder.decodeSingularInt64Field(value: &self.pingTime)
      case 10: try decoder.decodeSingularEnumField(value: &self.syncType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 4)
    }
    if self.bytesRecv != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesRecv, fieldNumber: 5)
    }
    if self.satSent != 0 {
      try visitor.visitSingularInt64Field(value: self.satSent, fieldNumber: 6)
    }
    if self.satRecv != 0 {
      try visitor.visitSingularInt64Field(value: self.satRecv, fieldNumber: 7)
    }
    if self.inbound != false {
      try visitor.visitSingularBoolField(value: self.inbound, fieldNumber: 8)
    }
    if self.pingTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pingTime, fieldNumber: 9)
    }
    if self.syncType != .unknownSync {
      try visitor.visitSingularEnumField(value: self.syncType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Peer, rhs: Lnrpc_Peer) -> Bool {
    if lhs.pubKey != rhs.pubKey { return false }
    if lhs.address != rhs.address { return false }
    if lhs.bytesSent != rhs.bytesSent { return false }
    if lhs.bytesRecv != rhs.bytesRecv { return false }
    if lhs.satSent != rhs.satSent { return false }
    if lhs.satRecv != rhs.satRecv { return false }
    if lhs.inbound != rhs.inbound { return false }
    if lhs.pingTime != rhs.pingTime { return false }
    if lhs.syncType != rhs.syncType { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Peer.SyncType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SYNC"),
    1: .same(proto: "ACTIVE_SYNC"),
    2: .same(proto: "PASSIVE_SYNC")
  ]
}

extension Lnrpc_ListPeersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPeersRequest, rhs: Lnrpc_ListPeersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListPeersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.peers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPeersResponse, rhs: Lnrpc_ListPeersResponse) -> Bool {
    if lhs.peers != rhs.peers { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GetInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetInfoRequest, rhs: Lnrpc_GetInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity_pubkey"),
    2: .same(proto: "alias"),
    3: .same(proto: "num_pending_channels"),
    4: .same(proto: "num_active_channels"),
    5: .same(proto: "num_peers"),
    6: .same(proto: "block_height"),
    8: .same(proto: "block_hash"),
    9: .same(proto: "synced_to_chain"),
    10: .same(proto: "testnet"),
    12: .same(proto: "uris"),
    13: .same(proto: "best_header_timestamp"),
    14: .same(proto: "version"),
    15: .same(proto: "num_inactive_channels"),
    16: .same(proto: "chains")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.identityPubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.alias)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numPendingChannels)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numActiveChannels)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numPeers)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.blockHeight)
      case 8: try decoder.decodeSingularStringField(value: &self.blockHash)
      case 9: try decoder.decodeSingularBoolField(value: &self.syncedToChain)
      case 10: try decoder.decodeSingularBoolField(value: &self.testnet)
      case 12: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 13: try decoder.decodeSingularInt64Field(value: &self.bestHeaderTimestamp)
      case 14: try decoder.decodeSingularStringField(value: &self.version)
      case 15: try decoder.decodeSingularUInt32Field(value: &self.numInactiveChannels)
      case 16: try decoder.decodeRepeatedMessageField(value: &self.chains)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identityPubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityPubkey, fieldNumber: 1)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 2)
    }
    if self.numPendingChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingChannels, fieldNumber: 3)
    }
    if self.numActiveChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numActiveChannels, fieldNumber: 4)
    }
    if self.numPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPeers, fieldNumber: 5)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockHeight, fieldNumber: 6)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 8)
    }
    if self.syncedToChain != false {
      try visitor.visitSingularBoolField(value: self.syncedToChain, fieldNumber: 9)
    }
    if self.testnet != false {
      try visitor.visitSingularBoolField(value: self.testnet, fieldNumber: 10)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 12)
    }
    if self.bestHeaderTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.bestHeaderTimestamp, fieldNumber: 13)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 14)
    }
    if self.numInactiveChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numInactiveChannels, fieldNumber: 15)
    }
    if !self.chains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chains, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GetInfoResponse, rhs: Lnrpc_GetInfoResponse) -> Bool {
    if lhs.identityPubkey != rhs.identityPubkey { return false }
    if lhs.alias != rhs.alias { return false }
    if lhs.numPendingChannels != rhs.numPendingChannels { return false }
    if lhs.numActiveChannels != rhs.numActiveChannels { return false }
    if lhs.numPeers != rhs.numPeers { return false }
    if lhs.blockHeight != rhs.blockHeight { return false }
    if lhs.blockHash != rhs.blockHash { return false }
    if lhs.syncedToChain != rhs.syncedToChain { return false }
    if lhs.testnet != rhs.testnet { return false }
    if lhs.uris != rhs.uris { return false }
    if lhs.bestHeaderTimestamp != rhs.bestHeaderTimestamp { return false }
    if lhs.version != rhs.version { return false }
    if lhs.numInactiveChannels != rhs.numInactiveChannels { return false }
    if lhs.chains != rhs.chains { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Chain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "network")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chain)
      case 2: try decoder.decodeSingularStringField(value: &self.network)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chain.isEmpty {
      try visitor.visitSingularStringField(value: self.chain, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Chain, rhs: Lnrpc_Chain) -> Bool {
    if lhs.chain != rhs.chain { return false }
    if lhs.network != rhs.network { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ConfirmationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmationUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_sha"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "num_confs_left")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockSha)
      case 2: try decoder.decodeSingularInt32Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numConfsLeft)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockSha.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockSha, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 2)
    }
    if self.numConfsLeft != 0 {
      try visitor.visitSingularUInt32Field(value: self.numConfsLeft, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ConfirmationUpdate, rhs: Lnrpc_ConfirmationUpdate) -> Bool {
    if lhs.blockSha != rhs.blockSha { return false }
    if lhs.blockHeight != rhs.blockHeight { return false }
    if lhs.numConfsLeft != rhs.numConfsLeft { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelOpenUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelOpenUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_point")
  ]

  fileprivate class _StorageClass {
    var _channelPoint: Lnrpc_ChannelPoint?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPoint = source._channelPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channelPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channelPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelOpenUpdate, rhs: Lnrpc_ChannelOpenUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelPoint != rhs_storage._channelPoint { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelCloseUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCloseUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closing_txid"),
    2: .same(proto: "success")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.closingTxid)
      case 2: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.closingTxid, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelCloseUpdate, rhs: Lnrpc_ChannelCloseUpdate) -> Bool {
    if lhs.closingTxid != rhs.closingTxid { return false }
    if lhs.success != rhs.success { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_CloseChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
    2: .same(proto: "force"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_byte")
  ]

  fileprivate class _StorageClass {
    var _channelPoint: Lnrpc_ChannelPoint?
    var _force: Bool = false
    var _targetConf: Int32 = 0
    var _satPerByte: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPoint = source._channelPoint
      _force = source._force
      _targetConf = source._targetConf
      _satPerByte = source._satPerByte
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channelPoint)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._force)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._targetConf)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._satPerByte)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channelPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._force != false {
        try visitor.visitSingularBoolField(value: _storage._force, fieldNumber: 2)
      }
      if _storage._targetConf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetConf, fieldNumber: 3)
      }
      if _storage._satPerByte != 0 {
        try visitor.visitSingularInt64Field(value: _storage._satPerByte, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CloseChannelRequest, rhs: Lnrpc_CloseChannelRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelPoint != rhs_storage._channelPoint { return false }
        if _storage._force != rhs_storage._force { return false }
        if _storage._targetConf != rhs_storage._targetConf { return false }
        if _storage._satPerByte != rhs_storage._satPerByte { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_CloseStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "close_pending"),
    3: .same(proto: "chan_close")
  ]

  fileprivate class _StorageClass {
    var _update: Lnrpc_CloseStatusUpdate.OneOf_Update?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_PendingUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .closePending(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._update = .closePending(v) }
        case 3:
          var v: Lnrpc_ChannelCloseUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanClose(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._update = .chanClose(v) }
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._update {
      case .closePending(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .chanClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_CloseStatusUpdate, rhs: Lnrpc_CloseStatusUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._update != rhs_storage._update { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "output_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txid)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.outputIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingUpdate, rhs: Lnrpc_PendingUpdate) -> Bool {
    if lhs.txid != rhs.txid { return false }
    if lhs.outputIndex != rhs.outputIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_OpenChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "node_pubkey"),
    3: .same(proto: "node_pubkey_string"),
    4: .same(proto: "local_funding_amount"),
    5: .same(proto: "push_sat"),
    6: .standard(proto: "target_conf"),
    7: .standard(proto: "sat_per_byte"),
    8: .same(proto: "private"),
    9: .same(proto: "min_htlc_msat"),
    10: .same(proto: "remote_csv_delay"),
    11: .same(proto: "min_confs"),
    12: .same(proto: "spend_unconfirmed")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularBytesField(value: &self.nodePubkey)
      case 3: try decoder.decodeSingularStringField(value: &self.nodePubkeyString)
      case 4: try decoder.decodeSingularInt64Field(value: &self.localFundingAmount)
      case 5: try decoder.decodeSingularInt64Field(value: &self.pushSat)
      case 6: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 7: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      case 8: try decoder.decodeSingularBoolField(value: &self.`private`)
      case 9: try decoder.decodeSingularInt64Field(value: &self.minHtlcMsat)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.remoteCsvDelay)
      case 11: try decoder.decodeSingularInt32Field(value: &self.minConfs)
      case 12: try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePubkey, fieldNumber: 2)
    }
    if !self.nodePubkeyString.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePubkeyString, fieldNumber: 3)
    }
    if self.localFundingAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.localFundingAmount, fieldNumber: 4)
    }
    if self.pushSat != 0 {
      try visitor.visitSingularInt64Field(value: self.pushSat, fieldNumber: 5)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 6)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 7)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 8)
    }
    if self.minHtlcMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlcMsat, fieldNumber: 9)
    }
    if self.remoteCsvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.remoteCsvDelay, fieldNumber: 10)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 11)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OpenChannelRequest, rhs: Lnrpc_OpenChannelRequest) -> Bool {
    if lhs.nodePubkey != rhs.nodePubkey { return false }
    if lhs.nodePubkeyString != rhs.nodePubkeyString { return false }
    if lhs.localFundingAmount != rhs.localFundingAmount { return false }
    if lhs.pushSat != rhs.pushSat { return false }
    if lhs.targetConf != rhs.targetConf { return false }
    if lhs.satPerByte != rhs.satPerByte { return false }
    if lhs.`private` != rhs.`private` { return false }
    if lhs.minHtlcMsat != rhs.minHtlcMsat { return false }
    if lhs.remoteCsvDelay != rhs.remoteCsvDelay { return false }
    if lhs.minConfs != rhs.minConfs { return false }
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_OpenStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_pending"),
    3: .same(proto: "chan_open")
  ]

  fileprivate class _StorageClass {
    var _update: Lnrpc_OpenStatusUpdate.OneOf_Update?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_PendingUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanPending(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._update = .chanPending(v) }
        case 3:
          var v: Lnrpc_ChannelOpenUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanOpen(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._update = .chanOpen(v) }
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._update {
      case .chanPending(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .chanOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_OpenStatusUpdate, rhs: Lnrpc_OpenStatusUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._update != rhs_storage._update { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingHTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingHTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .same(proto: "outpoint"),
    4: .same(proto: "maturity_height"),
    5: .same(proto: "blocks_til_maturity"),
    6: .same(proto: "stage")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.incoming)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularStringField(value: &self.outpoint)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.maturityHeight)
      case 5: try decoder.decodeSingularInt32Field(value: &self.blocksTilMaturity)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.stage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.outpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.outpoint, fieldNumber: 3)
    }
    if self.maturityHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.maturityHeight, fieldNumber: 4)
    }
    if self.blocksTilMaturity != 0 {
      try visitor.visitSingularInt32Field(value: self.blocksTilMaturity, fieldNumber: 5)
    }
    if self.stage != 0 {
      try visitor.visitSingularUInt32Field(value: self.stage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingHTLC, rhs: Lnrpc_PendingHTLC) -> Bool {
    if lhs.incoming != rhs.incoming { return false }
    if lhs.amount != rhs.amount { return false }
    if lhs.outpoint != rhs.outpoint { return false }
    if lhs.maturityHeight != rhs.maturityHeight { return false }
    if lhs.blocksTilMaturity != rhs.blocksTilMaturity { return false }
    if lhs.stage != rhs.stage { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsRequest, rhs: Lnrpc_PendingChannelsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_limbo_balance"),
    2: .same(proto: "pending_open_channels"),
    3: .same(proto: "pending_closing_channels"),
    4: .same(proto: "pending_force_closing_channels"),
    5: .same(proto: "waiting_close_channels")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.totalLimboBalance)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.pendingOpenChannels)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.pendingClosingChannels)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.pendingForceClosingChannels)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.waitingCloseChannels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalLimboBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalLimboBalance, fieldNumber: 1)
    }
    if !self.pendingOpenChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingOpenChannels, fieldNumber: 2)
    }
    if !self.pendingClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingClosingChannels, fieldNumber: 3)
    }
    if !self.pendingForceClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingForceClosingChannels, fieldNumber: 4)
    }
    if !self.waitingCloseChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waitingCloseChannels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse, rhs: Lnrpc_PendingChannelsResponse) -> Bool {
    if lhs.totalLimboBalance != rhs.totalLimboBalance { return false }
    if lhs.pendingOpenChannels != rhs.pendingOpenChannels { return false }
    if lhs.pendingClosingChannels != rhs.pendingClosingChannels { return false }
    if lhs.pendingForceClosingChannels != rhs.pendingForceClosingChannels { return false }
    if lhs.waitingCloseChannels != rhs.waitingCloseChannels { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "remote_node_pub"),
    2: .same(proto: "channel_point"),
    3: .same(proto: "capacity"),
    4: .same(proto: "local_balance"),
    5: .same(proto: "remote_balance")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.remoteNodePub)
      case 2: try decoder.decodeSingularStringField(value: &self.channelPoint)
      case 3: try decoder.decodeSingularInt64Field(value: &self.capacity)
      case 4: try decoder.decodeSingularInt64Field(value: &self.localBalance)
      case 5: try decoder.decodeSingularInt64Field(value: &self.remoteBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.remoteNodePub.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteNodePub, fieldNumber: 1)
    }
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 2)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 3)
    }
    if self.localBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.localBalance, fieldNumber: 4)
    }
    if self.remoteBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteBalance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.PendingChannel, rhs: Lnrpc_PendingChannelsResponse.PendingChannel) -> Bool {
    if lhs.remoteNodePub != rhs.remoteNodePub { return false }
    if lhs.channelPoint != rhs.channelPoint { return false }
    if lhs.capacity != rhs.capacity { return false }
    if lhs.localBalance != rhs.localBalance { return false }
    if lhs.remoteBalance != rhs.remoteBalance { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingOpenChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingOpenChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "confirmation_height"),
    4: .same(proto: "commit_fee"),
    5: .same(proto: "commit_weight"),
    6: .same(proto: "fee_per_kw")
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel?
    var _confirmationHeight: UInt32 = 0
    var _commitFee: Int64 = 0
    var _commitWeight: Int64 = 0
    var _feePerKw: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _confirmationHeight = source._confirmationHeight
      _commitFee = source._commitFee
      _commitWeight = source._commitWeight
      _feePerKw = source._feePerKw
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._confirmationHeight)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._commitFee)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._commitWeight)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._feePerKw)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._confirmationHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._confirmationHeight, fieldNumber: 2)
      }
      if _storage._commitFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitFee, fieldNumber: 4)
      }
      if _storage._commitWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitWeight, fieldNumber: 5)
      }
      if _storage._feePerKw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerKw, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.PendingOpenChannel, rhs: Lnrpc_PendingChannelsResponse.PendingOpenChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel { return false }
        if _storage._confirmationHeight != rhs_storage._confirmationHeight { return false }
        if _storage._commitFee != rhs_storage._commitFee { return false }
        if _storage._commitWeight != rhs_storage._commitWeight { return false }
        if _storage._feePerKw != rhs_storage._feePerKw { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.WaitingCloseChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".WaitingCloseChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "limbo_balance")
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel?
    var _limboBalance: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _limboBalance = source._limboBalance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._limboBalance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.WaitingCloseChannel, rhs: Lnrpc_PendingChannelsResponse.WaitingCloseChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel { return false }
        if _storage._limboBalance != rhs_storage._limboBalance { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "closing_txid")
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel?
    var _closingTxid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _closingTxid = source._closingTxid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularStringField(value: &_storage._closingTxid)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._closingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closingTxid, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.ClosedChannel, rhs: Lnrpc_PendingChannelsResponse.ClosedChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel { return false }
        if _storage._closingTxid != rhs_storage._closingTxid { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ForceClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ForceClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "closing_txid"),
    3: .same(proto: "limbo_balance"),
    4: .same(proto: "maturity_height"),
    5: .same(proto: "blocks_til_maturity"),
    6: .same(proto: "recovered_balance"),
    8: .same(proto: "pending_htlcs")
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel?
    var _closingTxid: String = String()
    var _limboBalance: Int64 = 0
    var _maturityHeight: UInt32 = 0
    var _blocksTilMaturity: Int32 = 0
    var _recoveredBalance: Int64 = 0
    var _pendingHtlcs: [Lnrpc_PendingHTLC] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _closingTxid = source._closingTxid
      _limboBalance = source._limboBalance
      _maturityHeight = source._maturityHeight
      _blocksTilMaturity = source._blocksTilMaturity
      _recoveredBalance = source._recoveredBalance
      _pendingHtlcs = source._pendingHtlcs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularStringField(value: &_storage._closingTxid)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._limboBalance)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._maturityHeight)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._blocksTilMaturity)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._recoveredBalance)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._closingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closingTxid, fieldNumber: 2)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 3)
      }
      if _storage._maturityHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maturityHeight, fieldNumber: 4)
      }
      if _storage._blocksTilMaturity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blocksTilMaturity, fieldNumber: 5)
      }
      if _storage._recoveredBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._recoveredBalance, fieldNumber: 6)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PendingChannelsResponse.ForceClosedChannel, rhs: Lnrpc_PendingChannelsResponse.ForceClosedChannel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel { return false }
        if _storage._closingTxid != rhs_storage._closingTxid { return false }
        if _storage._limboBalance != rhs_storage._limboBalance { return false }
        if _storage._maturityHeight != rhs_storage._maturityHeight { return false }
        if _storage._blocksTilMaturity != rhs_storage._blocksTilMaturity { return false }
        if _storage._recoveredBalance != rhs_storage._recoveredBalance { return false }
        if _storage._pendingHtlcs != rhs_storage._pendingHtlcs { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelEventSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEventSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEventSubscription, rhs: Lnrpc_ChannelEventSubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelEventUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEventUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open_channel"),
    2: .same(proto: "closed_channel"),
    3: .same(proto: "active_channel"),
    4: .same(proto: "inactive_channel"),
    5: .same(proto: "type")
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_ChannelEventUpdate.OneOf_Channel?
    var _type: Lnrpc_ChannelEventUpdate.UpdateType = .openChannel

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_Channel?
          if let current = _storage._channel {
            try decoder.handleConflictingOneOf()
            if case .openChannel(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._channel = .openChannel(v) }
        case 2:
          var v: Lnrpc_ChannelCloseSummary?
          if let current = _storage._channel {
            try decoder.handleConflictingOneOf()
            if case .closedChannel(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._channel = .closedChannel(v) }
        case 3:
          var v: Lnrpc_ChannelPoint?
          if let current = _storage._channel {
            try decoder.handleConflictingOneOf()
            if case .activeChannel(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._channel = .activeChannel(v) }
        case 4:
          var v: Lnrpc_ChannelPoint?
          if let current = _storage._channel {
            try decoder.handleConflictingOneOf()
            if case .inactiveChannel(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._channel = .inactiveChannel(v) }
        case 5: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._channel {
      case .openChannel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .closedChannel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .activeChannel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .inactiveChannel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
      if _storage._type != .openChannel {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEventUpdate, rhs: Lnrpc_ChannelEventUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel { return false }
        if _storage._type != rhs_storage._type { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelEventUpdate.UpdateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN_CHANNEL"),
    1: .same(proto: "CLOSED_CHANNEL"),
    2: .same(proto: "ACTIVE_CHANNEL"),
    3: .same(proto: "INACTIVE_CHANNEL")
  ]
}

extension Lnrpc_WalletBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WalletBalanceRequest, rhs: Lnrpc_WalletBalanceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_WalletBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_balance"),
    2: .same(proto: "confirmed_balance"),
    3: .same(proto: "unconfirmed_balance")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.totalBalance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.confirmedBalance)
      case 3: try decoder.decodeSingularInt64Field(value: &self.unconfirmedBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBalance, fieldNumber: 1)
    }
    if self.confirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.confirmedBalance, fieldNumber: 2)
    }
    if self.unconfirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.unconfirmedBalance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_WalletBalanceResponse, rhs: Lnrpc_WalletBalanceResponse) -> Bool {
    if lhs.totalBalance != rhs.totalBalance { return false }
    if lhs.confirmedBalance != rhs.confirmedBalance { return false }
    if lhs.unconfirmedBalance != rhs.unconfirmedBalance { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBalanceRequest, rhs: Lnrpc_ChannelBalanceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "pending_open_balance")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.balance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.pendingOpenBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 1)
    }
    if self.pendingOpenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingOpenBalance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBalanceResponse, rhs: Lnrpc_ChannelBalanceResponse) -> Bool {
    if lhs.balance != rhs.balance { return false }
    if lhs.pendingOpenBalance != rhs.pendingOpenBalance { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_QueryRoutesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "amt"),
    3: .standard(proto: "num_routes"),
    4: .standard(proto: "final_cltv_delta"),
    5: .standard(proto: "fee_limit"),
    6: .standard(proto: "ignored_nodes"),
    7: .standard(proto: "ignored_edges"),
    8: .standard(proto: "source_pub_key")
  ]

  fileprivate class _StorageClass {
    var _pubKey: String = String()
    var _amt: Int64 = 0
    var _numRoutes: Int32 = 0
    var _finalCltvDelta: Int32 = 0
    var _feeLimit: Lnrpc_FeeLimit?
    var _ignoredNodes: [Data] = []
    var _ignoredEdges: [Lnrpc_EdgeLocator] = []
    var _sourcePubKey: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pubKey = source._pubKey
      _amt = source._amt
      _numRoutes = source._numRoutes
      _finalCltvDelta = source._finalCltvDelta
      _feeLimit = source._feeLimit
      _ignoredNodes = source._ignoredNodes
      _ignoredEdges = source._ignoredEdges
      _sourcePubKey = source._sourcePubKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._pubKey)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._amt)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._numRoutes)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._finalCltvDelta)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._feeLimit)
        case 6: try decoder.decodeRepeatedBytesField(value: &_storage._ignoredNodes)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._ignoredEdges)
        case 8: try decoder.decodeSingularStringField(value: &_storage._sourcePubKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._pubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pubKey, fieldNumber: 1)
      }
      if _storage._amt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amt, fieldNumber: 2)
      }
      if _storage._numRoutes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numRoutes, fieldNumber: 3)
      }
      if _storage._finalCltvDelta != 0 {
        try visitor.visitSingularInt32Field(value: _storage._finalCltvDelta, fieldNumber: 4)
      }
      if let v = _storage._feeLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._ignoredNodes.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._ignoredNodes, fieldNumber: 6)
      }
      if !_storage._ignoredEdges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ignoredEdges, fieldNumber: 7)
      }
      if !_storage._sourcePubKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourcePubKey, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_QueryRoutesRequest, rhs: Lnrpc_QueryRoutesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pubKey != rhs_storage._pubKey { return false }
        if _storage._amt != rhs_storage._amt { return false }
        if _storage._numRoutes != rhs_storage._numRoutes { return false }
        if _storage._finalCltvDelta != rhs_storage._finalCltvDelta { return false }
        if _storage._feeLimit != rhs_storage._feeLimit { return false }
        if _storage._ignoredNodes != rhs_storage._ignoredNodes { return false }
        if _storage._ignoredEdges != rhs_storage._ignoredEdges { return false }
        if _storage._sourcePubKey != rhs_storage._sourcePubKey { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_EdgeLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeLocator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "direction_reverse")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.channelID)
      case 2: try decoder.decodeSingularBoolField(value: &self.directionReverse)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    if self.directionReverse != false {
      try visitor.visitSingularBoolField(value: self.directionReverse, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_EdgeLocator, rhs: Lnrpc_EdgeLocator) -> Bool {
    if lhs.channelID != rhs.channelID { return false }
    if lhs.directionReverse != rhs.directionReverse { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_QueryRoutesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.routes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_QueryRoutesResponse, rhs: Lnrpc_QueryRoutesResponse) -> Bool {
    if lhs.routes != rhs.routes { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Hop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_id"),
    2: .same(proto: "chan_capacity"),
    3: .same(proto: "amt_to_forward"),
    4: .same(proto: "fee"),
    5: .same(proto: "expiry"),
    6: .same(proto: "amt_to_forward_msat"),
    7: .same(proto: "fee_msat"),
    8: .same(proto: "pub_key")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.chanCapacity)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amtToForward)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.expiry)
      case 6: try decoder.decodeSingularInt64Field(value: &self.amtToForwardMsat)
      case 7: try decoder.decodeSingularInt64Field(value: &self.feeMsat)
      case 8: try decoder.decodeSingularStringField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.chanCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.chanCapacity, fieldNumber: 2)
    }
    if self.amtToForward != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForward, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 5)
    }
    if self.amtToForwardMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForwardMsat, fieldNumber: 6)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeMsat, fieldNumber: 7)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Hop, rhs: Lnrpc_Hop) -> Bool {
    if lhs.chanID != rhs.chanID { return false }
    if lhs.chanCapacity != rhs.chanCapacity { return false }
    if lhs.amtToForward != rhs.amtToForward { return false }
    if lhs.fee != rhs.fee { return false }
    if lhs.expiry != rhs.expiry { return false }
    if lhs.amtToForwardMsat != rhs.amtToForwardMsat { return false }
    if lhs.feeMsat != rhs.feeMsat { return false }
    if lhs.pubKey != rhs.pubKey { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Route"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_time_lock"),
    2: .same(proto: "total_fees"),
    3: .same(proto: "total_amt"),
    4: .same(proto: "hops"),
    5: .same(proto: "total_fees_msat"),
    6: .same(proto: "total_amt_msat")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.totalTimeLock)
      case 2: try decoder.decodeSingularInt64Field(value: &self.totalFees)
      case 3: try decoder.decodeSingularInt64Field(value: &self.totalAmt)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.hops)
      case 5: try decoder.decodeSingularInt64Field(value: &self.totalFeesMsat)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalAmtMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalTimeLock != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalTimeLock, fieldNumber: 1)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 2)
    }
    if self.totalAmt != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmt, fieldNumber: 3)
    }
    if !self.hops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hops, fieldNumber: 4)
    }
    if self.totalFeesMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFeesMsat, fieldNumber: 5)
    }
    if self.totalAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmtMsat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Route, rhs: Lnrpc_Route) -> Bool {
    if lhs.totalTimeLock != rhs.totalTimeLock { return false }
    if lhs.totalFees != rhs.totalFees { return false }
    if lhs.totalAmt != rhs.totalAmt { return false }
    if lhs.hops != rhs.hops { return false }
    if lhs.totalFeesMsat != rhs.totalFeesMsat { return false }
    if lhs.totalAmtMsat != rhs.totalAmtMsat { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NodeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeInfoRequest, rhs: Lnrpc_NodeInfoRequest) -> Bool {
    if lhs.pubKey != rhs.pubKey { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "num_channels"),
    3: .same(proto: "total_capacity")
  ]

  fileprivate class _StorageClass {
    var _node: Lnrpc_LightningNode?
    var _numChannels: UInt32 = 0
    var _totalCapacity: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _node = source._node
      _numChannels = source._numChannels
      _totalCapacity = source._totalCapacity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._node)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._numChannels)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._totalCapacity)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._numChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numChannels, fieldNumber: 2)
      }
      if _storage._totalCapacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalCapacity, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeInfo, rhs: Lnrpc_NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._node != rhs_storage._node { return false }
        if _storage._numChannels != rhs_storage._numChannels { return false }
        if _storage._totalCapacity != rhs_storage._totalCapacity { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_LightningNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "last_update"),
    2: .same(proto: "pub_key"),
    3: .same(proto: "alias"),
    4: .same(proto: "addresses"),
    5: .same(proto: "color")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.lastUpdate)
      case 2: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 3: try decoder.decodeSingularStringField(value: &self.alias)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.addresses)
      case 5: try decoder.decodeSingularStringField(value: &self.color)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 2)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 3)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 4)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_LightningNode, rhs: Lnrpc_LightningNode) -> Bool {
    if lhs.lastUpdate != rhs.lastUpdate { return false }
    if lhs.pubKey != rhs.pubKey { return false }
    if lhs.alias != rhs.alias { return false }
    if lhs.addresses != rhs.addresses { return false }
    if lhs.color != rhs.color { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "addr")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.network)
      case 2: try decoder.decodeSingularStringField(value: &self.addr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeAddress, rhs: Lnrpc_NodeAddress) -> Bool {
    if lhs.network != rhs.network { return false }
    if lhs.addr != rhs.addr { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_RoutingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time_lock_delta"),
    2: .same(proto: "min_htlc"),
    3: .same(proto: "fee_base_msat"),
    4: .same(proto: "fee_rate_milli_msat"),
    5: .same(proto: "disabled"),
    6: .same(proto: "max_htlc_msat")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta)
      case 2: try decoder.decodeSingularInt64Field(value: &self.minHtlc)
      case 3: try decoder.decodeSingularInt64Field(value: &self.feeBaseMsat)
      case 4: try decoder.decodeSingularInt64Field(value: &self.feeRateMilliMsat)
      case 5: try decoder.decodeSingularBoolField(value: &self.disabled)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.maxHtlcMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 1)
    }
    if self.minHtlc != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlc, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeRateMilliMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeRateMilliMsat, fieldNumber: 4)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 5)
    }
    if self.maxHtlcMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxHtlcMsat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RoutingPolicy, rhs: Lnrpc_RoutingPolicy) -> Bool {
    if lhs.timeLockDelta != rhs.timeLockDelta { return false }
    if lhs.minHtlc != rhs.minHtlc { return false }
    if lhs.feeBaseMsat != rhs.feeBaseMsat { return false }
    if lhs.feeRateMilliMsat != rhs.feeRateMilliMsat { return false }
    if lhs.disabled != rhs.disabled { return false }
    if lhs.maxHtlcMsat != rhs.maxHtlcMsat { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_id"),
    2: .same(proto: "chan_point"),
    3: .same(proto: "last_update"),
    4: .same(proto: "node1_pub"),
    5: .same(proto: "node2_pub"),
    6: .same(proto: "capacity"),
    7: .same(proto: "node1_policy"),
    8: .same(proto: "node2_policy")
  ]

  fileprivate class _StorageClass {
    var _channelID: UInt64 = 0
    var _chanPoint: String = String()
    var _lastUpdate: UInt32 = 0
    var _node1Pub: String = String()
    var _node2Pub: String = String()
    var _capacity: Int64 = 0
    var _node1Policy: Lnrpc_RoutingPolicy?
    var _node2Policy: Lnrpc_RoutingPolicy?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _chanPoint = source._chanPoint
      _lastUpdate = source._lastUpdate
      _node1Pub = source._node1Pub
      _node2Pub = source._node2Pub
      _capacity = source._capacity
      _node1Policy = source._node1Policy
      _node2Policy = source._node2Policy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._channelID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._chanPoint)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._lastUpdate)
        case 4: try decoder.decodeSingularStringField(value: &_storage._node1Pub)
        case 5: try decoder.decodeSingularStringField(value: &_storage._node2Pub)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._node1Policy)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._node2Policy)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._chanPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chanPoint, fieldNumber: 2)
      }
      if _storage._lastUpdate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lastUpdate, fieldNumber: 3)
      }
      if !_storage._node1Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node1Pub, fieldNumber: 4)
      }
      if !_storage._node2Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node2Pub, fieldNumber: 5)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 6)
      }
      if let v = _storage._node1Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._node2Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEdge, rhs: Lnrpc_ChannelEdge) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID { return false }
        if _storage._chanPoint != rhs_storage._chanPoint { return false }
        if _storage._lastUpdate != rhs_storage._lastUpdate { return false }
        if _storage._node1Pub != rhs_storage._node1Pub { return false }
        if _storage._node2Pub != rhs_storage._node2Pub { return false }
        if _storage._capacity != rhs_storage._capacity { return false }
        if _storage._node1Policy != rhs_storage._node1Policy { return false }
        if _storage._node2Policy != rhs_storage._node2Policy { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraphRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "include_unannounced")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.includeUnannounced)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeUnannounced != false {
      try visitor.visitSingularBoolField(value: self.includeUnannounced, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelGraphRequest, rhs: Lnrpc_ChannelGraphRequest) -> Bool {
    if lhs.includeUnannounced != rhs.includeUnannounced { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraph"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "edges")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.edges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if !self.edges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelGraph, rhs: Lnrpc_ChannelGraph) -> Bool {
    if lhs.nodes != rhs.nodes { return false }
    if lhs.edges != rhs.edges { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChanInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanInfoRequest, rhs: Lnrpc_ChanInfoRequest) -> Bool {
    if lhs.chanID != rhs.chanID { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NetworkInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NetworkInfoRequest, rhs: Lnrpc_NetworkInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "graph_diameter"),
    2: .same(proto: "avg_out_degree"),
    3: .same(proto: "max_out_degree"),
    4: .same(proto: "num_nodes"),
    5: .same(proto: "num_channels"),
    6: .same(proto: "total_network_capacity"),
    7: .same(proto: "avg_channel_size"),
    8: .same(proto: "min_channel_size"),
    9: .same(proto: "max_channel_size"),
    10: .same(proto: "median_channel_size_sat")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.graphDiameter)
      case 2: try decoder.decodeSingularDoubleField(value: &self.avgOutDegree)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.maxOutDegree)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numNodes)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numChannels)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalNetworkCapacity)
      case 7: try decoder.decodeSingularDoubleField(value: &self.avgChannelSize)
      case 8: try decoder.decodeSingularInt64Field(value: &self.minChannelSize)
      case 9: try decoder.decodeSingularInt64Field(value: &self.maxChannelSize)
      case 10: try decoder.decodeSingularInt64Field(value: &self.medianChannelSizeSat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.graphDiameter != 0 {
      try visitor.visitSingularUInt32Field(value: self.graphDiameter, fieldNumber: 1)
    }
    if self.avgOutDegree != 0 {
      try visitor.visitSingularDoubleField(value: self.avgOutDegree, fieldNumber: 2)
    }
    if self.maxOutDegree != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxOutDegree, fieldNumber: 3)
    }
    if self.numNodes != 0 {
      try visitor.visitSingularUInt32Field(value: self.numNodes, fieldNumber: 4)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numChannels, fieldNumber: 5)
    }
    if self.totalNetworkCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNetworkCapacity, fieldNumber: 6)
    }
    if self.avgChannelSize != 0 {
      try visitor.visitSingularDoubleField(value: self.avgChannelSize, fieldNumber: 7)
    }
    if self.minChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.minChannelSize, fieldNumber: 8)
    }
    if self.maxChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxChannelSize, fieldNumber: 9)
    }
    if self.medianChannelSizeSat != 0 {
      try visitor.visitSingularInt64Field(value: self.medianChannelSizeSat, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NetworkInfo, rhs: Lnrpc_NetworkInfo) -> Bool {
    if lhs.graphDiameter != rhs.graphDiameter { return false }
    if lhs.avgOutDegree != rhs.avgOutDegree { return false }
    if lhs.maxOutDegree != rhs.maxOutDegree { return false }
    if lhs.numNodes != rhs.numNodes { return false }
    if lhs.numChannels != rhs.numChannels { return false }
    if lhs.totalNetworkCapacity != rhs.totalNetworkCapacity { return false }
    if lhs.avgChannelSize != rhs.avgChannelSize { return false }
    if lhs.minChannelSize != rhs.minChannelSize { return false }
    if lhs.maxChannelSize != rhs.maxChannelSize { return false }
    if lhs.medianChannelSizeSat != rhs.medianChannelSizeSat { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_StopRequest, rhs: Lnrpc_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_StopResponse, rhs: Lnrpc_StopResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GraphTopologySubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologySubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GraphTopologySubscription, rhs: Lnrpc_GraphTopologySubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_GraphTopologyUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologyUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_updates"),
    2: .standard(proto: "channel_updates"),
    3: .standard(proto: "closed_chans")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeUpdates)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.channelUpdates)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.closedChans)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeUpdates, fieldNumber: 1)
    }
    if !self.channelUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelUpdates, fieldNumber: 2)
    }
    if !self.closedChans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closedChans, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_GraphTopologyUpdate, rhs: Lnrpc_GraphTopologyUpdate) -> Bool {
    if lhs.nodeUpdates != rhs.nodeUpdates { return false }
    if lhs.channelUpdates != rhs.channelUpdates { return false }
    if lhs.closedChans != rhs.closedChans { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .standard(proto: "identity_key"),
    3: .standard(proto: "global_features"),
    4: .same(proto: "alias")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.addresses)
      case 2: try decoder.decodeSingularStringField(value: &self.identityKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.globalFeatures)
      case 4: try decoder.decodeSingularStringField(value: &self.alias)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKey, fieldNumber: 2)
    }
    if !self.globalFeatures.isEmpty {
      try visitor.visitSingularBytesField(value: self.globalFeatures, fieldNumber: 3)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_NodeUpdate, rhs: Lnrpc_NodeUpdate) -> Bool {
    if lhs.addresses != rhs.addresses { return false }
    if lhs.identityKey != rhs.identityKey { return false }
    if lhs.globalFeatures != rhs.globalFeatures { return false }
    if lhs.alias != rhs.alias { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelEdgeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdgeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "chan_point"),
    3: .same(proto: "capacity"),
    4: .standard(proto: "routing_policy"),
    5: .standard(proto: "advertising_node"),
    6: .standard(proto: "connecting_node")
  ]

  fileprivate class _StorageClass {
    var _chanID: UInt64 = 0
    var _chanPoint: Lnrpc_ChannelPoint?
    var _capacity: Int64 = 0
    var _routingPolicy: Lnrpc_RoutingPolicy?
    var _advertisingNode: String = String()
    var _connectingNode: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanID = source._chanID
      _chanPoint = source._chanPoint
      _capacity = source._capacity
      _routingPolicy = source._routingPolicy
      _advertisingNode = source._advertisingNode
      _connectingNode = source._connectingNode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._routingPolicy)
        case 5: try decoder.decodeSingularStringField(value: &_storage._advertisingNode)
        case 6: try decoder.decodeSingularStringField(value: &_storage._connectingNode)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 1)
      }
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 3)
      }
      if let v = _storage._routingPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._advertisingNode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._advertisingNode, fieldNumber: 5)
      }
      if !_storage._connectingNode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectingNode, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelEdgeUpdate, rhs: Lnrpc_ChannelEdgeUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chanID != rhs_storage._chanID { return false }
        if _storage._chanPoint != rhs_storage._chanPoint { return false }
        if _storage._capacity != rhs_storage._capacity { return false }
        if _storage._routingPolicy != rhs_storage._routingPolicy { return false }
        if _storage._advertisingNode != rhs_storage._advertisingNode { return false }
        if _storage._connectingNode != rhs_storage._connectingNode { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ClosedChannelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .same(proto: "capacity"),
    3: .standard(proto: "closed_height"),
    4: .standard(proto: "chan_point")
  ]

  fileprivate class _StorageClass {
    var _chanID: UInt64 = 0
    var _capacity: Int64 = 0
    var _closedHeight: UInt32 = 0
    var _chanPoint: Lnrpc_ChannelPoint?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanID = source._chanID
      _capacity = source._capacity
      _closedHeight = source._closedHeight
      _chanPoint = source._chanPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._closedHeight)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 1)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 2)
      }
      if _storage._closedHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._closedHeight, fieldNumber: 3)
      }
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ClosedChannelUpdate, rhs: Lnrpc_ClosedChannelUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chanID != rhs_storage._chanID { return false }
        if _storage._capacity != rhs_storage._capacity { return false }
        if _storage._closedHeight != rhs_storage._closedHeight { return false }
        if _storage._chanPoint != rhs_storage._chanPoint { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_HopHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HopHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node_id"),
    2: .same(proto: "chan_id"),
    3: .same(proto: "fee_base_msat"),
    4: .same(proto: "fee_proportional_millionths"),
    5: .same(proto: "cltv_expiry_delta")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nodeID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.feeBaseMsat)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.feeProportionalMillionths)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.cltvExpiryDelta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeProportionalMillionths != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeProportionalMillionths, fieldNumber: 4)
    }
    if self.cltvExpiryDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvExpiryDelta, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_HopHint, rhs: Lnrpc_HopHint) -> Bool {
    if lhs.nodeID != rhs.nodeID { return false }
    if lhs.chanID != rhs.chanID { return false }
    if lhs.feeBaseMsat != rhs.feeBaseMsat { return false }
    if lhs.feeProportionalMillionths != rhs.feeProportionalMillionths { return false }
    if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_RouteHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hop_hints")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.hopHints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hopHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hopHints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RouteHint, rhs: Lnrpc_RouteHint) -> Bool {
    if lhs.hopHints != rhs.hopHints { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Invoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invoice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memo"),
    2: .same(proto: "receipt"),
    3: .same(proto: "r_preimage"),
    4: .same(proto: "r_hash"),
    5: .same(proto: "value"),
    6: .same(proto: "settled"),
    7: .same(proto: "creation_date"),
    8: .same(proto: "settle_date"),
    9: .same(proto: "payment_request"),
    10: .same(proto: "description_hash"),
    11: .same(proto: "expiry"),
    12: .same(proto: "fallback_addr"),
    13: .same(proto: "cltv_expiry"),
    14: .same(proto: "route_hints"),
    15: .same(proto: "private"),
    16: .same(proto: "add_index"),
    17: .same(proto: "settle_index"),
    18: .same(proto: "amt_paid"),
    19: .same(proto: "amt_paid_sat"),
    20: .same(proto: "amt_paid_msat"),
    21: .same(proto: "state")
  ]

  fileprivate class _StorageClass {
    var _memo: String = String()
    var _receipt: Data = SwiftProtobuf.Internal.emptyData
    var _rPreimage: Data = SwiftProtobuf.Internal.emptyData
    var _rHash: Data = SwiftProtobuf.Internal.emptyData
    var _value: Int64 = 0
    var _settled: Bool = false
    var _creationDate: Int64 = 0
    var _settleDate: Int64 = 0
    var _paymentRequest: String = String()
    var _descriptionHash: Data = SwiftProtobuf.Internal.emptyData
    var _expiry: Int64 = 0
    var _fallbackAddr: String = String()
    var _cltvExpiry: UInt64 = 0
    var _routeHints: [Lnrpc_RouteHint] = []
    var _private: Bool = false
    var _addIndex: UInt64 = 0
    var _settleIndex: UInt64 = 0
    var _amtPaid: Int64 = 0
    var _amtPaidSat: Int64 = 0
    var _amtPaidMsat: Int64 = 0
    var _state: Lnrpc_Invoice.InvoiceState = .open

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _memo = source._memo
      _receipt = source._receipt
      _rPreimage = source._rPreimage
      _rHash = source._rHash
      _value = source._value
      _settled = source._settled
      _creationDate = source._creationDate
      _settleDate = source._settleDate
      _paymentRequest = source._paymentRequest
      _descriptionHash = source._descriptionHash
      _expiry = source._expiry
      _fallbackAddr = source._fallbackAddr
      _cltvExpiry = source._cltvExpiry
      _routeHints = source._routeHints
      _private = source._private
      _addIndex = source._addIndex
      _settleIndex = source._settleIndex
      _amtPaid = source._amtPaid
      _amtPaidSat = source._amtPaidSat
      _amtPaidMsat = source._amtPaidMsat
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._memo)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._receipt)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._rPreimage)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._rHash)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._value)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._settled)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._creationDate)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._settleDate)
        case 9: try decoder.decodeSingularStringField(value: &_storage._paymentRequest)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._descriptionHash)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._expiry)
        case 12: try decoder.decodeSingularStringField(value: &_storage._fallbackAddr)
        case 13: try decoder.decodeSingularUInt64Field(value: &_storage._cltvExpiry)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._routeHints)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._private)
        case 16: try decoder.decodeSingularUInt64Field(value: &_storage._addIndex)
        case 17: try decoder.decodeSingularUInt64Field(value: &_storage._settleIndex)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._amtPaid)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._amtPaidSat)
        case 20: try decoder.decodeSingularInt64Field(value: &_storage._amtPaidMsat)
        case 21: try decoder.decodeSingularEnumField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 1)
      }
      if !_storage._receipt.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._receipt, fieldNumber: 2)
      }
      if !_storage._rPreimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rPreimage, fieldNumber: 3)
      }
      if !_storage._rHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rHash, fieldNumber: 4)
      }
      if _storage._value != 0 {
        try visitor.visitSingularInt64Field(value: _storage._value, fieldNumber: 5)
      }
      if _storage._settled != false {
        try visitor.visitSingularBoolField(value: _storage._settled, fieldNumber: 6)
      }
      if _storage._creationDate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._creationDate, fieldNumber: 7)
      }
      if _storage._settleDate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._settleDate, fieldNumber: 8)
      }
      if !_storage._paymentRequest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentRequest, fieldNumber: 9)
      }
      if !_storage._descriptionHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._descriptionHash, fieldNumber: 10)
      }
      if _storage._expiry != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expiry, fieldNumber: 11)
      }
      if !_storage._fallbackAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fallbackAddr, fieldNumber: 12)
      }
      if _storage._cltvExpiry != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._cltvExpiry, fieldNumber: 13)
      }
      if !_storage._routeHints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routeHints, fieldNumber: 14)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 15)
      }
      if _storage._addIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._addIndex, fieldNumber: 16)
      }
      if _storage._settleIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._settleIndex, fieldNumber: 17)
      }
      if _storage._amtPaid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaid, fieldNumber: 18)
      }
      if _storage._amtPaidSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaidSat, fieldNumber: 19)
      }
      if _storage._amtPaidMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtPaidMsat, fieldNumber: 20)
      }
      if _storage._state != .open {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Invoice, rhs: Lnrpc_Invoice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._memo != rhs_storage._memo { return false }
        if _storage._receipt != rhs_storage._receipt { return false }
        if _storage._rPreimage != rhs_storage._rPreimage { return false }
        if _storage._rHash != rhs_storage._rHash { return false }
        if _storage._value != rhs_storage._value { return false }
        if _storage._settled != rhs_storage._settled { return false }
        if _storage._creationDate != rhs_storage._creationDate { return false }
        if _storage._settleDate != rhs_storage._settleDate { return false }
        if _storage._paymentRequest != rhs_storage._paymentRequest { return false }
        if _storage._descriptionHash != rhs_storage._descriptionHash { return false }
        if _storage._expiry != rhs_storage._expiry { return false }
        if _storage._fallbackAddr != rhs_storage._fallbackAddr { return false }
        if _storage._cltvExpiry != rhs_storage._cltvExpiry { return false }
        if _storage._routeHints != rhs_storage._routeHints { return false }
        if _storage._private != rhs_storage._private { return false }
        if _storage._addIndex != rhs_storage._addIndex { return false }
        if _storage._settleIndex != rhs_storage._settleIndex { return false }
        if _storage._amtPaid != rhs_storage._amtPaid { return false }
        if _storage._amtPaidSat != rhs_storage._amtPaidSat { return false }
        if _storage._amtPaidMsat != rhs_storage._amtPaidMsat { return false }
        if _storage._state != rhs_storage._state { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Invoice.InvoiceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "SETTLED"),
    2: .same(proto: "CANCELED"),
    3: .same(proto: "ACCEPTED")
  ]
}

extension Lnrpc_AddInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r_hash"),
    2: .same(proto: "payment_request"),
    16: .same(proto: "add_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rHash)
      case 2: try decoder.decodeSingularStringField(value: &self.paymentRequest)
      case 16: try decoder.decodeSingularUInt64Field(value: &self.addIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 1)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 2)
    }
    if self.addIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.addIndex, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AddInvoiceResponse, rhs: Lnrpc_AddInvoiceResponse) -> Bool {
    if lhs.rHash != rhs.rHash { return false }
    if lhs.paymentRequest != rhs.paymentRequest { return false }
    if lhs.addIndex != rhs.addIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PaymentHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r_hash_str"),
    2: .same(proto: "r_hash")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.rHashStr)
      case 2: try decoder.decodeSingularBytesField(value: &self.rHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHashStr.isEmpty {
      try visitor.visitSingularStringField(value: self.rHashStr, fieldNumber: 1)
    }
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PaymentHash, rhs: Lnrpc_PaymentHash) -> Bool {
    if lhs.rHashStr != rhs.rHashStr { return false }
    if lhs.rHash != rhs.rHash { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListInvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pending_only"),
    4: .same(proto: "index_offset"),
    5: .same(proto: "num_max_invoices"),
    6: .same(proto: "reversed")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.pendingOnly)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.indexOffset)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.numMaxInvoices)
      case 6: try decoder.decodeSingularBoolField(value: &self.reversed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pendingOnly != false {
      try visitor.visitSingularBoolField(value: self.pendingOnly, fieldNumber: 1)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.indexOffset, fieldNumber: 4)
    }
    if self.numMaxInvoices != 0 {
      try visitor.visitSingularUInt64Field(value: self.numMaxInvoices, fieldNumber: 5)
    }
    if self.reversed != false {
      try visitor.visitSingularBoolField(value: self.reversed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListInvoiceRequest, rhs: Lnrpc_ListInvoiceRequest) -> Bool {
    if lhs.pendingOnly != rhs.pendingOnly { return false }
    if lhs.indexOffset != rhs.indexOffset { return false }
    if lhs.numMaxInvoices != rhs.numMaxInvoices { return false }
    if lhs.reversed != rhs.reversed { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoices"),
    2: .same(proto: "last_index_offset"),
    3: .same(proto: "first_index_offset")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.invoices)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.lastIndexOffset)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.firstIndexOffset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invoices, fieldNumber: 1)
    }
    if self.lastIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastIndexOffset, fieldNumber: 2)
    }
    if self.firstIndexOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.firstIndexOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListInvoiceResponse, rhs: Lnrpc_ListInvoiceResponse) -> Bool {
    if lhs.invoices != rhs.invoices { return false }
    if lhs.lastIndexOffset != rhs.lastIndexOffset { return false }
    if lhs.firstIndexOffset != rhs.firstIndexOffset { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_InvoiceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceSubscription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "add_index"),
    2: .same(proto: "settle_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.addIndex)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.settleIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.addIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.addIndex, fieldNumber: 1)
    }
    if self.settleIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.settleIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_InvoiceSubscription, rhs: Lnrpc_InvoiceSubscription) -> Bool {
    if lhs.addIndex != rhs.addIndex { return false }
    if lhs.settleIndex != rhs.settleIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment_hash"),
    2: .same(proto: "value"),
    3: .same(proto: "creation_date"),
    4: .same(proto: "path"),
    5: .same(proto: "fee"),
    6: .same(proto: "payment_preimage"),
    7: .same(proto: "value_sat"),
    8: .same(proto: "value_msat")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.paymentHash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      case 3: try decoder.decodeSingularInt64Field(value: &self.creationDate)
      case 4: try decoder.decodeRepeatedStringField(value: &self.path)
      case 5: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 6: try decoder.decodeSingularStringField(value: &self.paymentPreimage)
      case 7: try decoder.decodeSingularInt64Field(value: &self.valueSat)
      case 8: try decoder.decodeSingularInt64Field(value: &self.valueMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if self.creationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.creationDate, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedStringField(value: self.path, fieldNumber: 4)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 5)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentPreimage, fieldNumber: 6)
    }
    if self.valueSat != 0 {
      try visitor.visitSingularInt64Field(value: self.valueSat, fieldNumber: 7)
    }
    if self.valueMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.valueMsat, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_Payment, rhs: Lnrpc_Payment) -> Bool {
    if lhs.paymentHash != rhs.paymentHash { return false }
    if lhs.value != rhs.value { return false }
    if lhs.creationDate != rhs.creationDate { return false }
    if lhs.path != rhs.path { return false }
    if lhs.fee != rhs.fee { return false }
    if lhs.paymentPreimage != rhs.paymentPreimage { return false }
    if lhs.valueSat != rhs.valueSat { return false }
    if lhs.valueMsat != rhs.valueMsat { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPaymentsRequest, rhs: Lnrpc_ListPaymentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ListPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.payments)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ListPaymentsResponse, rhs: Lnrpc_ListPaymentsResponse) -> Bool {
    if lhs.payments != rhs.payments { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteAllPaymentsRequest, rhs: Lnrpc_DeleteAllPaymentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DeleteAllPaymentsResponse, rhs: Lnrpc_DeleteAllPaymentsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_AbandonChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbandonChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point")
  ]

  fileprivate class _StorageClass {
    var _channelPoint: Lnrpc_ChannelPoint?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPoint = source._channelPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channelPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channelPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AbandonChannelRequest, rhs: Lnrpc_AbandonChannelRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelPoint != rhs_storage._channelPoint { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_AbandonChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbandonChannelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_AbandonChannelResponse, rhs: Lnrpc_AbandonChannelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DebugLevelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show"),
    2: .standard(proto: "level_spec")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.show)
      case 2: try decoder.decodeSingularStringField(value: &self.levelSpec)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.show != false {
      try visitor.visitSingularBoolField(value: self.show, fieldNumber: 1)
    }
    if !self.levelSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.levelSpec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DebugLevelRequest, rhs: Lnrpc_DebugLevelRequest) -> Bool {
    if lhs.show != rhs.show { return false }
    if lhs.levelSpec != rhs.levelSpec { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_DebugLevelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sub_systems")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subSystems)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subSystems.isEmpty {
      try visitor.visitSingularStringField(value: self.subSystems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_DebugLevelResponse, rhs: Lnrpc_DebugLevelResponse) -> Bool {
    if lhs.subSystems != rhs.subSystems { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PayReqString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReqString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pay_req")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.payReq)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payReq.isEmpty {
      try visitor.visitSingularStringField(value: self.payReq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PayReqString, rhs: Lnrpc_PayReqString) -> Bool {
    if lhs.payReq != rhs.payReq { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PayReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "payment_hash"),
    3: .same(proto: "num_satoshis"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "expiry"),
    6: .same(proto: "description"),
    7: .same(proto: "description_hash"),
    8: .same(proto: "fallback_addr"),
    9: .same(proto: "cltv_expiry"),
    10: .same(proto: "route_hints")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.destination)
      case 2: try decoder.decodeSingularStringField(value: &self.paymentHash)
      case 3: try decoder.decodeSingularInt64Field(value: &self.numSatoshis)
      case 4: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 5: try decoder.decodeSingularInt64Field(value: &self.expiry)
      case 6: try decoder.decodeSingularStringField(value: &self.description_p)
      case 7: try decoder.decodeSingularStringField(value: &self.descriptionHash)
      case 8: try decoder.decodeSingularStringField(value: &self.fallbackAddr)
      case 9: try decoder.decodeSingularInt64Field(value: &self.cltvExpiry)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.routeHints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 2)
    }
    if self.numSatoshis != 0 {
      try visitor.visitSingularInt64Field(value: self.numSatoshis, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.descriptionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptionHash, fieldNumber: 7)
    }
    if !self.fallbackAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackAddr, fieldNumber: 8)
    }
    if self.cltvExpiry != 0 {
      try visitor.visitSingularInt64Field(value: self.cltvExpiry, fieldNumber: 9)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PayReq, rhs: Lnrpc_PayReq) -> Bool {
    if lhs.destination != rhs.destination { return false }
    if lhs.paymentHash != rhs.paymentHash { return false }
    if lhs.numSatoshis != rhs.numSatoshis { return false }
    if lhs.timestamp != rhs.timestamp { return false }
    if lhs.expiry != rhs.expiry { return false }
    if lhs.description_p != rhs.description_p { return false }
    if lhs.descriptionHash != rhs.descriptionHash { return false }
    if lhs.fallbackAddr != rhs.fallbackAddr { return false }
    if lhs.cltvExpiry != rhs.cltvExpiry { return false }
    if lhs.routeHints != rhs.routeHints { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_FeeReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeReportRequest, rhs: Lnrpc_FeeReportRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelFeeReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelFeeReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chan_point", json: "channel_point"),
    2: .same(proto: "base_fee_msat"),
    3: .same(proto: "fee_per_mil"),
    4: .same(proto: "fee_rate")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chanPoint)
      case 2: try decoder.decodeSingularInt64Field(value: &self.baseFeeMsat)
      case 3: try decoder.decodeSingularInt64Field(value: &self.feePerMil)
      case 4: try decoder.decodeSingularDoubleField(value: &self.feeRate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.chanPoint, fieldNumber: 1)
    }
    if self.baseFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.baseFeeMsat, fieldNumber: 2)
    }
    if self.feePerMil != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerMil, fieldNumber: 3)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.feeRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelFeeReport, rhs: Lnrpc_ChannelFeeReport) -> Bool {
    if lhs.chanPoint != rhs.chanPoint { return false }
    if lhs.baseFeeMsat != rhs.baseFeeMsat { return false }
    if lhs.feePerMil != rhs.feePerMil { return false }
    if lhs.feeRate != rhs.feeRate { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_FeeReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_fees"),
    2: .same(proto: "day_fee_sum"),
    3: .same(proto: "week_fee_sum"),
    4: .same(proto: "month_fee_sum")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.channelFees)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.dayFeeSum)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.weekFeeSum)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.monthFeeSum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelFees, fieldNumber: 1)
    }
    if self.dayFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.dayFeeSum, fieldNumber: 2)
    }
    if self.weekFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.weekFeeSum, fieldNumber: 3)
    }
    if self.monthFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.monthFeeSum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_FeeReportResponse, rhs: Lnrpc_FeeReportResponse) -> Bool {
    if lhs.channelFees != rhs.channelFees { return false }
    if lhs.dayFeeSum != rhs.dayFeeSum { return false }
    if lhs.weekFeeSum != rhs.weekFeeSum { return false }
    if lhs.monthFeeSum != rhs.monthFeeSum { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PolicyUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "global"),
    2: .same(proto: "chan_point"),
    3: .same(proto: "base_fee_msat"),
    4: .same(proto: "fee_rate"),
    5: .same(proto: "time_lock_delta")
  ]

  fileprivate class _StorageClass {
    var _scope: Lnrpc_PolicyUpdateRequest.OneOf_Scope?
    var _baseFeeMsat: Int64 = 0
    var _feeRate: Double = 0
    var _timeLockDelta: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _baseFeeMsat = source._baseFeeMsat
      _feeRate = source._feeRate
      _timeLockDelta = source._timeLockDelta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._scope != nil { try decoder.handleConflictingOneOf() }
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v { _storage._scope = .global(v) }
        case 2:
          var v: Lnrpc_ChannelPoint?
          if let current = _storage._scope {
            try decoder.handleConflictingOneOf()
            if case .chanPoint(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._scope = .chanPoint(v) }
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._baseFeeMsat)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._feeRate)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._timeLockDelta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._scope {
      case .global(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      case .chanPoint(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if _storage._baseFeeMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._baseFeeMsat, fieldNumber: 3)
      }
      if _storage._feeRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._feeRate, fieldNumber: 4)
      }
      if _storage._timeLockDelta != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._timeLockDelta, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PolicyUpdateRequest, rhs: Lnrpc_PolicyUpdateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope { return false }
        if _storage._baseFeeMsat != rhs_storage._baseFeeMsat { return false }
        if _storage._feeRate != rhs_storage._feeRate { return false }
        if _storage._timeLockDelta != rhs_storage._timeLockDelta { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_PolicyUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_PolicyUpdateResponse, rhs: Lnrpc_PolicyUpdateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ForwardingHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start_time"),
    2: .same(proto: "end_time"),
    3: .same(proto: "index_offset"),
    4: .same(proto: "num_max_events")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startTime)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.endTime)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.indexOffset)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numMaxEvents)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 2)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexOffset, fieldNumber: 3)
    }
    if self.numMaxEvents != 0 {
      try visitor.visitSingularUInt32Field(value: self.numMaxEvents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingHistoryRequest, rhs: Lnrpc_ForwardingHistoryRequest) -> Bool {
    if lhs.startTime != rhs.startTime { return false }
    if lhs.endTime != rhs.endTime { return false }
    if lhs.indexOffset != rhs.indexOffset { return false }
    if lhs.numMaxEvents != rhs.numMaxEvents { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ForwardingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "chan_id_in"),
    4: .same(proto: "chan_id_out"),
    5: .same(proto: "amt_in"),
    6: .same(proto: "amt_out"),
    7: .same(proto: "fee"),
    8: .same(proto: "fee_msat")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.chanIDIn)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.chanIDOut)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.amtIn)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.amtOut)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.fee)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.feeMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.chanIDIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDIn, fieldNumber: 2)
    }
    if self.chanIDOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDOut, fieldNumber: 4)
    }
    if self.amtIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtIn, fieldNumber: 5)
    }
    if self.amtOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtOut, fieldNumber: 6)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 7)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeMsat, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingEvent, rhs: Lnrpc_ForwardingEvent) -> Bool {
    if lhs.timestamp != rhs.timestamp { return false }
    if lhs.chanIDIn != rhs.chanIDIn { return false }
    if lhs.chanIDOut != rhs.chanIDOut { return false }
    if lhs.amtIn != rhs.amtIn { return false }
    if lhs.amtOut != rhs.amtOut { return false }
    if lhs.fee != rhs.fee { return false }
    if lhs.feeMsat != rhs.feeMsat { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ForwardingHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forwarding_events"),
    2: .same(proto: "last_offset_index")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.forwardingEvents)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.lastOffsetIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forwardingEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwardingEvents, fieldNumber: 1)
    }
    if self.lastOffsetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastOffsetIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ForwardingHistoryResponse, rhs: Lnrpc_ForwardingHistoryResponse) -> Bool {
    if lhs.forwardingEvents != rhs.forwardingEvents { return false }
    if lhs.lastOffsetIndex != rhs.lastOffsetIndex { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ExportChannelBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExportChannelBackupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_point")
  ]

  fileprivate class _StorageClass {
    var _chanPoint: Lnrpc_ChannelPoint?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanPoint = source._chanPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ExportChannelBackupRequest, rhs: Lnrpc_ExportChannelBackupRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chanPoint != rhs_storage._chanPoint { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelBackup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_point"),
    2: .same(proto: "chan_backup")
  ]

  fileprivate class _StorageClass {
    var _chanPoint: Lnrpc_ChannelPoint?
    var _chanBackup: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanPoint = source._chanPoint
      _chanBackup = source._chanBackup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._chanBackup)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._chanBackup.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._chanBackup, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackup, rhs: Lnrpc_ChannelBackup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chanPoint != rhs_storage._chanPoint { return false }
        if _storage._chanBackup != rhs_storage._chanBackup { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_MultiChanBackup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiChanBackup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_points"),
    2: .same(proto: "multi_chan_backup")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.chanPoints)
      case 2: try decoder.decodeSingularBytesField(value: &self.multiChanBackup)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chanPoints, fieldNumber: 1)
    }
    if !self.multiChanBackup.isEmpty {
      try visitor.visitSingularBytesField(value: self.multiChanBackup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_MultiChanBackup, rhs: Lnrpc_MultiChanBackup) -> Bool {
    if lhs.chanPoints != rhs.chanPoints { return false }
    if lhs.multiChanBackup != rhs.multiChanBackup { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChanBackupExportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanBackupExportRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanBackupExportRequest, rhs: Lnrpc_ChanBackupExportRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChanBackupSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanBackupSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "single_chan_backups"),
    2: .same(proto: "multi_chan_backup")
  ]

  fileprivate class _StorageClass {
    var _singleChanBackups: Lnrpc_ChannelBackups?
    var _multiChanBackup: Lnrpc_MultiChanBackup?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _singleChanBackups = source._singleChanBackups
      _multiChanBackup = source._multiChanBackup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._singleChanBackups)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._multiChanBackup)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._singleChanBackups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._multiChanBackup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChanBackupSnapshot, rhs: Lnrpc_ChanBackupSnapshot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._singleChanBackups != rhs_storage._singleChanBackups { return false }
        if _storage._multiChanBackup != rhs_storage._multiChanBackup { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelBackups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_backups")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.chanBackups)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanBackups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chanBackups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackups, rhs: Lnrpc_ChannelBackups) -> Bool {
    if lhs.chanBackups != rhs.chanBackups { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_RestoreChanBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestoreChanBackupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_backups"),
    2: .same(proto: "multi_chan_backup")
  ]

  fileprivate class _StorageClass {
    var _backup: Lnrpc_RestoreChanBackupRequest.OneOf_Backup?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _backup = source._backup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_ChannelBackups?
          if let current = _storage._backup {
            try decoder.handleConflictingOneOf()
            if case .chanBackups(let m) = current { v = m }
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v { _storage._backup = .chanBackups(v) }
        case 2:
          if _storage._backup != nil { try decoder.handleConflictingOneOf() }
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v { _storage._backup = .multiChanBackup(v) }
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._backup {
      case .chanBackups(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .multiChanBackup(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RestoreChanBackupRequest, rhs: Lnrpc_RestoreChanBackupRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._backup != rhs_storage._backup { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_RestoreBackupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestoreBackupResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_RestoreBackupResponse, rhs: Lnrpc_RestoreBackupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_ChannelBackupSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBackupSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_ChannelBackupSubscription, rhs: Lnrpc_ChannelBackupSubscription) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension Lnrpc_VerifyChanBackupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyChanBackupResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lnrpc_VerifyChanBackupResponse, rhs: Lnrpc_VerifyChanBackupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}
