// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LndRpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "LndRpc.pbobjc.h"
//#import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - LNDLndRpcRoot

@implementation LNDLndRpcRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
//    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - LNDLndRpcRoot_FileDescriptor

static GPBFileDescriptor *LNDLndRpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"lnrpc"
                                                 objcPrefix:@"LND"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LNDGenSeedRequest

@implementation LNDGenSeedRequest

@dynamic aezeedPassphrase;
@dynamic seedEntropy;

typedef struct LNDGenSeedRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *aezeedPassphrase;
  NSData *seedEntropy;
} LNDGenSeedRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = LNDGenSeedRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDGenSeedRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "seedEntropy",
        .dataTypeSpecific.className = NULL,
        .number = LNDGenSeedRequest_FieldNumber_SeedEntropy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDGenSeedRequest__storage_, seedEntropy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGenSeedRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDGenSeedRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGenSeedResponse

@implementation LNDGenSeedResponse

@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic encipheredSeed;

typedef struct LNDGenSeedResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *encipheredSeed;
} LNDGenSeedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDGenSeedResponse_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGenSeedResponse__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encipheredSeed",
        .dataTypeSpecific.className = NULL,
        .number = LNDGenSeedResponse_FieldNumber_EncipheredSeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDGenSeedResponse__storage_, encipheredSeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGenSeedResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDGenSeedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDInitWalletRequest

@implementation LNDInitWalletRequest

@dynamic walletPassword;
@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic aezeedPassphrase;
@dynamic recoveryWindow;

typedef struct LNDInitWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t recoveryWindow;
  NSData *walletPassword;
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *aezeedPassphrase;
} LNDInitWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = LNDInitWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDInitWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDInitWalletRequest_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDInitWalletRequest__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = LNDInitWalletRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDInitWalletRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "recoveryWindow",
        .dataTypeSpecific.className = NULL,
        .number = LNDInitWalletRequest_FieldNumber_RecoveryWindow,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDInitWalletRequest__storage_, recoveryWindow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDInitWalletRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDInitWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDInitWalletResponse

@implementation LNDInitWalletResponse


typedef struct LNDInitWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDInitWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDInitWalletResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDInitWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDUnlockWalletRequest

@implementation LNDUnlockWalletRequest

@dynamic walletPassword;
@dynamic recoveryWindow;

typedef struct LNDUnlockWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t recoveryWindow;
  NSData *walletPassword;
} LNDUnlockWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = LNDUnlockWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDUnlockWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "recoveryWindow",
        .dataTypeSpecific.className = NULL,
        .number = LNDUnlockWalletRequest_FieldNumber_RecoveryWindow,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDUnlockWalletRequest__storage_, recoveryWindow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDUnlockWalletRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDUnlockWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDUnlockWalletResponse

@implementation LNDUnlockWalletResponse


typedef struct LNDUnlockWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDUnlockWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDUnlockWalletResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDUnlockWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChangePasswordRequest

@implementation LNDChangePasswordRequest

@dynamic currentPassword;
@dynamic newPassword;

typedef struct LNDChangePasswordRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *currentPassword;
  NSData *newPassword;
} LNDChangePasswordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentPassword",
        .dataTypeSpecific.className = NULL,
        .number = LNDChangePasswordRequest_FieldNumber_CurrentPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChangePasswordRequest__storage_, currentPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = LNDChangePasswordRequest_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChangePasswordRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChangePasswordRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChangePasswordRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChangePasswordResponse

@implementation LNDChangePasswordResponse


typedef struct LNDChangePasswordResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDChangePasswordResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChangePasswordResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDChangePasswordResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDTransaction

@implementation LNDTransaction

@dynamic txHash;
@dynamic amount;
@dynamic numConfirmations;
@dynamic blockHash;
@dynamic blockHeight;
@dynamic timeStamp;
@dynamic totalFees;
@dynamic destAddressesArray, destAddressesArray_Count;

typedef struct LNDTransaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t numConfirmations;
  int32_t blockHeight;
  NSString *txHash;
  NSString *blockHash;
  NSMutableArray *destAddressesArray;
  int64_t amount;
  int64_t timeStamp;
  int64_t totalFees;
} LNDTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numConfirmations",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_NumConfirmations,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, numConfirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_BlockHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_BlockHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_TimeStamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_TotalFees,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "destAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDTransaction_FieldNumber_DestAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDTransaction__storage_, destAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDTransaction class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDTransaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGetTransactionsRequest

@implementation LNDGetTransactionsRequest


typedef struct LNDGetTransactionsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDGetTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGetTransactionsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDGetTransactionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDTransactionDetails

@implementation LNDTransactionDetails

@dynamic transactionsArray, transactionsArray_Count;

typedef struct LNDTransactionDetails__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} LNDTransactionDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDTransaction),
        .number = LNDTransactionDetails_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDTransactionDetails__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDTransactionDetails class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDTransactionDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDFeeLimit

@implementation LNDFeeLimit

@dynamic limitOneOfCase;
@dynamic fixed;
@dynamic percent;

typedef struct LNDFeeLimit__storage_ {
  uint32_t _has_storage_[2];
  int64_t fixed;
  int64_t percent;
} LNDFeeLimit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fixed",
        .dataTypeSpecific.className = NULL,
        .number = LNDFeeLimit_FieldNumber_Fixed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDFeeLimit__storage_, fixed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "percent",
        .dataTypeSpecific.className = NULL,
        .number = LNDFeeLimit_FieldNumber_Percent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDFeeLimit__storage_, percent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDFeeLimit class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDFeeLimit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "limit",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LNDFeeLimit_ClearLimitOneOfCase(LNDFeeLimit *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LNDSendRequest

@implementation LNDSendRequest

@dynamic dest;
@dynamic destString;
@dynamic amt;
@dynamic paymentHash;
@dynamic paymentHashString;
@dynamic paymentRequest;
@dynamic finalCltvDelta;
@dynamic hasFeeLimit, feeLimit;

typedef struct LNDSendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t finalCltvDelta;
  NSData *dest;
  NSString *destString;
  NSData *paymentHash;
  NSString *paymentHashString;
  NSString *paymentRequest;
  LNDFeeLimit *feeLimit;
  int64_t amt;
} LNDSendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dest",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_Dest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, dest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "destString",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_DestString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, destString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_Amt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_PaymentHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentHashString",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_PaymentHashString,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, paymentHashString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_PaymentRequest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "finalCltvDelta",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendRequest_FieldNumber_FinalCltvDelta,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, finalCltvDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDFeeLimit),
        .number = LNDSendRequest_FieldNumber_FeeLimit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDSendRequest__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendResponse

@implementation LNDSendResponse

@dynamic paymentError;
@dynamic paymentPreimage;
@dynamic hasPaymentRoute, paymentRoute;

typedef struct LNDSendResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentError;
  NSData *paymentPreimage;
  LNDRoute *paymentRoute;
} LNDSendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentError",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendResponse_FieldNumber_PaymentError,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendResponse__storage_, paymentError),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendResponse_FieldNumber_PaymentPreimage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDSendResponse__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRoute",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoute),
        .number = LNDSendResponse_FieldNumber_PaymentRoute,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDSendResponse__storage_, paymentRoute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendToRouteRequest

@implementation LNDSendToRouteRequest

@dynamic paymentHash;
@dynamic paymentHashString;
@dynamic routesArray, routesArray_Count;

typedef struct LNDSendToRouteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *paymentHash;
  NSString *paymentHashString;
  NSMutableArray *routesArray;
} LNDSendToRouteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendToRouteRequest_FieldNumber_PaymentHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendToRouteRequest__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentHashString",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendToRouteRequest_FieldNumber_PaymentHashString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDSendToRouteRequest__storage_, paymentHashString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "routesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoute),
        .number = LNDSendToRouteRequest_FieldNumber_RoutesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDSendToRouteRequest__storage_, routesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendToRouteRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendToRouteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelPoint

@implementation LNDChannelPoint

@dynamic fundingTxidOneOfCase;
@dynamic fundingTxidBytes;
@dynamic fundingTxidStr;
@dynamic outputIndex;

typedef struct LNDChannelPoint__storage_ {
  uint32_t _has_storage_[2];
  uint32_t outputIndex;
  NSData *fundingTxidBytes;
  NSString *fundingTxidStr;
} LNDChannelPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fundingTxidBytes",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelPoint_FieldNumber_FundingTxidBytes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDChannelPoint__storage_, fundingTxidBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fundingTxidStr",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelPoint_FieldNumber_FundingTxidStr,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDChannelPoint__storage_, fundingTxidStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelPoint_FieldNumber_OutputIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelPoint__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelPoint class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "fundingTxid",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LNDChannelPoint_ClearFundingTxidOneOfCase(LNDChannelPoint *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LNDLightningAddress

@implementation LNDLightningAddress

@dynamic pubkey;
@dynamic host;

typedef struct LNDLightningAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
  NSString *host;
} LNDLightningAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningAddress_FieldNumber_Pubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDLightningAddress__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningAddress_FieldNumber_Host,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDLightningAddress__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDLightningAddress class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDLightningAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendManyRequest

@implementation LNDSendManyRequest

@dynamic addrToAmount, addrToAmount_Count;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct LNDSendManyRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  GPBStringInt64Dictionary *addrToAmount;
  int64_t satPerByte;
} LNDSendManyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrToAmount",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendManyRequest_FieldNumber_AddrToAmount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDSendManyRequest__storage_, addrToAmount),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendManyRequest_FieldNumber_TargetConf,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendManyRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendManyRequest_FieldNumber_SatPerByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDSendManyRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendManyRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendManyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendManyResponse

@implementation LNDSendManyResponse

@dynamic txid;

typedef struct LNDSendManyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} LNDSendManyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendManyResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendManyResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendManyResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendManyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendCoinsRequest

@implementation LNDSendCoinsRequest

@dynamic addr;
@dynamic amount;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct LNDSendCoinsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  NSString *addr;
  int64_t amount;
  int64_t satPerByte;
} LNDSendCoinsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendCoinsRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendCoinsRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendCoinsRequest_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDSendCoinsRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendCoinsRequest_FieldNumber_TargetConf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDSendCoinsRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendCoinsRequest_FieldNumber_SatPerByte,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDSendCoinsRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendCoinsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendCoinsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSendCoinsResponse

@implementation LNDSendCoinsResponse

@dynamic txid;

typedef struct LNDSendCoinsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} LNDSendCoinsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = LNDSendCoinsResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSendCoinsResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSendCoinsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSendCoinsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNewAddressRequest

@implementation LNDNewAddressRequest

@dynamic type;

typedef struct LNDNewAddressRequest__storage_ {
  uint32_t _has_storage_[1];
  LNDNewAddressRequest_AddressType type;
} LNDNewAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = LNDNewAddressRequest_AddressType_EnumDescriptor,
        .number = LNDNewAddressRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNewAddressRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNewAddressRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNewAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LNDNewAddressRequest_Type_RawValue(LNDNewAddressRequest *message) {
  GPBDescriptor *descriptor = [LNDNewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LNDNewAddressRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetLNDNewAddressRequest_Type_RawValue(LNDNewAddressRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [LNDNewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LNDNewAddressRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum LNDNewAddressRequest_AddressType

GPBEnumDescriptor *LNDNewAddressRequest_AddressType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WitnessPubkeyHash\000NestedPubkeyHash\000";
    static const int32_t values[] = {
        LNDNewAddressRequest_AddressType_WitnessPubkeyHash,
        LNDNewAddressRequest_AddressType_NestedPubkeyHash,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LNDNewAddressRequest_AddressType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LNDNewAddressRequest_AddressType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LNDNewAddressRequest_AddressType_IsValidValue(int32_t value__) {
  switch (value__) {
    case LNDNewAddressRequest_AddressType_WitnessPubkeyHash:
    case LNDNewAddressRequest_AddressType_NestedPubkeyHash:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LNDNewAddressResponse

@implementation LNDNewAddressResponse

@dynamic address;

typedef struct LNDNewAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} LNDNewAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = LNDNewAddressResponse_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNewAddressResponse__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNewAddressResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNewAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSignMessageRequest

@implementation LNDSignMessageRequest

@dynamic msg;

typedef struct LNDSignMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
} LNDSignMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = LNDSignMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSignMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSignMessageRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSignMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDSignMessageResponse

@implementation LNDSignMessageResponse

@dynamic signature;

typedef struct LNDSignMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *signature;
} LNDSignMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = LNDSignMessageResponse_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDSignMessageResponse__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDSignMessageResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDSignMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDVerifyMessageRequest

@implementation LNDVerifyMessageRequest

@dynamic msg;
@dynamic signature;

typedef struct LNDVerifyMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
  NSString *signature;
} LNDVerifyMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = LNDVerifyMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDVerifyMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = LNDVerifyMessageRequest_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDVerifyMessageRequest__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDVerifyMessageRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDVerifyMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDVerifyMessageResponse

@implementation LNDVerifyMessageResponse

@dynamic valid;
@dynamic pubkey;

typedef struct LNDVerifyMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
} LNDVerifyMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valid",
        .dataTypeSpecific.className = NULL,
        .number = LNDVerifyMessageResponse_FieldNumber_Valid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDVerifyMessageResponse_FieldNumber_Pubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDVerifyMessageResponse__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDVerifyMessageResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDVerifyMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDConnectPeerRequest

@implementation LNDConnectPeerRequest

@dynamic hasAddr, addr;
@dynamic perm;

typedef struct LNDConnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  LNDLightningAddress *addr;
} LNDConnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDLightningAddress),
        .number = LNDConnectPeerRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDConnectPeerRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "perm",
        .dataTypeSpecific.className = NULL,
        .number = LNDConnectPeerRequest_FieldNumber_Perm,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDConnectPeerRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDConnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDConnectPeerResponse

@implementation LNDConnectPeerResponse


typedef struct LNDConnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDConnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDConnectPeerResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDConnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDisconnectPeerRequest

@implementation LNDDisconnectPeerRequest

@dynamic pubKey;

typedef struct LNDDisconnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} LNDDisconnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDDisconnectPeerRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDDisconnectPeerRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDisconnectPeerRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDDisconnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDisconnectPeerResponse

@implementation LNDDisconnectPeerResponse


typedef struct LNDDisconnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDDisconnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDisconnectPeerResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDDisconnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDHTLC

@implementation LNDHTLC

@dynamic incoming;
@dynamic amount;
@dynamic hashLock;
@dynamic expirationHeight;

typedef struct LNDHTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expirationHeight;
  NSData *hashLock;
  int64_t amount;
} LNDHTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = LNDHTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LNDHTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDHTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashLock",
        .dataTypeSpecific.className = NULL,
        .number = LNDHTLC_FieldNumber_HashLock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDHTLC__storage_, hashLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expirationHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDHTLC_FieldNumber_ExpirationHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDHTLC__storage_, expirationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDHTLC class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDHTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannel

@implementation LNDChannel

@dynamic active;
@dynamic remotePubkey;
@dynamic channelPoint;
@dynamic chanId;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;
@dynamic unsettledBalance;
@dynamic totalSatoshisSent;
@dynamic totalSatoshisReceived;
@dynamic numUpdates;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;
@dynamic csvDelay;
@dynamic private_p;

typedef struct LNDChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t csvDelay;
  NSString *remotePubkey;
  NSString *channelPoint;
  NSMutableArray *pendingHtlcsArray;
  uint64_t chanId;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
  int64_t unsettledBalance;
  int64_t totalSatoshisSent;
  int64_t totalSatoshisReceived;
  uint64_t numUpdates;
} LNDChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "active",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_Active,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remotePubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_RemotePubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, remotePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_ChannelPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_ChanId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_LocalBalance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_RemoteBalance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_CommitFee,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_CommitWeight,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_FeePerKw,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unsettledBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_UnsettledBalance,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, unsettledBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisSent",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_TotalSatoshisSent,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, totalSatoshisSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisReceived",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_TotalSatoshisReceived,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, totalSatoshisReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numUpdates",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_NumUpdates,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, numUpdates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDHTLC),
        .number = LNDChannel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "csvDelay",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_CsvDelay,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(LNDChannel__storage_, csvDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannel_FieldNumber_Private_p,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListChannelsRequest

@implementation LNDListChannelsRequest

@dynamic activeOnly;
@dynamic inactiveOnly;
@dynamic publicOnly;
@dynamic privateOnly;

typedef struct LNDListChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDListChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activeOnly",
        .dataTypeSpecific.className = NULL,
        .number = LNDListChannelsRequest_FieldNumber_ActiveOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inactiveOnly",
        .dataTypeSpecific.className = NULL,
        .number = LNDListChannelsRequest_FieldNumber_InactiveOnly,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "publicOnly",
        .dataTypeSpecific.className = NULL,
        .number = LNDListChannelsRequest_FieldNumber_PublicOnly,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "privateOnly",
        .dataTypeSpecific.className = NULL,
        .number = LNDListChannelsRequest_FieldNumber_PrivateOnly,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListChannelsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListChannelsResponse

@implementation LNDListChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct LNDListChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} LNDListChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannel),
        .number = LNDListChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDListChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListChannelsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelCloseSummary

@implementation LNDChannelCloseSummary

@dynamic channelPoint;
@dynamic chanId;
@dynamic chainHash;
@dynamic closingTxHash;
@dynamic remotePubkey;
@dynamic capacity;
@dynamic closeHeight;
@dynamic settledBalance;
@dynamic timeLockedBalance;
@dynamic closeType;

typedef struct LNDChannelCloseSummary__storage_ {
  uint32_t _has_storage_[1];
  uint32_t closeHeight;
  LNDChannelCloseSummary_ClosureType closeType;
  NSString *channelPoint;
  NSString *chainHash;
  NSString *closingTxHash;
  NSString *remotePubkey;
  uint64_t chanId;
  int64_t capacity;
  int64_t settledBalance;
  int64_t timeLockedBalance;
} LNDChannelCloseSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_ChanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chainHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_ChainHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, chainHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "closingTxHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_ClosingTxHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, closingTxHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remotePubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_RemotePubkey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, remotePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closeHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_CloseHeight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, closeHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "settledBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_SettledBalance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, settledBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeLockedBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseSummary_FieldNumber_TimeLockedBalance,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, timeLockedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closeType",
        .dataTypeSpecific.enumDescFunc = LNDChannelCloseSummary_ClosureType_EnumDescriptor,
        .number = LNDChannelCloseSummary_FieldNumber_CloseType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LNDChannelCloseSummary__storage_, closeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelCloseSummary class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelCloseSummary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LNDChannelCloseSummary_CloseType_RawValue(LNDChannelCloseSummary *message) {
  GPBDescriptor *descriptor = [LNDChannelCloseSummary descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LNDChannelCloseSummary_FieldNumber_CloseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetLNDChannelCloseSummary_CloseType_RawValue(LNDChannelCloseSummary *message, int32_t value) {
  GPBDescriptor *descriptor = [LNDChannelCloseSummary descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LNDChannelCloseSummary_FieldNumber_CloseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum LNDChannelCloseSummary_ClosureType

GPBEnumDescriptor *LNDChannelCloseSummary_ClosureType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CooperativeClose\000LocalForceClose\000RemoteF"
        "orceClose\000BreachClose\000FundingCanceled\000Ab"
        "andoned\000";
    static const int32_t values[] = {
        LNDChannelCloseSummary_ClosureType_CooperativeClose,
        LNDChannelCloseSummary_ClosureType_LocalForceClose,
        LNDChannelCloseSummary_ClosureType_RemoteForceClose,
        LNDChannelCloseSummary_ClosureType_BreachClose,
        LNDChannelCloseSummary_ClosureType_FundingCanceled,
        LNDChannelCloseSummary_ClosureType_Abandoned,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LNDChannelCloseSummary_ClosureType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LNDChannelCloseSummary_ClosureType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LNDChannelCloseSummary_ClosureType_IsValidValue(int32_t value__) {
  switch (value__) {
    case LNDChannelCloseSummary_ClosureType_CooperativeClose:
    case LNDChannelCloseSummary_ClosureType_LocalForceClose:
    case LNDChannelCloseSummary_ClosureType_RemoteForceClose:
    case LNDChannelCloseSummary_ClosureType_BreachClose:
    case LNDChannelCloseSummary_ClosureType_FundingCanceled:
    case LNDChannelCloseSummary_ClosureType_Abandoned:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LNDClosedChannelsRequest

@implementation LNDClosedChannelsRequest

@dynamic cooperative;
@dynamic localForce;
@dynamic remoteForce;
@dynamic breach;
@dynamic fundingCanceled;
@dynamic abandoned;

typedef struct LNDClosedChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDClosedChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cooperative",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_Cooperative,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "localForce",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_LocalForce,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remoteForce",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_RemoteForce,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "breach",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_Breach,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fundingCanceled",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_FundingCanceled,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "abandoned",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelsRequest_FieldNumber_Abandoned,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDClosedChannelsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDClosedChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDClosedChannelsResponse

@implementation LNDClosedChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct LNDClosedChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} LNDClosedChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelCloseSummary),
        .number = LNDClosedChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDClosedChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDClosedChannelsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDClosedChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPeer

@implementation LNDPeer

@dynamic pubKey;
@dynamic address;
@dynamic bytesSent;
@dynamic bytesRecv;
@dynamic satSent;
@dynamic satRecv;
@dynamic inbound;
@dynamic pingTime;

typedef struct LNDPeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *address;
  uint64_t bytesSent;
  uint64_t bytesRecv;
  int64_t satSent;
  int64_t satRecv;
  int64_t pingTime;
} LNDPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bytesSent",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_BytesSent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, bytesSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "bytesRecv",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_BytesRecv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, bytesRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "satSent",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_SatSent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, satSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "satRecv",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_SatRecv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, satRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inbound",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_Inbound,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pingTime",
        .dataTypeSpecific.className = NULL,
        .number = LNDPeer_FieldNumber_PingTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDPeer__storage_, pingTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPeer class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPeer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListPeersRequest

@implementation LNDListPeersRequest


typedef struct LNDListPeersRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDListPeersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListPeersRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDListPeersRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListPeersResponse

@implementation LNDListPeersResponse

@dynamic peersArray, peersArray_Count;

typedef struct LNDListPeersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} LNDListPeersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPeer),
        .number = LNDListPeersResponse_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDListPeersResponse__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListPeersResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListPeersResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGetInfoRequest

@implementation LNDGetInfoRequest


typedef struct LNDGetInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDGetInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGetInfoRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDGetInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGetInfoResponse

@implementation LNDGetInfoResponse

@dynamic identityPubkey;
@dynamic alias;
@dynamic numPendingChannels;
@dynamic numActiveChannels;
@dynamic numPeers;
@dynamic blockHeight;
@dynamic blockHash;
@dynamic syncedToChain;
@dynamic testnet;
@dynamic chainsArray, chainsArray_Count;
@dynamic urisArray, urisArray_Count;
@dynamic bestHeaderTimestamp;
@dynamic version;
@dynamic numInactiveChannels;

typedef struct LNDGetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numPendingChannels;
  uint32_t numActiveChannels;
  uint32_t numPeers;
  uint32_t blockHeight;
  uint32_t numInactiveChannels;
  NSString *identityPubkey;
  NSString *alias;
  NSString *blockHash;
  NSMutableArray *chainsArray;
  NSMutableArray *urisArray;
  NSString *version;
  int64_t bestHeaderTimestamp;
} LNDGetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityPubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_IdentityPubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, identityPubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_Alias,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numPendingChannels",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_NumPendingChannels,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, numPendingChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numActiveChannels",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_NumActiveChannels,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, numActiveChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numPeers",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_NumPeers,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, numPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_BlockHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncedToChain",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_SyncedToChain,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "testnet",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_Testnet,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chainsArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_ChainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, chainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "urisArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_UrisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, urisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bestHeaderTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_BestHeaderTimestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, bestHeaderTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_Version,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numInactiveChannels",
        .dataTypeSpecific.className = NULL,
        .number = LNDGetInfoResponse_FieldNumber_NumInactiveChannels,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LNDGetInfoResponse__storage_, numInactiveChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGetInfoResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDGetInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDConfirmationUpdate

@implementation LNDConfirmationUpdate

@dynamic blockSha;
@dynamic blockHeight;
@dynamic numConfsLeft;

typedef struct LNDConfirmationUpdate__storage_ {
  uint32_t _has_storage_[1];
  int32_t blockHeight;
  uint32_t numConfsLeft;
  NSData *blockSha;
} LNDConfirmationUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockSha",
        .dataTypeSpecific.className = NULL,
        .number = LNDConfirmationUpdate_FieldNumber_BlockSha,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDConfirmationUpdate__storage_, blockSha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDConfirmationUpdate_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDConfirmationUpdate__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numConfsLeft",
        .dataTypeSpecific.className = NULL,
        .number = LNDConfirmationUpdate_FieldNumber_NumConfsLeft,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDConfirmationUpdate__storage_, numConfsLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDConfirmationUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDConfirmationUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelOpenUpdate

@implementation LNDChannelOpenUpdate

@dynamic hasChannelPoint, channelPoint;

typedef struct LNDChannelOpenUpdate__storage_ {
  uint32_t _has_storage_[1];
  LNDChannelPoint *channelPoint;
} LNDChannelOpenUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDChannelOpenUpdate_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelOpenUpdate__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelOpenUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelOpenUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelCloseUpdate

@implementation LNDChannelCloseUpdate

@dynamic closingTxid;
@dynamic success;

typedef struct LNDChannelCloseUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSData *closingTxid;
} LNDChannelCloseUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseUpdate_FieldNumber_ClosingTxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelCloseUpdate__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelCloseUpdate_FieldNumber_Success,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelCloseUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelCloseUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDCloseChannelRequest

@implementation LNDCloseChannelRequest

@dynamic hasChannelPoint, channelPoint;
@dynamic force;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct LNDCloseChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  LNDChannelPoint *channelPoint;
  int64_t satPerByte;
} LNDCloseChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDCloseChannelRequest_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDCloseChannelRequest__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = LNDCloseChannelRequest_FieldNumber_Force,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = LNDCloseChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDCloseChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = LNDCloseChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDCloseChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDCloseChannelRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDCloseChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDCloseStatusUpdate

@implementation LNDCloseStatusUpdate

@dynamic updateOneOfCase;
@dynamic closePending;
@dynamic confirmation;
@dynamic chanClose;

typedef struct LNDCloseStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  LNDPendingUpdate *closePending;
  LNDConfirmationUpdate *confirmation;
  LNDChannelCloseUpdate *chanClose;
} LNDCloseStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closePending",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingUpdate),
        .number = LNDCloseStatusUpdate_FieldNumber_ClosePending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDCloseStatusUpdate__storage_, closePending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmation",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDConfirmationUpdate),
        .number = LNDCloseStatusUpdate_FieldNumber_Confirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDCloseStatusUpdate__storage_, confirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanClose",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelCloseUpdate),
        .number = LNDCloseStatusUpdate_FieldNumber_ChanClose,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDCloseStatusUpdate__storage_, chanClose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDCloseStatusUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDCloseStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LNDCloseStatusUpdate_ClearUpdateOneOfCase(LNDCloseStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LNDPendingUpdate

@implementation LNDPendingUpdate

@dynamic txid;
@dynamic outputIndex;

typedef struct LNDPendingUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t outputIndex;
  NSData *txid;
} LNDPendingUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingUpdate_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingUpdate__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingUpdate_FieldNumber_OutputIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingUpdate__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDOpenChannelRequest

@implementation LNDOpenChannelRequest

@dynamic nodePubkey;
@dynamic nodePubkeyString;
@dynamic localFundingAmount;
@dynamic pushSat;
@dynamic targetConf;
@dynamic satPerByte;
@dynamic private_p;
@dynamic minHtlcMsat;
@dynamic remoteCsvDelay;
@dynamic minConfs;
@dynamic spendUnconfirmed;

typedef struct LNDOpenChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  uint32_t remoteCsvDelay;
  int32_t minConfs;
  NSData *nodePubkey;
  NSString *nodePubkeyString;
  int64_t localFundingAmount;
  int64_t pushSat;
  int64_t satPerByte;
  int64_t minHtlcMsat;
} LNDOpenChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodePubkey",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_NodePubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, nodePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nodePubkeyString",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_NodePubkeyString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, nodePubkeyString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "localFundingAmount",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_LocalFundingAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, localFundingAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pushSat",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_PushSat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, pushSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_Private_p,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minHtlcMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_MinHtlcMsat,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, minHtlcMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteCsvDelay",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_RemoteCsvDelay,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, remoteCsvDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minConfs",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_MinConfs,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LNDOpenChannelRequest__storage_, minConfs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "spendUnconfirmed",
        .dataTypeSpecific.className = NULL,
        .number = LNDOpenChannelRequest_FieldNumber_SpendUnconfirmed,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDOpenChannelRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDOpenChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDOpenStatusUpdate

@implementation LNDOpenStatusUpdate

@dynamic updateOneOfCase;
@dynamic chanPending;
@dynamic confirmation;
@dynamic chanOpen;

typedef struct LNDOpenStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  LNDPendingUpdate *chanPending;
  LNDConfirmationUpdate *confirmation;
  LNDChannelOpenUpdate *chanOpen;
} LNDOpenStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPending",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingUpdate),
        .number = LNDOpenStatusUpdate_FieldNumber_ChanPending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDOpenStatusUpdate__storage_, chanPending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmation",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDConfirmationUpdate),
        .number = LNDOpenStatusUpdate_FieldNumber_Confirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDOpenStatusUpdate__storage_, confirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanOpen",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelOpenUpdate),
        .number = LNDOpenStatusUpdate_FieldNumber_ChanOpen,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDOpenStatusUpdate__storage_, chanOpen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDOpenStatusUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDOpenStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LNDOpenStatusUpdate_ClearUpdateOneOfCase(LNDOpenStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LNDPendingHTLC

@implementation LNDPendingHTLC

@dynamic incoming;
@dynamic amount;
@dynamic outpoint;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic stage;

typedef struct LNDPendingHTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  uint32_t stage;
  NSString *outpoint;
  int64_t amount;
} LNDPendingHTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPendingHTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_Outpoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPendingHTLC__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_MaturityHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPendingHTLC__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_BlocksTilMaturity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDPendingHTLC__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stage",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingHTLC_FieldNumber_Stage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDPendingHTLC__storage_, stage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingHTLC class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingHTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsRequest

@implementation LNDPendingChannelsRequest


typedef struct LNDPendingChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDPendingChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDPendingChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse

@implementation LNDPendingChannelsResponse

@dynamic totalLimboBalance;
@dynamic pendingOpenChannelsArray, pendingOpenChannelsArray_Count;
@dynamic pendingClosingChannelsArray, pendingClosingChannelsArray_Count;
@dynamic pendingForceClosingChannelsArray, pendingForceClosingChannelsArray_Count;
@dynamic waitingCloseChannelsArray, waitingCloseChannelsArray_Count;

typedef struct LNDPendingChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pendingOpenChannelsArray;
  NSMutableArray *pendingClosingChannelsArray;
  NSMutableArray *pendingForceClosingChannelsArray;
  NSMutableArray *waitingCloseChannelsArray;
  int64_t totalLimboBalance;
} LNDPendingChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalLimboBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_FieldNumber_TotalLimboBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse__storage_, totalLimboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingOpenChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_PendingOpenChannel),
        .number = LNDPendingChannelsResponse_FieldNumber_PendingOpenChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse__storage_, pendingOpenChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_ClosedChannel),
        .number = LNDPendingChannelsResponse_FieldNumber_PendingClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse__storage_, pendingClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingForceClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_ForceClosedChannel),
        .number = LNDPendingChannelsResponse_FieldNumber_PendingForceClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse__storage_, pendingForceClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "waitingCloseChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_WaitingCloseChannel),
        .number = LNDPendingChannelsResponse_FieldNumber_WaitingCloseChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse__storage_, waitingCloseChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse_PendingChannel

@implementation LNDPendingChannelsResponse_PendingChannel

@dynamic remoteNodePub;
@dynamic channelPoint;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;

typedef struct LNDPendingChannelsResponse_PendingChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *remoteNodePub;
  NSString *channelPoint;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
} LNDPendingChannelsResponse_PendingChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remoteNodePub",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingChannel_FieldNumber_RemoteNodePub,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingChannel__storage_, remoteNodePub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingChannel_FieldNumber_ChannelPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingChannel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingChannel_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingChannel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingChannel_FieldNumber_LocalBalance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingChannel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingChannel_FieldNumber_RemoteBalance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingChannel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse_PendingChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse_PendingChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(LNDPendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse_PendingOpenChannel

@implementation LNDPendingChannelsResponse_PendingOpenChannel

@dynamic hasChannel, channel;
@dynamic confirmationHeight;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;

typedef struct LNDPendingChannelsResponse_PendingOpenChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t confirmationHeight;
  LNDPendingChannelsResponse_PendingChannel *channel;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
} LNDPendingChannelsResponse_PendingOpenChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_PendingChannel),
        .number = LNDPendingChannelsResponse_PendingOpenChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingOpenChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmationHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingOpenChannel_FieldNumber_ConfirmationHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingOpenChannel__storage_, confirmationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingOpenChannel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitWeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingOpenChannel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_PendingOpenChannel_FieldNumber_FeePerKw,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_PendingOpenChannel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse_PendingOpenChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse_PendingOpenChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(LNDPendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse_WaitingCloseChannel

@implementation LNDPendingChannelsResponse_WaitingCloseChannel

@dynamic hasChannel, channel;
@dynamic limboBalance;

typedef struct LNDPendingChannelsResponse_WaitingCloseChannel__storage_ {
  uint32_t _has_storage_[1];
  LNDPendingChannelsResponse_PendingChannel *channel;
  int64_t limboBalance;
} LNDPendingChannelsResponse_WaitingCloseChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_PendingChannel),
        .number = LNDPendingChannelsResponse_WaitingCloseChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_WaitingCloseChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limboBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_WaitingCloseChannel_FieldNumber_LimboBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_WaitingCloseChannel__storage_, limboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse_WaitingCloseChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse_WaitingCloseChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(LNDPendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse_ClosedChannel

@implementation LNDPendingChannelsResponse_ClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;

typedef struct LNDPendingChannelsResponse_ClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  LNDPendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
} LNDPendingChannelsResponse_ClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_PendingChannel),
        .number = LNDPendingChannelsResponse_ClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse_ClosedChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse_ClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(LNDPendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPendingChannelsResponse_ForceClosedChannel

@implementation LNDPendingChannelsResponse_ForceClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;
@dynamic limboBalance;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic recoveredBalance;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;

typedef struct LNDPendingChannelsResponse_ForceClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  LNDPendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
  NSMutableArray *pendingHtlcsArray;
  int64_t limboBalance;
  int64_t recoveredBalance;
} LNDPendingChannelsResponse_ForceClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingChannelsResponse_PendingChannel),
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limboBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_LimboBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, limboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_MaturityHeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_BlocksTilMaturity,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recoveredBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_RecoveredBalance,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, recoveredBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPendingHTLC),
        .number = LNDPendingChannelsResponse_ForceClosedChannel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPendingChannelsResponse_ForceClosedChannel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPendingChannelsResponse_ForceClosedChannel class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPendingChannelsResponse_ForceClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(LNDPendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDWalletBalanceRequest

@implementation LNDWalletBalanceRequest


typedef struct LNDWalletBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDWalletBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDWalletBalanceRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDWalletBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDWalletBalanceResponse

@implementation LNDWalletBalanceResponse

@dynamic totalBalance;
@dynamic confirmedBalance;
@dynamic unconfirmedBalance;

typedef struct LNDWalletBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalBalance;
  int64_t confirmedBalance;
  int64_t unconfirmedBalance;
} LNDWalletBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDWalletBalanceResponse_FieldNumber_TotalBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDWalletBalanceResponse__storage_, totalBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "confirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDWalletBalanceResponse_FieldNumber_ConfirmedBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDWalletBalanceResponse__storage_, confirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unconfirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDWalletBalanceResponse_FieldNumber_UnconfirmedBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDWalletBalanceResponse__storage_, unconfirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDWalletBalanceResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDWalletBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelBalanceRequest

@implementation LNDChannelBalanceRequest


typedef struct LNDChannelBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDChannelBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelBalanceRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDChannelBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelBalanceResponse

@implementation LNDChannelBalanceResponse

@dynamic balance;
@dynamic pendingOpenBalance;

typedef struct LNDChannelBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t balance;
  int64_t pendingOpenBalance;
} LNDChannelBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelBalanceResponse_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelBalanceResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingOpenBalance",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelBalanceResponse_FieldNumber_PendingOpenBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChannelBalanceResponse__storage_, pendingOpenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelBalanceResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDQueryRoutesRequest

@implementation LNDQueryRoutesRequest

@dynamic pubKey;
@dynamic amt;
@dynamic numRoutes;
@dynamic finalCltvDelta;
@dynamic hasFeeLimit, feeLimit;

typedef struct LNDQueryRoutesRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t numRoutes;
  int32_t finalCltvDelta;
  NSString *pubKey;
  LNDFeeLimit *feeLimit;
  int64_t amt;
} LNDQueryRoutesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDQueryRoutesRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDQueryRoutesRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = LNDQueryRoutesRequest_FieldNumber_Amt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDQueryRoutesRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numRoutes",
        .dataTypeSpecific.className = NULL,
        .number = LNDQueryRoutesRequest_FieldNumber_NumRoutes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDQueryRoutesRequest__storage_, numRoutes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "finalCltvDelta",
        .dataTypeSpecific.className = NULL,
        .number = LNDQueryRoutesRequest_FieldNumber_FinalCltvDelta,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDQueryRoutesRequest__storage_, finalCltvDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDFeeLimit),
        .number = LNDQueryRoutesRequest_FieldNumber_FeeLimit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDQueryRoutesRequest__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDQueryRoutesRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDQueryRoutesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDQueryRoutesResponse

@implementation LNDQueryRoutesResponse

@dynamic routesArray, routesArray_Count;

typedef struct LNDQueryRoutesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *routesArray;
} LNDQueryRoutesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoute),
        .number = LNDQueryRoutesResponse_FieldNumber_RoutesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDQueryRoutesResponse__storage_, routesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDQueryRoutesResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDQueryRoutesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDHop

@implementation LNDHop

@dynamic chanId;
@dynamic chanCapacity;
@dynamic amtToForward;
@dynamic fee;
@dynamic expiry;
@dynamic amtToForwardMsat;
@dynamic feeMsat;
@dynamic pubKey;

typedef struct LNDHop__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expiry;
  NSString *pubKey;
  uint64_t chanId;
  int64_t chanCapacity;
  int64_t amtToForward;
  int64_t fee;
  int64_t amtToForwardMsat;
  int64_t feeMsat;
} LNDHop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDHop__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanCapacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_ChanCapacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDHop__storage_, chanCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtToForward",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_AmtToForward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDHop__storage_, amtToForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDHop__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDHop__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "amtToForwardMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_AmtToForwardMsat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDHop__storage_, amtToForwardMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_FeeMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDHop__storage_, feeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDHop_FieldNumber_PubKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDHop__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDHop class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDHop__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDRoute

@implementation LNDRoute

@dynamic totalTimeLock;
@dynamic totalFees;
@dynamic totalAmt;
@dynamic hopsArray, hopsArray_Count;
@dynamic totalFeesMsat;
@dynamic totalAmtMsat;

typedef struct LNDRoute__storage_ {
  uint32_t _has_storage_[1];
  uint32_t totalTimeLock;
  NSMutableArray *hopsArray;
  int64_t totalFees;
  int64_t totalAmt;
  int64_t totalFeesMsat;
  int64_t totalAmtMsat;
} LNDRoute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalTimeLock",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoute_FieldNumber_TotalTimeLock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, totalTimeLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoute_FieldNumber_TotalFees,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalAmt",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoute_FieldNumber_TotalAmt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, totalAmt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hopsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDHop),
        .number = LNDRoute_FieldNumber_HopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, hopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalFeesMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoute_FieldNumber_TotalFeesMsat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, totalFeesMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalAmtMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoute_FieldNumber_TotalAmtMsat,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDRoute__storage_, totalAmtMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDRoute class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDRoute__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNodeInfoRequest

@implementation LNDNodeInfoRequest

@dynamic pubKey;

typedef struct LNDNodeInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} LNDNodeInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeInfoRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNodeInfoRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNodeInfoRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNodeInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNodeInfo

@implementation LNDNodeInfo

@dynamic hasNode, node;
@dynamic numChannels;
@dynamic totalCapacity;

typedef struct LNDNodeInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numChannels;
  LNDLightningNode *node;
  int64_t totalCapacity;
} LNDNodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDLightningNode),
        .number = LNDNodeInfo_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNodeInfo__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeInfo_FieldNumber_NumChannels,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDNodeInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalCapacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeInfo_FieldNumber_TotalCapacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDNodeInfo__storage_, totalCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNodeInfo class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDLightningNode

@implementation LNDLightningNode

@dynamic lastUpdate;
@dynamic pubKey;
@dynamic alias;
@dynamic addressesArray, addressesArray_Count;
@dynamic color;

typedef struct LNDLightningNode__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *pubKey;
  NSString *alias;
  NSMutableArray *addressesArray;
  NSString *color;
} LNDLightningNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningNode_FieldNumber_LastUpdate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDLightningNode__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningNode_FieldNumber_PubKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDLightningNode__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningNode_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDLightningNode__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDNodeAddress),
        .number = LNDLightningNode_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDLightningNode__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = LNDLightningNode_FieldNumber_Color,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDLightningNode__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDLightningNode class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDLightningNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNodeAddress

@implementation LNDNodeAddress

@dynamic network;
@dynamic addr;

typedef struct LNDNodeAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *network;
  NSString *addr;
} LNDNodeAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "network",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeAddress_FieldNumber_Network,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNodeAddress__storage_, network),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeAddress_FieldNumber_Addr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDNodeAddress__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNodeAddress class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNodeAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDRoutingPolicy

@implementation LNDRoutingPolicy

@dynamic timeLockDelta;
@dynamic minHtlc;
@dynamic feeBaseMsat;
@dynamic feeRateMilliMsat;
@dynamic disabled;

typedef struct LNDRoutingPolicy__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeLockDelta;
  int64_t minHtlc;
  int64_t feeBaseMsat;
  int64_t feeRateMilliMsat;
} LNDRoutingPolicy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoutingPolicy_FieldNumber_TimeLockDelta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDRoutingPolicy__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minHtlc",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoutingPolicy_FieldNumber_MinHtlc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDRoutingPolicy__storage_, minHtlc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeBaseMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoutingPolicy_FieldNumber_FeeBaseMsat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDRoutingPolicy__storage_, feeBaseMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRateMilliMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoutingPolicy_FieldNumber_FeeRateMilliMsat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDRoutingPolicy__storage_, feeRateMilliMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "disabled",
        .dataTypeSpecific.className = NULL,
        .number = LNDRoutingPolicy_FieldNumber_Disabled,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDRoutingPolicy class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDRoutingPolicy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelEdge

@implementation LNDChannelEdge

@dynamic channelId;
@dynamic chanPoint;
@dynamic lastUpdate;
@dynamic node1Pub;
@dynamic node2Pub;
@dynamic capacity;
@dynamic hasNode1Policy, node1Policy;
@dynamic hasNode2Policy, node2Policy;

typedef struct LNDChannelEdge__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *chanPoint;
  NSString *node1Pub;
  NSString *node2Pub;
  LNDRoutingPolicy *node1Policy;
  LNDRoutingPolicy *node2Policy;
  uint64_t channelId;
  int64_t capacity;
} LNDChannelEdge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_LastUpdate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "node1Pub",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_Node1Pub,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, node1Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "node2Pub",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_Node2Pub,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, node2Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdge_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "node1Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoutingPolicy),
        .number = LNDChannelEdge_FieldNumber_Node1Policy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, node1Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "node2Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoutingPolicy),
        .number = LNDChannelEdge_FieldNumber_Node2Policy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDChannelEdge__storage_, node2Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelEdge class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelEdge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelGraphRequest

@implementation LNDChannelGraphRequest

@dynamic includeUnannounced;

typedef struct LNDChannelGraphRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDChannelGraphRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeUnannounced",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelGraphRequest_FieldNumber_IncludeUnannounced,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelGraphRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelGraphRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelGraph

@implementation LNDChannelGraph

@dynamic nodesArray, nodesArray_Count;
@dynamic edgesArray, edgesArray_Count;

typedef struct LNDChannelGraph__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodesArray;
  NSMutableArray *edgesArray;
} LNDChannelGraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDLightningNode),
        .number = LNDChannelGraph_FieldNumber_NodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDChannelGraph__storage_, nodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelEdge),
        .number = LNDChannelGraph_FieldNumber_EdgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDChannelGraph__storage_, edgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelGraph class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelGraph__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChanInfoRequest

@implementation LNDChanInfoRequest

@dynamic chanId;

typedef struct LNDChanInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t chanId;
} LNDChanInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDChanInfoRequest_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChanInfoRequest__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChanInfoRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChanInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNetworkInfoRequest

@implementation LNDNetworkInfoRequest


typedef struct LNDNetworkInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDNetworkInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNetworkInfoRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDNetworkInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNetworkInfo

@implementation LNDNetworkInfo

@dynamic graphDiameter;
@dynamic avgOutDegree;
@dynamic maxOutDegree;
@dynamic numNodes;
@dynamic numChannels;
@dynamic totalNetworkCapacity;
@dynamic avgChannelSize;
@dynamic minChannelSize;
@dynamic maxChannelSize;

typedef struct LNDNetworkInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t graphDiameter;
  uint32_t maxOutDegree;
  uint32_t numNodes;
  uint32_t numChannels;
  double avgOutDegree;
  int64_t totalNetworkCapacity;
  double avgChannelSize;
  int64_t minChannelSize;
  int64_t maxChannelSize;
} LNDNetworkInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "graphDiameter",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_GraphDiameter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, graphDiameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avgOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_AvgOutDegree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, avgOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_MaxOutDegree,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, maxOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numNodes",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_NumNodes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, numNodes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_NumChannels,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalNetworkCapacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_TotalNetworkCapacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, totalNetworkCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "avgChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_AvgChannelSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, avgChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "minChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_MinChannelSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, minChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = LNDNetworkInfo_FieldNumber_MaxChannelSize,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDNetworkInfo__storage_, maxChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNetworkInfo class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNetworkInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDStopRequest

@implementation LNDStopRequest


typedef struct LNDStopRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDStopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDStopRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDStopRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDStopResponse

@implementation LNDStopResponse


typedef struct LNDStopResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDStopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDStopResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDStopResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGraphTopologySubscription

@implementation LNDGraphTopologySubscription


typedef struct LNDGraphTopologySubscription__storage_ {
  uint32_t _has_storage_[1];
} LNDGraphTopologySubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGraphTopologySubscription class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDGraphTopologySubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDGraphTopologyUpdate

@implementation LNDGraphTopologyUpdate

@dynamic nodeUpdatesArray, nodeUpdatesArray_Count;
@dynamic channelUpdatesArray, channelUpdatesArray_Count;
@dynamic closedChansArray, closedChansArray_Count;

typedef struct LNDGraphTopologyUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodeUpdatesArray;
  NSMutableArray *channelUpdatesArray;
  NSMutableArray *closedChansArray;
} LNDGraphTopologyUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDNodeUpdate),
        .number = LNDGraphTopologyUpdate_FieldNumber_NodeUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGraphTopologyUpdate__storage_, nodeUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelEdgeUpdate),
        .number = LNDGraphTopologyUpdate_FieldNumber_ChannelUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGraphTopologyUpdate__storage_, channelUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closedChansArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDClosedChannelUpdate),
        .number = LNDGraphTopologyUpdate_FieldNumber_ClosedChansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDGraphTopologyUpdate__storage_, closedChansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDGraphTopologyUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDGraphTopologyUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDNodeUpdate

@implementation LNDNodeUpdate

@dynamic addressesArray, addressesArray_Count;
@dynamic identityKey;
@dynamic globalFeatures;
@dynamic alias;

typedef struct LNDNodeUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSString *identityKey;
  NSData *globalFeatures;
  NSString *alias;
} LNDNodeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeUpdate_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDNodeUpdate__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityKey",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeUpdate_FieldNumber_IdentityKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDNodeUpdate__storage_, identityKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "globalFeatures",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeUpdate_FieldNumber_GlobalFeatures,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDNodeUpdate__storage_, globalFeatures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = LNDNodeUpdate_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDNodeUpdate__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDNodeUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDNodeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelEdgeUpdate

@implementation LNDChannelEdgeUpdate

@dynamic chanId;
@dynamic hasChanPoint, chanPoint;
@dynamic capacity;
@dynamic hasRoutingPolicy, routingPolicy;
@dynamic advertisingNode;
@dynamic connectingNode;

typedef struct LNDChannelEdgeUpdate__storage_ {
  uint32_t _has_storage_[1];
  LNDChannelPoint *chanPoint;
  LNDRoutingPolicy *routingPolicy;
  NSString *advertisingNode;
  NSString *connectingNode;
  uint64_t chanId;
  int64_t capacity;
} LNDChannelEdgeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdgeUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDChannelEdgeUpdate_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdgeUpdate_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "routingPolicy",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRoutingPolicy),
        .number = LNDChannelEdgeUpdate_FieldNumber_RoutingPolicy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, routingPolicy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertisingNode",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdgeUpdate_FieldNumber_AdvertisingNode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, advertisingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectingNode",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelEdgeUpdate_FieldNumber_ConnectingNode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDChannelEdgeUpdate__storage_, connectingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelEdgeUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelEdgeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDClosedChannelUpdate

@implementation LNDClosedChannelUpdate

@dynamic chanId;
@dynamic capacity;
@dynamic closedHeight;
@dynamic hasChanPoint, chanPoint;

typedef struct LNDClosedChannelUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t closedHeight;
  LNDChannelPoint *chanPoint;
  uint64_t chanId;
  int64_t capacity;
} LNDClosedChannelUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDClosedChannelUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelUpdate_FieldNumber_Capacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDClosedChannelUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closedHeight",
        .dataTypeSpecific.className = NULL,
        .number = LNDClosedChannelUpdate_FieldNumber_ClosedHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDClosedChannelUpdate__storage_, closedHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDClosedChannelUpdate_FieldNumber_ChanPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDClosedChannelUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDClosedChannelUpdate class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDClosedChannelUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDHopHint

@implementation LNDHopHint

@dynamic nodeId;
@dynamic chanId;
@dynamic feeBaseMsat;
@dynamic feeProportionalMillionths;
@dynamic cltvExpiryDelta;

typedef struct LNDHopHint__storage_ {
  uint32_t _has_storage_[1];
  uint32_t feeBaseMsat;
  uint32_t feeProportionalMillionths;
  uint32_t cltvExpiryDelta;
  NSString *nodeId;
  uint64_t chanId;
} LNDHopHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeId",
        .dataTypeSpecific.className = NULL,
        .number = LNDHopHint_FieldNumber_NodeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDHopHint__storage_, nodeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = LNDHopHint_FieldNumber_ChanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDHopHint__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "feeBaseMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDHopHint_FieldNumber_FeeBaseMsat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDHopHint__storage_, feeBaseMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "feeProportionalMillionths",
        .dataTypeSpecific.className = NULL,
        .number = LNDHopHint_FieldNumber_FeeProportionalMillionths,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDHopHint__storage_, feeProportionalMillionths),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cltvExpiryDelta",
        .dataTypeSpecific.className = NULL,
        .number = LNDHopHint_FieldNumber_CltvExpiryDelta,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDHopHint__storage_, cltvExpiryDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDHopHint class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDHopHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDRouteHint

@implementation LNDRouteHint

@dynamic hopHintsArray, hopHintsArray_Count;

typedef struct LNDRouteHint__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *hopHintsArray;
} LNDRouteHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hopHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDHopHint),
        .number = LNDRouteHint_FieldNumber_HopHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDRouteHint__storage_, hopHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDRouteHint class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDRouteHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDInvoice

@implementation LNDInvoice

@dynamic memo;
@dynamic receipt;
@dynamic rPreimage;
@dynamic rHash;
@dynamic value;
@dynamic settled;
@dynamic creationDate;
@dynamic settleDate;
@dynamic paymentRequest;
@dynamic descriptionHash;
@dynamic expiry;
@dynamic fallbackAddr;
@dynamic cltvExpiry;
@dynamic routeHintsArray, routeHintsArray_Count;
@dynamic private_p;
@dynamic addIndex;
@dynamic settleIndex;
@dynamic amtPaid;
@dynamic amtPaidSat;
@dynamic amtPaidMsat;

typedef struct LNDInvoice__storage_ {
  uint32_t _has_storage_[1];
  NSString *memo;
  NSData *receipt;
  NSData *rPreimage;
  NSData *rHash;
  NSString *paymentRequest;
  NSData *descriptionHash;
  NSString *fallbackAddr;
  NSMutableArray *routeHintsArray;
  int64_t value;
  int64_t creationDate;
  int64_t settleDate;
  int64_t expiry;
  uint64_t cltvExpiry;
  uint64_t addIndex;
  uint64_t settleIndex;
  int64_t amtPaid;
  int64_t amtPaidSat;
  int64_t amtPaidMsat;
} LNDInvoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memo",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Memo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, memo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Receipt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rPreimage",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_RPreimage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, rPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_RHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settled",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Settled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_CreationDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settleDate",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_SettleDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, settleDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_PaymentRequest,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_DescriptionHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Expiry,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_FallbackAddr,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_CltvExpiry,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "routeHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRouteHint),
        .number = LNDInvoice_FieldNumber_RouteHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, routeHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_Private_p,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_AddIndex,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "settleIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_SettleIndex,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, settleIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtPaid",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_AmtPaid,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, amtPaid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtPaidSat",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_AmtPaidSat,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, amtPaidSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtPaidMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoice_FieldNumber_AmtPaidMsat,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(LNDInvoice__storage_, amtPaidMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDInvoice class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDInvoice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDAddInvoiceResponse

@implementation LNDAddInvoiceResponse

@dynamic rHash;
@dynamic paymentRequest;
@dynamic addIndex;

typedef struct LNDAddInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *rHash;
  NSString *paymentRequest;
  uint64_t addIndex;
} LNDAddInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDAddInvoiceResponse_FieldNumber_RHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDAddInvoiceResponse__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = LNDAddInvoiceResponse_FieldNumber_PaymentRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDAddInvoiceResponse__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDAddInvoiceResponse_FieldNumber_AddIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDAddInvoiceResponse__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDAddInvoiceResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDAddInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPaymentHash

@implementation LNDPaymentHash

@dynamic rHashStr;
@dynamic rHash;

typedef struct LNDPaymentHash__storage_ {
  uint32_t _has_storage_[1];
  NSString *rHashStr;
  NSData *rHash;
} LNDPaymentHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHashStr",
        .dataTypeSpecific.className = NULL,
        .number = LNDPaymentHash_FieldNumber_RHashStr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPaymentHash__storage_, rHashStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDPaymentHash_FieldNumber_RHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPaymentHash__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPaymentHash class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPaymentHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListInvoiceRequest

@implementation LNDListInvoiceRequest

@dynamic pendingOnly;
@dynamic indexOffset;
@dynamic numMaxInvoices;
@dynamic reversed;

typedef struct LNDListInvoiceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t indexOffset;
  uint64_t numMaxInvoices;
} LNDListInvoiceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pendingOnly",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceRequest_FieldNumber_PendingOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "indexOffset",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceRequest_FieldNumber_IndexOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDListInvoiceRequest__storage_, indexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "numMaxInvoices",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceRequest_FieldNumber_NumMaxInvoices,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDListInvoiceRequest__storage_, numMaxInvoices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "reversed",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceRequest_FieldNumber_Reversed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListInvoiceRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListInvoiceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListInvoiceResponse

@implementation LNDListInvoiceResponse

@dynamic invoicesArray, invoicesArray_Count;
@dynamic lastIndexOffset;
@dynamic firstIndexOffset;

typedef struct LNDListInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *invoicesArray;
  uint64_t lastIndexOffset;
  uint64_t firstIndexOffset;
} LNDListInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invoicesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDInvoice),
        .number = LNDListInvoiceResponse_FieldNumber_InvoicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDListInvoiceResponse__storage_, invoicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastIndexOffset",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceResponse_FieldNumber_LastIndexOffset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDListInvoiceResponse__storage_, lastIndexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "firstIndexOffset",
        .dataTypeSpecific.className = NULL,
        .number = LNDListInvoiceResponse_FieldNumber_FirstIndexOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDListInvoiceResponse__storage_, firstIndexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListInvoiceResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDInvoiceSubscription

@implementation LNDInvoiceSubscription

@dynamic addIndex;
@dynamic settleIndex;

typedef struct LNDInvoiceSubscription__storage_ {
  uint32_t _has_storage_[1];
  uint64_t addIndex;
  uint64_t settleIndex;
} LNDInvoiceSubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoiceSubscription_FieldNumber_AddIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDInvoiceSubscription__storage_, addIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "settleIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDInvoiceSubscription_FieldNumber_SettleIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDInvoiceSubscription__storage_, settleIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDInvoiceSubscription class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDInvoiceSubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPayment

@implementation LNDPayment

@dynamic paymentHash;
@dynamic value;
@dynamic creationDate;
@dynamic pathArray, pathArray_Count;
@dynamic fee;
@dynamic paymentPreimage;
@dynamic valueSat;
@dynamic valueMsat;

typedef struct LNDPayment__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentHash;
  NSMutableArray *pathArray;
  NSString *paymentPreimage;
  int64_t value;
  int64_t creationDate;
  int64_t fee;
  int64_t valueSat;
  int64_t valueMsat;
} LNDPayment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_PaymentHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_CreationDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_PaymentPreimage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valueSat",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_ValueSat,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, valueSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "valueMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayment_FieldNumber_ValueMsat,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDPayment__storage_, valueMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPayment class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPayment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListPaymentsRequest

@implementation LNDListPaymentsRequest


typedef struct LNDListPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDListPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListPaymentsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDListPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDListPaymentsResponse

@implementation LNDListPaymentsResponse

@dynamic paymentsArray, paymentsArray_Count;

typedef struct LNDListPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *paymentsArray;
} LNDListPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDPayment),
        .number = LNDListPaymentsResponse_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDListPaymentsResponse__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDListPaymentsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDListPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDeleteAllPaymentsRequest

@implementation LNDDeleteAllPaymentsRequest


typedef struct LNDDeleteAllPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDDeleteAllPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDeleteAllPaymentsRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDDeleteAllPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDeleteAllPaymentsResponse

@implementation LNDDeleteAllPaymentsResponse


typedef struct LNDDeleteAllPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDDeleteAllPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDeleteAllPaymentsResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDDeleteAllPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDAbandonChannelRequest

@implementation LNDAbandonChannelRequest

@dynamic hasChannelPoint, channelPoint;

typedef struct LNDAbandonChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  LNDChannelPoint *channelPoint;
} LNDAbandonChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDAbandonChannelRequest_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDAbandonChannelRequest__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDAbandonChannelRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDAbandonChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDAbandonChannelResponse

@implementation LNDAbandonChannelResponse


typedef struct LNDAbandonChannelResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDAbandonChannelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDAbandonChannelResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDAbandonChannelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDebugLevelRequest

@implementation LNDDebugLevelRequest

@dynamic show;
@dynamic levelSpec;

typedef struct LNDDebugLevelRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *levelSpec;
} LNDDebugLevelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "show",
        .dataTypeSpecific.className = NULL,
        .number = LNDDebugLevelRequest_FieldNumber_Show,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "levelSpec",
        .dataTypeSpecific.className = NULL,
        .number = LNDDebugLevelRequest_FieldNumber_LevelSpec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDDebugLevelRequest__storage_, levelSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDebugLevelRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDDebugLevelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDDebugLevelResponse

@implementation LNDDebugLevelResponse

@dynamic subSystems;

typedef struct LNDDebugLevelResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *subSystems;
} LNDDebugLevelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subSystems",
        .dataTypeSpecific.className = NULL,
        .number = LNDDebugLevelResponse_FieldNumber_SubSystems,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDDebugLevelResponse__storage_, subSystems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDDebugLevelResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDDebugLevelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPayReqString

@implementation LNDPayReqString

@dynamic payReq;

typedef struct LNDPayReqString__storage_ {
  uint32_t _has_storage_[1];
  NSString *payReq;
} LNDPayReqString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payReq",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReqString_FieldNumber_PayReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPayReqString__storage_, payReq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPayReqString class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPayReqString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPayReq

@implementation LNDPayReq

@dynamic destination;
@dynamic paymentHash;
@dynamic numSatoshis;
@dynamic timestamp;
@dynamic expiry;
@dynamic description_p;
@dynamic descriptionHash;
@dynamic fallbackAddr;
@dynamic cltvExpiry;
@dynamic routeHintsArray, routeHintsArray_Count;

typedef struct LNDPayReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *destination;
  NSString *paymentHash;
  NSString *description_p;
  NSString *descriptionHash;
  NSString *fallbackAddr;
  NSMutableArray *routeHintsArray;
  int64_t numSatoshis;
  int64_t timestamp;
  int64_t expiry;
  int64_t cltvExpiry;
} LNDPayReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_Destination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_PaymentHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numSatoshis",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_NumSatoshis,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, numSatoshis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_DescriptionHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_FallbackAddr,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = LNDPayReq_FieldNumber_CltvExpiry,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "routeHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDRouteHint),
        .number = LNDPayReq_FieldNumber_RouteHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDPayReq__storage_, routeHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPayReq class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPayReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDFeeReportRequest

@implementation LNDFeeReportRequest


typedef struct LNDFeeReportRequest__storage_ {
  uint32_t _has_storage_[1];
} LNDFeeReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDFeeReportRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDFeeReportRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDChannelFeeReport

@implementation LNDChannelFeeReport

@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feePerMil;
@dynamic feeRate;

typedef struct LNDChannelFeeReport__storage_ {
  uint32_t _has_storage_[1];
  NSString *chanPoint;
  int64_t baseFeeMsat;
  int64_t feePerMil;
  double feeRate;
} LNDChannelFeeReport__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelFeeReport_FieldNumber_ChanPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDChannelFeeReport__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelFeeReport_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDChannelFeeReport__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerMil",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelFeeReport_FieldNumber_FeePerMil,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDChannelFeeReport__storage_, feePerMil),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = LNDChannelFeeReport_FieldNumber_FeeRate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDChannelFeeReport__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDChannelFeeReport class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDChannelFeeReport__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDFeeReportResponse

@implementation LNDFeeReportResponse

@dynamic channelFeesArray, channelFeesArray_Count;
@dynamic dayFeeSum;
@dynamic weekFeeSum;
@dynamic monthFeeSum;

typedef struct LNDFeeReportResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelFeesArray;
  uint64_t dayFeeSum;
  uint64_t weekFeeSum;
  uint64_t monthFeeSum;
} LNDFeeReportResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelFeesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelFeeReport),
        .number = LNDFeeReportResponse_FieldNumber_ChannelFeesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDFeeReportResponse__storage_, channelFeesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dayFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = LNDFeeReportResponse_FieldNumber_DayFeeSum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDFeeReportResponse__storage_, dayFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "weekFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = LNDFeeReportResponse_FieldNumber_WeekFeeSum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDFeeReportResponse__storage_, weekFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "monthFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = LNDFeeReportResponse_FieldNumber_MonthFeeSum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDFeeReportResponse__storage_, monthFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDFeeReportResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDFeeReportResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDPolicyUpdateRequest

@implementation LNDPolicyUpdateRequest

@dynamic scopeOneOfCase;
@dynamic global;
@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feeRate;
@dynamic timeLockDelta;

typedef struct LNDPolicyUpdateRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t timeLockDelta;
  LNDChannelPoint *chanPoint;
  int64_t baseFeeMsat;
  double feeRate;
} LNDPolicyUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "global",
        .dataTypeSpecific.className = NULL,
        .number = LNDPolicyUpdateRequest_FieldNumber_Global,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDChannelPoint),
        .number = LNDPolicyUpdateRequest_FieldNumber_ChanPoint,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LNDPolicyUpdateRequest__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = LNDPolicyUpdateRequest_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDPolicyUpdateRequest__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = LNDPolicyUpdateRequest_FieldNumber_FeeRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDPolicyUpdateRequest__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = LNDPolicyUpdateRequest_FieldNumber_TimeLockDelta,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDPolicyUpdateRequest__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPolicyUpdateRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDPolicyUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "scope",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void LNDPolicyUpdateRequest_ClearScopeOneOfCase(LNDPolicyUpdateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LNDPolicyUpdateResponse

@implementation LNDPolicyUpdateResponse


typedef struct LNDPolicyUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
} LNDPolicyUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDPolicyUpdateResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LNDPolicyUpdateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDForwardingHistoryRequest

@implementation LNDForwardingHistoryRequest

@dynamic startTime;
@dynamic endTime;
@dynamic indexOffset;
@dynamic numMaxEvents;

typedef struct LNDForwardingHistoryRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t indexOffset;
  uint32_t numMaxEvents;
  uint64_t startTime;
  uint64_t endTime;
} LNDForwardingHistoryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingHistoryRequest_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryRequest__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingHistoryRequest_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryRequest__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "indexOffset",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingHistoryRequest_FieldNumber_IndexOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryRequest__storage_, indexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numMaxEvents",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingHistoryRequest_FieldNumber_NumMaxEvents,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryRequest__storage_, numMaxEvents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDForwardingHistoryRequest class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDForwardingHistoryRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDForwardingEvent

@implementation LNDForwardingEvent

@dynamic timestamp;
@dynamic chanIdIn;
@dynamic chanIdOut;
@dynamic amtIn;
@dynamic amtOut;
@dynamic fee;

typedef struct LNDForwardingEvent__storage_ {
  uint32_t _has_storage_[1];
  uint64_t timestamp;
  uint64_t chanIdIn;
  uint64_t chanIdOut;
  uint64_t amtIn;
  uint64_t amtOut;
  uint64_t fee;
} LNDForwardingEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdIn",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_ChanIdIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, chanIdIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdOut",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_ChanIdOut,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, chanIdOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtIn",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_AmtIn,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, amtIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtOut",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_AmtOut,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, amtOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingEvent_FieldNumber_Fee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LNDForwardingEvent__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDForwardingEvent class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDForwardingEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LNDForwardingHistoryResponse

@implementation LNDForwardingHistoryResponse

@dynamic forwardingEventsArray, forwardingEventsArray_Count;
@dynamic lastOffsetIndex;

typedef struct LNDForwardingHistoryResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastOffsetIndex;
  NSMutableArray *forwardingEventsArray;
} LNDForwardingHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "forwardingEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LNDForwardingEvent),
        .number = LNDForwardingHistoryResponse_FieldNumber_ForwardingEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryResponse__storage_, forwardingEventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastOffsetIndex",
        .dataTypeSpecific.className = NULL,
        .number = LNDForwardingHistoryResponse_FieldNumber_LastOffsetIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LNDForwardingHistoryResponse__storage_, lastOffsetIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LNDForwardingHistoryResponse class]
                                     rootClass:[LNDLndRpcRoot class]
                                          file:LNDLndRpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LNDForwardingHistoryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
