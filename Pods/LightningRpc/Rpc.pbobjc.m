// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Rpc.pbobjc.h"
// #import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - RpcRoot

@implementation RpcRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
//    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - RpcRoot_FileDescriptor

static GPBFileDescriptor *RpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"lnrpc"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GenSeedRequest

@implementation GenSeedRequest

@dynamic aezeedPassphrase;
@dynamic seedEntropy;

typedef struct GenSeedRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *aezeedPassphrase;
  NSData *seedEntropy;
} GenSeedRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenSeedRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "seedEntropy",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedRequest_FieldNumber_SeedEntropy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenSeedRequest__storage_, seedEntropy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenSeedRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenSeedRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenSeedResponse

@implementation GenSeedResponse

@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic encipheredSeed;

typedef struct GenSeedResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *encipheredSeed;
} GenSeedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedResponse_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GenSeedResponse__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encipheredSeed",
        .dataTypeSpecific.className = NULL,
        .number = GenSeedResponse_FieldNumber_EncipheredSeed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenSeedResponse__storage_, encipheredSeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenSeedResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenSeedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitWalletRequest

@implementation InitWalletRequest

@dynamic walletPassword;
@dynamic cipherSeedMnemonicArray, cipherSeedMnemonicArray_Count;
@dynamic aezeedPassphrase;

typedef struct InitWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *walletPassword;
  NSMutableArray *cipherSeedMnemonicArray;
  NSData *aezeedPassphrase;
} InitWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cipherSeedMnemonicArray",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_CipherSeedMnemonicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, cipherSeedMnemonicArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aezeedPassphrase",
        .dataTypeSpecific.className = NULL,
        .number = InitWalletRequest_FieldNumber_AezeedPassphrase,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InitWalletRequest__storage_, aezeedPassphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InitWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitWalletResponse

@implementation InitWalletResponse


typedef struct InitWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} InitWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(InitWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnlockWalletRequest

@implementation UnlockWalletRequest

@dynamic walletPassword;

typedef struct UnlockWalletRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *walletPassword;
} UnlockWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "walletPassword",
        .dataTypeSpecific.className = NULL,
        .number = UnlockWalletRequest_FieldNumber_WalletPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnlockWalletRequest__storage_, walletPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnlockWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnlockWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnlockWalletResponse

@implementation UnlockWalletResponse


typedef struct UnlockWalletResponse__storage_ {
  uint32_t _has_storage_[1];
} UnlockWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnlockWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(UnlockWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic txHash;
@dynamic amount;
@dynamic numConfirmations;
@dynamic blockHash;
@dynamic blockHeight;
@dynamic timeStamp;
@dynamic totalFees;
@dynamic destAddressesArray, destAddressesArray_Count;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t numConfirmations;
  int32_t blockHeight;
  NSString *txHash;
  NSString *blockHash;
  NSMutableArray *destAddressesArray;
  int64_t amount;
  int64_t timeStamp;
  int64_t totalFees;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numConfirmations",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_NumConfirmations,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, numConfirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BlockHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BlockHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TimeStamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, timeStamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TotalFees,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "destAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_DestAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, destAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionsRequest

@implementation GetTransactionsRequest


typedef struct GetTransactionsRequest__storage_ {
  uint32_t _has_storage_[1];
} GetTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetTransactionsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionDetails

@implementation TransactionDetails

@dynamic transactionsArray, transactionsArray_Count;

typedef struct TransactionDetails__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} TransactionDetails__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionDetails_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionDetails__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionDetails class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionDetails__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendRequest

@implementation SendRequest

@dynamic dest;
@dynamic destString;
@dynamic amt;
@dynamic paymentHash;
@dynamic paymentHashString;
@dynamic paymentRequest;
@dynamic finalCltvDelta;

typedef struct SendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t finalCltvDelta;
  NSData *dest;
  NSString *destString;
  NSData *paymentHash;
  NSString *paymentHashString;
  NSString *paymentRequest;
  int64_t amt;
} SendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dest",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_Dest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendRequest__storage_, dest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "destString",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_DestString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendRequest__storage_, destString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_Amt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentHashString",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentHashString,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentHashString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_PaymentRequest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendRequest__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "finalCltvDelta",
        .dataTypeSpecific.className = NULL,
        .number = SendRequest_FieldNumber_FinalCltvDelta,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendRequest__storage_, finalCltvDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendResponse

@implementation SendResponse

@dynamic paymentError;
@dynamic paymentPreimage;
@dynamic hasPaymentRoute, paymentRoute;

typedef struct SendResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentError;
  NSData *paymentPreimage;
  Route *paymentRoute;
} SendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentError",
        .dataTypeSpecific.className = NULL,
        .number = SendResponse_FieldNumber_PaymentError,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentError),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = SendResponse_FieldNumber_PaymentPreimage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRoute",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = SendResponse_FieldNumber_PaymentRoute,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendResponse__storage_, paymentRoute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelPoint

@implementation ChannelPoint

@dynamic fundingTxidOneOfCase;
@dynamic fundingTxidBytes;
@dynamic fundingTxidStr;
@dynamic outputIndex;

typedef struct ChannelPoint__storage_ {
  uint32_t _has_storage_[2];
  uint32_t outputIndex;
  NSData *fundingTxidBytes;
  NSString *fundingTxidStr;
} ChannelPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fundingTxidBytes",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_FundingTxidBytes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, fundingTxidBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fundingTxidStr",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_FundingTxidStr,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, fundingTxidStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPoint_FieldNumber_OutputIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelPoint__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelPoint class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "fundingTxid",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ChannelPoint_ClearFundingTxidOneOfCase(ChannelPoint *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LightningAddress

@implementation LightningAddress

@dynamic pubkey;
@dynamic host;

typedef struct LightningAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
  NSString *host;
} LightningAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = LightningAddress_FieldNumber_Pubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LightningAddress__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = LightningAddress_FieldNumber_Host,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LightningAddress__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LightningAddress class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LightningAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyRequest

@implementation SendManyRequest

@dynamic addrToAmount, addrToAmount_Count;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct SendManyRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  GPBStringInt64Dictionary *addrToAmount;
  int64_t satPerByte;
} SendManyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrToAmount",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_AddrToAmount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, addrToAmount),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_TargetConf,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_SatPerByte,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendManyRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyResponse

@implementation SendManyResponse

@dynamic txid;

typedef struct SendManyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} SendManyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SendManyResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendManyResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendCoinsRequest

@implementation SendCoinsRequest

@dynamic addr;
@dynamic amount;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct SendCoinsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  NSString *addr;
  int64_t amount;
  int64_t satPerByte;
} SendCoinsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_TargetConf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsRequest_FieldNumber_SatPerByte,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendCoinsRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendCoinsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendCoinsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendCoinsResponse

@implementation SendCoinsResponse

@dynamic txid;

typedef struct SendCoinsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
} SendCoinsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SendCoinsResponse_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendCoinsResponse__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendCoinsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendCoinsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAddressRequest

@implementation NewAddressRequest

@dynamic type;

typedef struct NewAddressRequest__storage_ {
  uint32_t _has_storage_[1];
  NewAddressRequest_AddressType type;
} NewAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = NewAddressRequest_AddressType_EnumDescriptor,
        .number = NewAddressRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAddressRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NewAddressRequest_Type_RawValue(NewAddressRequest *message) {
  GPBDescriptor *descriptor = [NewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NewAddressRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetNewAddressRequest_Type_RawValue(NewAddressRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [NewAddressRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NewAddressRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum NewAddressRequest_AddressType

GPBEnumDescriptor *NewAddressRequest_AddressType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WitnessPubkeyHash\000NestedPubkeyHash\000";
    static const int32_t values[] = {
        NewAddressRequest_AddressType_WitnessPubkeyHash,
        NewAddressRequest_AddressType_NestedPubkeyHash,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NewAddressRequest_AddressType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NewAddressRequest_AddressType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NewAddressRequest_AddressType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NewAddressRequest_AddressType_WitnessPubkeyHash:
    case NewAddressRequest_AddressType_NestedPubkeyHash:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NewWitnessAddressRequest

@implementation NewWitnessAddressRequest


typedef struct NewWitnessAddressRequest__storage_ {
  uint32_t _has_storage_[1];
} NewWitnessAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewWitnessAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NewWitnessAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAddressResponse

@implementation NewAddressResponse

@dynamic address;

typedef struct NewAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} NewAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = NewAddressResponse_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAddressResponse__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageRequest

@implementation SignMessageRequest

@dynamic msg;

typedef struct SignMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
} SignMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageResponse

@implementation SignMessageResponse

@dynamic signature;

typedef struct SignMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *signature;
} SignMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageResponse_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageResponse__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageRequest

@implementation VerifyMessageRequest

@dynamic msg;
@dynamic signature;

typedef struct VerifyMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
  NSString *signature;
} VerifyMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageResponse

@implementation VerifyMessageResponse

@dynamic valid;
@dynamic pubkey;

typedef struct VerifyMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubkey;
} VerifyMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valid",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageResponse_FieldNumber_Valid,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pubkey",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageResponse_FieldNumber_Pubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyMessageResponse__storage_, pubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectPeerRequest

@implementation ConnectPeerRequest

@dynamic hasAddr, addr;
@dynamic perm;

typedef struct ConnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  LightningAddress *addr;
} ConnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addr",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningAddress),
        .number = ConnectPeerRequest_FieldNumber_Addr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectPeerRequest__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "perm",
        .dataTypeSpecific.className = NULL,
        .number = ConnectPeerRequest_FieldNumber_Perm,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectPeerRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectPeerResponse

@implementation ConnectPeerResponse


typedef struct ConnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} ConnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectPeerResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ConnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectPeerRequest

@implementation DisconnectPeerRequest

@dynamic pubKey;

typedef struct DisconnectPeerRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} DisconnectPeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = DisconnectPeerRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectPeerRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectPeerRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectPeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectPeerResponse

@implementation DisconnectPeerResponse


typedef struct DisconnectPeerResponse__storage_ {
  uint32_t _has_storage_[1];
} DisconnectPeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectPeerResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DisconnectPeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HTLC

@implementation HTLC

@dynamic incoming;
@dynamic amount;
@dynamic hashLock;
@dynamic expirationHeight;

typedef struct HTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expirationHeight;
  NSData *hashLock;
  int64_t amount;
} HTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashLock",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_HashLock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HTLC__storage_, hashLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expirationHeight",
        .dataTypeSpecific.className = NULL,
        .number = HTLC_FieldNumber_ExpirationHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HTLC__storage_, expirationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HTLC class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ActiveChannel

@implementation ActiveChannel

@dynamic active;
@dynamic remotePubkey;
@dynamic channelPoint;
@dynamic chanId;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;
@dynamic unsettledBalance;
@dynamic totalSatoshisSent;
@dynamic totalSatoshisReceived;
@dynamic numUpdates;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;
@dynamic csvDelay;

typedef struct ActiveChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t csvDelay;
  NSString *remotePubkey;
  NSString *channelPoint;
  NSMutableArray *pendingHtlcsArray;
  uint64_t chanId;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
  int64_t unsettledBalance;
  int64_t totalSatoshisSent;
  int64_t totalSatoshisReceived;
  uint64_t numUpdates;
} ActiveChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "active",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_Active,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "remotePubkey",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_RemotePubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, remotePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_ChannelPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_ChanId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_LocalBalance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_RemoteBalance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_CommitFee,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_CommitWeight,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_FeePerKw,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unsettledBalance",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_UnsettledBalance,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, unsettledBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisSent",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_TotalSatoshisSent,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, totalSatoshisSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSatoshisReceived",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_TotalSatoshisReceived,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, totalSatoshisReceived),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numUpdates",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_NumUpdates,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, numUpdates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(HTLC),
        .number = ActiveChannel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "csvDelay",
        .dataTypeSpecific.className = NULL,
        .number = ActiveChannel_FieldNumber_CsvDelay,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ActiveChannel__storage_, csvDelay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ActiveChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ActiveChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListChannelsRequest

@implementation ListChannelsRequest


typedef struct ListChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} ListChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListChannelsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListChannelsResponse

@implementation ListChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct ListChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} ListChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ActiveChannel),
        .number = ListChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListChannelsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peer

@implementation Peer

@dynamic pubKey;
@dynamic address;
@dynamic bytesSent;
@dynamic bytesRecv;
@dynamic satSent;
@dynamic satRecv;
@dynamic inbound;
@dynamic pingTime;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *address;
  uint64_t bytesSent;
  uint64_t bytesRecv;
  int64_t satSent;
  int64_t satRecv;
  int64_t pingTime;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Peer__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bytesSent",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_BytesSent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Peer__storage_, bytesSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "bytesRecv",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_BytesRecv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Peer__storage_, bytesRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "satSent",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_SatSent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Peer__storage_, satSent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "satRecv",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_SatRecv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Peer__storage_, satRecv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inbound",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Inbound,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pingTime",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_PingTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Peer__storage_, pingTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPeersRequest

@implementation ListPeersRequest


typedef struct ListPeersRequest__storage_ {
  uint32_t _has_storage_[1];
} ListPeersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPeersRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListPeersRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPeersResponse

@implementation ListPeersResponse

@dynamic peersArray, peersArray_Count;

typedef struct ListPeersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} ListPeersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = ListPeersResponse_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListPeersResponse__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPeersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListPeersResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoRequest

@implementation GetInfoRequest


typedef struct GetInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} GetInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoResponse

@implementation GetInfoResponse

@dynamic identityPubkey;
@dynamic alias;
@dynamic numPendingChannels;
@dynamic numActiveChannels;
@dynamic numPeers;
@dynamic blockHeight;
@dynamic blockHash;
@dynamic syncedToChain;
@dynamic testnet;
@dynamic chainsArray, chainsArray_Count;
@dynamic urisArray, urisArray_Count;
@dynamic bestHeaderTimestamp;

typedef struct GetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numPendingChannels;
  uint32_t numActiveChannels;
  uint32_t numPeers;
  uint32_t blockHeight;
  NSString *identityPubkey;
  NSString *alias;
  NSString *blockHash;
  NSMutableArray *chainsArray;
  NSMutableArray *urisArray;
  int64_t bestHeaderTimestamp;
} GetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identityPubkey",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_IdentityPubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, identityPubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Alias,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numPendingChannels",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumPendingChannels,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numPendingChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numActiveChannels",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumActiveChannels,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numActiveChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numPeers",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_NumPeers,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, numPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BlockHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, blockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncedToChain",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_SyncedToChain,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "testnet",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Testnet,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chainsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_ChainsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, chainsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "urisArray",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_UrisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, urisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bestHeaderTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_BestHeaderTimestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, bestHeaderTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfirmationUpdate

@implementation ConfirmationUpdate

@dynamic blockSha;
@dynamic blockHeight;
@dynamic numConfsLeft;

typedef struct ConfirmationUpdate__storage_ {
  uint32_t _has_storage_[1];
  int32_t blockHeight;
  uint32_t numConfsLeft;
  NSData *blockSha;
} ConfirmationUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockSha",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_BlockSha,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, blockSha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numConfsLeft",
        .dataTypeSpecific.className = NULL,
        .number = ConfirmationUpdate_FieldNumber_NumConfsLeft,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ConfirmationUpdate__storage_, numConfsLeft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfirmationUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfirmationUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelOpenUpdate

@implementation ChannelOpenUpdate

@dynamic hasChannelPoint, channelPoint;

typedef struct ChannelOpenUpdate__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *channelPoint;
} ChannelOpenUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelOpenUpdate_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelOpenUpdate__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelOpenUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelOpenUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelCloseUpdate

@implementation ChannelCloseUpdate

@dynamic closingTxid;
@dynamic success;

typedef struct ChannelCloseUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSData *closingTxid;
} ChannelCloseUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseUpdate_FieldNumber_ClosingTxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelCloseUpdate__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = ChannelCloseUpdate_FieldNumber_Success,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelCloseUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelCloseUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseChannelRequest

@implementation CloseChannelRequest

@dynamic hasChannelPoint, channelPoint;
@dynamic force;
@dynamic targetConf;
@dynamic satPerByte;

typedef struct CloseChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  ChannelPoint *channelPoint;
  int64_t satPerByte;
} CloseChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = CloseChannelRequest_FieldNumber_ChannelPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_Force,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CloseChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseChannelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseStatusUpdate

@implementation CloseStatusUpdate

@dynamic updateOneOfCase;
@dynamic closePending;
@dynamic confirmation;
@dynamic chanClose;

typedef struct CloseStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  PendingUpdate *closePending;
  ConfirmationUpdate *confirmation;
  ChannelCloseUpdate *chanClose;
} CloseStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closePending",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingUpdate),
        .number = CloseStatusUpdate_FieldNumber_ClosePending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CloseStatusUpdate__storage_, closePending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmation",
        .dataTypeSpecific.className = GPBStringifySymbol(ConfirmationUpdate),
        .number = CloseStatusUpdate_FieldNumber_Confirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CloseStatusUpdate__storage_, confirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanClose",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelCloseUpdate),
        .number = CloseStatusUpdate_FieldNumber_ChanClose,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CloseStatusUpdate__storage_, chanClose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseStatusUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CloseStatusUpdate_ClearUpdateOneOfCase(CloseStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PendingUpdate

@implementation PendingUpdate

@dynamic txid;
@dynamic outputIndex;

typedef struct PendingUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t outputIndex;
  NSData *txid;
} PendingUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = PendingUpdate_FieldNumber_Txid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingUpdate__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "outputIndex",
        .dataTypeSpecific.className = NULL,
        .number = PendingUpdate_FieldNumber_OutputIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingUpdate__storage_, outputIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenChannelRequest

@implementation OpenChannelRequest

@dynamic nodePubkey;
@dynamic nodePubkeyString;
@dynamic localFundingAmount;
@dynamic pushSat;
@dynamic targetConf;
@dynamic satPerByte;
@dynamic private_p;
@dynamic minHtlcMsat;

typedef struct OpenChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t targetConf;
  NSData *nodePubkey;
  NSString *nodePubkeyString;
  int64_t localFundingAmount;
  int64_t pushSat;
  int64_t satPerByte;
  int64_t minHtlcMsat;
} OpenChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodePubkey",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_NodePubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, nodePubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nodePubkeyString",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_NodePubkeyString,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, nodePubkeyString),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "localFundingAmount",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_LocalFundingAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, localFundingAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pushSat",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_PushSat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, pushSat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "targetConf",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_TargetConf,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, targetConf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "satPerByte",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_SatPerByte,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, satPerByte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "private_p",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_Private_p,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minHtlcMsat",
        .dataTypeSpecific.className = NULL,
        .number = OpenChannelRequest_FieldNumber_MinHtlcMsat,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OpenChannelRequest__storage_, minHtlcMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenChannelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenChannelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenStatusUpdate

@implementation OpenStatusUpdate

@dynamic updateOneOfCase;
@dynamic chanPending;
@dynamic confirmation;
@dynamic chanOpen;

typedef struct OpenStatusUpdate__storage_ {
  uint32_t _has_storage_[2];
  PendingUpdate *chanPending;
  ConfirmationUpdate *confirmation;
  ChannelOpenUpdate *chanOpen;
} OpenStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPending",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingUpdate),
        .number = OpenStatusUpdate_FieldNumber_ChanPending,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OpenStatusUpdate__storage_, chanPending),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmation",
        .dataTypeSpecific.className = GPBStringifySymbol(ConfirmationUpdate),
        .number = OpenStatusUpdate_FieldNumber_Confirmation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OpenStatusUpdate__storage_, confirmation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chanOpen",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelOpenUpdate),
        .number = OpenStatusUpdate_FieldNumber_ChanOpen,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OpenStatusUpdate__storage_, chanOpen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenStatusUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenStatusUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "update",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void OpenStatusUpdate_ClearUpdateOneOfCase(OpenStatusUpdate *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PendingHTLC

@implementation PendingHTLC

@dynamic incoming;
@dynamic amount;
@dynamic outpoint;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic stage;

typedef struct PendingHTLC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  uint32_t stage;
  NSString *outpoint;
  int64_t amount;
} PendingHTLC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "incoming",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Incoming,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Outpoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_MaturityHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_BlocksTilMaturity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stage",
        .dataTypeSpecific.className = NULL,
        .number = PendingHTLC_FieldNumber_Stage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PendingHTLC__storage_, stage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingHTLC class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingHTLC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsRequest

@implementation PendingChannelsRequest


typedef struct PendingChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
} PendingChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PendingChannelsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse

@implementation PendingChannelsResponse

@dynamic totalLimboBalance;
@dynamic pendingOpenChannelsArray, pendingOpenChannelsArray_Count;
@dynamic pendingClosingChannelsArray, pendingClosingChannelsArray_Count;
@dynamic pendingForceClosingChannelsArray, pendingForceClosingChannelsArray_Count;

typedef struct PendingChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pendingOpenChannelsArray;
  NSMutableArray *pendingClosingChannelsArray;
  NSMutableArray *pendingForceClosingChannelsArray;
  int64_t totalLimboBalance;
} PendingChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalLimboBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_FieldNumber_TotalLimboBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, totalLimboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingOpenChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingOpenChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingOpenChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingOpenChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_ClosedChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingForceClosingChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_ForceClosedChannel),
        .number = PendingChannelsResponse_FieldNumber_PendingForceClosingChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse__storage_, pendingForceClosingChannelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_PendingChannel

@implementation PendingChannelsResponse_PendingChannel

@dynamic remoteNodePub;
@dynamic channelPoint;
@dynamic capacity;
@dynamic localBalance;
@dynamic remoteBalance;

typedef struct PendingChannelsResponse_PendingChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *remoteNodePub;
  NSString *channelPoint;
  int64_t capacity;
  int64_t localBalance;
  int64_t remoteBalance;
} PendingChannelsResponse_PendingChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remoteNodePub",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_RemoteNodePub,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, remoteNodePub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelPoint",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_ChannelPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, channelPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "localBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_LocalBalance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, localBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingChannel_FieldNumber_RemoteBalance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingChannel__storage_, remoteBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_PendingChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_PendingChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_PendingOpenChannel

@implementation PendingChannelsResponse_PendingOpenChannel

@dynamic hasChannel, channel;
@dynamic confirmationHeight;
@dynamic commitFee;
@dynamic commitWeight;
@dynamic feePerKw;

typedef struct PendingChannelsResponse_PendingOpenChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t confirmationHeight;
  PendingChannelsResponse_PendingChannel *channel;
  int64_t commitFee;
  int64_t commitWeight;
  int64_t feePerKw;
} PendingChannelsResponse_PendingOpenChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmationHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_ConfirmationHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, confirmationHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "commitFee",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, commitFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "commitWeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_CommitWeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, commitWeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKw",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_PendingOpenChannel_FieldNumber_FeePerKw,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_PendingOpenChannel__storage_, feePerKw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_PendingOpenChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_PendingOpenChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_ClosedChannel

@implementation PendingChannelsResponse_ClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;

typedef struct PendingChannelsResponse_ClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  PendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
} PendingChannelsResponse_ClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_ClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_ClosedChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_ClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingChannelsResponse_ForceClosedChannel

@implementation PendingChannelsResponse_ForceClosedChannel

@dynamic hasChannel, channel;
@dynamic closingTxid;
@dynamic limboBalance;
@dynamic maturityHeight;
@dynamic blocksTilMaturity;
@dynamic recoveredBalance;
@dynamic pendingHtlcsArray, pendingHtlcsArray_Count;

typedef struct PendingChannelsResponse_ForceClosedChannel__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maturityHeight;
  int32_t blocksTilMaturity;
  PendingChannelsResponse_PendingChannel *channel;
  NSString *closingTxid;
  NSMutableArray *pendingHtlcsArray;
  int64_t limboBalance;
  int64_t recoveredBalance;
} PendingChannelsResponse_ForceClosedChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingChannelsResponse_PendingChannel),
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closingTxid",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_ClosingTxid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, closingTxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limboBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_LimboBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, limboBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maturityHeight",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_MaturityHeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, maturityHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blocksTilMaturity",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_BlocksTilMaturity,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, blocksTilMaturity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "recoveredBalance",
        .dataTypeSpecific.className = NULL,
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_RecoveredBalance,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, recoveredBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingHtlcsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PendingHTLC),
        .number = PendingChannelsResponse_ForceClosedChannel_FieldNumber_PendingHtlcsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PendingChannelsResponse_ForceClosedChannel__storage_, pendingHtlcsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingChannelsResponse_ForceClosedChannel class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingChannelsResponse_ForceClosedChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PendingChannelsResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WalletBalanceRequest

@implementation WalletBalanceRequest


typedef struct WalletBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} WalletBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WalletBalanceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(WalletBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WalletBalanceResponse

@implementation WalletBalanceResponse

@dynamic totalBalance;
@dynamic confirmedBalance;
@dynamic unconfirmedBalance;

typedef struct WalletBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalBalance;
  int64_t confirmedBalance;
  int64_t unconfirmedBalance;
} WalletBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_TotalBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, totalBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "confirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_ConfirmedBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, confirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unconfirmedBalance",
        .dataTypeSpecific.className = NULL,
        .number = WalletBalanceResponse_FieldNumber_UnconfirmedBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WalletBalanceResponse__storage_, unconfirmedBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WalletBalanceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WalletBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBalanceRequest

@implementation ChannelBalanceRequest


typedef struct ChannelBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} ChannelBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBalanceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChannelBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelBalanceResponse

@implementation ChannelBalanceResponse

@dynamic balance;

typedef struct ChannelBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  int64_t balance;
} ChannelBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBalanceResponse_FieldNumber_Balance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelBalanceResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBalanceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryRoutesRequest

@implementation QueryRoutesRequest

@dynamic pubKey;
@dynamic amt;
@dynamic numRoutes;

typedef struct QueryRoutesRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t numRoutes;
  NSString *pubKey;
  int64_t amt;
} QueryRoutesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amt",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_Amt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, amt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "numRoutes",
        .dataTypeSpecific.className = NULL,
        .number = QueryRoutesRequest_FieldNumber_NumRoutes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QueryRoutesRequest__storage_, numRoutes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryRoutesRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryRoutesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryRoutesResponse

@implementation QueryRoutesResponse

@dynamic routesArray, routesArray_Count;

typedef struct QueryRoutesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *routesArray;
} QueryRoutesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = QueryRoutesResponse_FieldNumber_RoutesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryRoutesResponse__storage_, routesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryRoutesResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryRoutesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Hop

@implementation Hop

@dynamic chanId;
@dynamic chanCapacity;
@dynamic amtToForward;
@dynamic fee;
@dynamic expiry;

typedef struct Hop__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expiry;
  uint64_t chanId;
  int64_t chanCapacity;
  int64_t amtToForward;
  int64_t fee;
} Hop__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Hop__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanCapacity",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_ChanCapacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Hop__storage_, chanCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amtToForward",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_AmtToForward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Hop__storage_, amtToForward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Hop__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = Hop_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Hop__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Hop class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Hop__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Route

@implementation Route

@dynamic totalTimeLock;
@dynamic totalFees;
@dynamic totalAmt;
@dynamic hopsArray, hopsArray_Count;

typedef struct Route__storage_ {
  uint32_t _has_storage_[1];
  uint32_t totalTimeLock;
  NSMutableArray *hopsArray;
  int64_t totalFees;
  int64_t totalAmt;
} Route__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalTimeLock",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalTimeLock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Route__storage_, totalTimeLock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalFees",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalFees,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Route__storage_, totalFees),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalAmt",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_TotalAmt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Route__storage_, totalAmt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hopsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Hop),
        .number = Route_FieldNumber_HopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Route__storage_, hopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Route class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Route__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfoRequest

@implementation NodeInfoRequest

@dynamic pubKey;

typedef struct NodeInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
} NodeInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfoRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfoRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic hasNode, node;
@dynamic numChannels;
@dynamic totalCapacity;

typedef struct NodeInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numChannels;
  LightningNode *node;
  int64_t totalCapacity;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningNode),
        .number = NodeInfo_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumChannels,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalCapacity",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_TotalCapacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, totalCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LightningNode

@implementation LightningNode

@dynamic lastUpdate;
@dynamic pubKey;
@dynamic alias;
@dynamic addressesArray, addressesArray_Count;
@dynamic color;

typedef struct LightningNode__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *pubKey;
  NSString *alias;
  NSMutableArray *addressesArray;
  NSString *color;
} LightningNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_LastUpdate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LightningNode__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_PubKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LightningNode__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LightningNode__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeAddress),
        .number = LightningNode_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LightningNode__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = LightningNode_FieldNumber_Color,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LightningNode__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LightningNode class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LightningNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeAddress

@implementation NodeAddress

@dynamic network;
@dynamic addr;

typedef struct NodeAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *network;
  NSString *addr;
} NodeAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "network",
        .dataTypeSpecific.className = NULL,
        .number = NodeAddress_FieldNumber_Network,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeAddress__storage_, network),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = NodeAddress_FieldNumber_Addr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeAddress__storage_, addr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeAddress class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoutingPolicy

@implementation RoutingPolicy

@dynamic timeLockDelta;
@dynamic minHtlc;
@dynamic feeBaseMsat;
@dynamic feeRateMilliMsat;

typedef struct RoutingPolicy__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeLockDelta;
  int64_t minHtlc;
  int64_t feeBaseMsat;
  int64_t feeRateMilliMsat;
} RoutingPolicy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_TimeLockDelta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minHtlc",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_MinHtlc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, minHtlc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeBaseMsat",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_FeeBaseMsat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, feeBaseMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRateMilliMsat",
        .dataTypeSpecific.className = NULL,
        .number = RoutingPolicy_FieldNumber_FeeRateMilliMsat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RoutingPolicy__storage_, feeRateMilliMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoutingPolicy class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoutingPolicy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEdge

@implementation ChannelEdge

@dynamic channelId;
@dynamic chanPoint;
@dynamic lastUpdate;
@dynamic node1Pub;
@dynamic node2Pub;
@dynamic capacity;
@dynamic hasNode1Policy, node1Policy;
@dynamic hasNode2Policy, node2Policy;

typedef struct ChannelEdge__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastUpdate;
  NSString *chanPoint;
  NSString *node1Pub;
  NSString *node2Pub;
  RoutingPolicy *node1Policy;
  RoutingPolicy *node2Policy;
  uint64_t channelId;
  int64_t capacity;
} ChannelEdge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastUpdate",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_LastUpdate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, lastUpdate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "node1Pub",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Node1Pub,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node1Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "node2Pub",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Node2Pub,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node2Pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdge_FieldNumber_Capacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "node1Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdge_FieldNumber_Node1Policy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node1Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "node2Policy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdge_FieldNumber_Node2Policy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChannelEdge__storage_, node2Policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEdge class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelEdge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGraphRequest

@implementation ChannelGraphRequest


typedef struct ChannelGraphRequest__storage_ {
  uint32_t _has_storage_[1];
} ChannelGraphRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGraphRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ChannelGraphRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGraph

@implementation ChannelGraph

@dynamic nodesArray, nodesArray_Count;
@dynamic edgesArray, edgesArray_Count;

typedef struct ChannelGraph__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodesArray;
  NSMutableArray *edgesArray;
} ChannelGraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LightningNode),
        .number = ChannelGraph_FieldNumber_NodesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelGraph__storage_, nodesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelEdge),
        .number = ChannelGraph_FieldNumber_EdgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelGraph__storage_, edgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGraph class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelGraph__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChanInfoRequest

@implementation ChanInfoRequest

@dynamic chanId;

typedef struct ChanInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t chanId;
} ChanInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ChanInfoRequest_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChanInfoRequest__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChanInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChanInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInfoRequest

@implementation NetworkInfoRequest


typedef struct NetworkInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} NetworkInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkInfo

@implementation NetworkInfo

@dynamic graphDiameter;
@dynamic avgOutDegree;
@dynamic maxOutDegree;
@dynamic numNodes;
@dynamic numChannels;
@dynamic totalNetworkCapacity;
@dynamic avgChannelSize;
@dynamic minChannelSize;
@dynamic maxChannelSize;

typedef struct NetworkInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t graphDiameter;
  uint32_t maxOutDegree;
  uint32_t numNodes;
  uint32_t numChannels;
  double avgOutDegree;
  int64_t totalNetworkCapacity;
  double avgChannelSize;
  int64_t minChannelSize;
  int64_t maxChannelSize;
} NetworkInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "graphDiameter",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_GraphDiameter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, graphDiameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "avgOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_AvgOutDegree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, avgOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxOutDegree",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MaxOutDegree,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, maxOutDegree),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numNodes",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_NumNodes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, numNodes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numChannels",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_NumChannels,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, numChannels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalNetworkCapacity",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_TotalNetworkCapacity,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, totalNetworkCapacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "avgChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_AvgChannelSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, avgChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "minChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MinChannelSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, minChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxChannelSize",
        .dataTypeSpecific.className = NULL,
        .number = NetworkInfo_FieldNumber_MaxChannelSize,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NetworkInfo__storage_, maxChannelSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkInfo class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StopRequest

@implementation StopRequest


typedef struct StopRequest__storage_ {
  uint32_t _has_storage_[1];
} StopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(StopRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StopResponse

@implementation StopResponse


typedef struct StopResponse__storage_ {
  uint32_t _has_storage_[1];
} StopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(StopResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GraphTopologySubscription

@implementation GraphTopologySubscription


typedef struct GraphTopologySubscription__storage_ {
  uint32_t _has_storage_[1];
} GraphTopologySubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GraphTopologySubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GraphTopologySubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GraphTopologyUpdate

@implementation GraphTopologyUpdate

@dynamic nodeUpdatesArray, nodeUpdatesArray_Count;
@dynamic channelUpdatesArray, channelUpdatesArray_Count;
@dynamic closedChansArray, closedChansArray_Count;

typedef struct GraphTopologyUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nodeUpdatesArray;
  NSMutableArray *channelUpdatesArray;
  NSMutableArray *closedChansArray;
} GraphTopologyUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeUpdate),
        .number = GraphTopologyUpdate_FieldNumber_NodeUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, nodeUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelUpdatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelEdgeUpdate),
        .number = GraphTopologyUpdate_FieldNumber_ChannelUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, channelUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "closedChansArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ClosedChannelUpdate),
        .number = GraphTopologyUpdate_FieldNumber_ClosedChansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GraphTopologyUpdate__storage_, closedChansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GraphTopologyUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GraphTopologyUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeUpdate

@implementation NodeUpdate

@dynamic addressesArray, addressesArray_Count;
@dynamic identityKey;
@dynamic globalFeatures;
@dynamic alias;

typedef struct NodeUpdate__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSString *identityKey;
  NSData *globalFeatures;
  NSString *alias;
} NodeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identityKey",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_IdentityKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, identityKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "globalFeatures",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_GlobalFeatures,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, globalFeatures),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = NodeUpdate_FieldNumber_Alias,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeUpdate__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelEdgeUpdate

@implementation ChannelEdgeUpdate

@dynamic chanId;
@dynamic hasChanPoint, chanPoint;
@dynamic capacity;
@dynamic hasRoutingPolicy, routingPolicy;
@dynamic advertisingNode;
@dynamic connectingNode;

typedef struct ChannelEdgeUpdate__storage_ {
  uint32_t _has_storage_[1];
  ChannelPoint *chanPoint;
  RoutingPolicy *routingPolicy;
  NSString *advertisingNode;
  NSString *connectingNode;
  uint64_t chanId;
  int64_t capacity;
} ChannelEdgeUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ChannelEdgeUpdate_FieldNumber_ChanPoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_Capacity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "routingPolicy",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutingPolicy),
        .number = ChannelEdgeUpdate_FieldNumber_RoutingPolicy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, routingPolicy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "advertisingNode",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_AdvertisingNode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, advertisingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectingNode",
        .dataTypeSpecific.className = NULL,
        .number = ChannelEdgeUpdate_FieldNumber_ConnectingNode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelEdgeUpdate__storage_, connectingNode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelEdgeUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelEdgeUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClosedChannelUpdate

@implementation ClosedChannelUpdate

@dynamic chanId;
@dynamic capacity;
@dynamic closedHeight;
@dynamic hasChanPoint, chanPoint;

typedef struct ClosedChannelUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t closedHeight;
  ChannelPoint *chanPoint;
  uint64_t chanId;
  int64_t capacity;
} ClosedChannelUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanId",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_ChanId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, chanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "capacity",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_Capacity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, capacity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "closedHeight",
        .dataTypeSpecific.className = NULL,
        .number = ClosedChannelUpdate_FieldNumber_ClosedHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, closedHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = ClosedChannelUpdate_FieldNumber_ChanPoint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ClosedChannelUpdate__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClosedChannelUpdate class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClosedChannelUpdate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Invoice

@implementation Invoice

@dynamic memo;
@dynamic receipt;
@dynamic rPreimage;
@dynamic rHash;
@dynamic value;
@dynamic settled;
@dynamic creationDate;
@dynamic settleDate;
@dynamic paymentRequest;
@dynamic descriptionHash;
@dynamic expiry;
@dynamic fallbackAddr;
@dynamic cltvExpiry;

typedef struct Invoice__storage_ {
  uint32_t _has_storage_[1];
  NSString *memo;
  NSData *receipt;
  NSData *rPreimage;
  NSData *rHash;
  NSString *paymentRequest;
  NSData *descriptionHash;
  NSString *fallbackAddr;
  int64_t value;
  int64_t creationDate;
  int64_t settleDate;
  int64_t expiry;
  uint64_t cltvExpiry;
} Invoice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memo",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Memo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Invoice__storage_, memo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Receipt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Invoice__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rPreimage",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_RPreimage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Invoice__storage_, rPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_RHash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Invoice__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Invoice__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settled",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Settled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_CreationDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Invoice__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "settleDate",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_SettleDate,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Invoice__storage_, settleDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_PaymentRequest,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Invoice__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_DescriptionHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Invoice__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_Expiry,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Invoice__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_FallbackAddr,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Invoice__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = Invoice_FieldNumber_CltvExpiry,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Invoice__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Invoice class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Invoice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddInvoiceResponse

@implementation AddInvoiceResponse

@dynamic rHash;
@dynamic paymentRequest;

typedef struct AddInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *rHash;
  NSString *paymentRequest;
} AddInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = AddInvoiceResponse_FieldNumber_RHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddInvoiceResponse__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "paymentRequest",
        .dataTypeSpecific.className = NULL,
        .number = AddInvoiceResponse_FieldNumber_PaymentRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddInvoiceResponse__storage_, paymentRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddInvoiceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentHash

@implementation PaymentHash

@dynamic rHashStr;
@dynamic rHash;

typedef struct PaymentHash__storage_ {
  uint32_t _has_storage_[1];
  NSString *rHashStr;
  NSData *rHash;
} PaymentHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rHashStr",
        .dataTypeSpecific.className = NULL,
        .number = PaymentHash_FieldNumber_RHashStr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentHash__storage_, rHashStr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rHash",
        .dataTypeSpecific.className = NULL,
        .number = PaymentHash_FieldNumber_RHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentHash__storage_, rHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentHash class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListInvoiceRequest

@implementation ListInvoiceRequest

@dynamic pendingOnly;

typedef struct ListInvoiceRequest__storage_ {
  uint32_t _has_storage_[1];
} ListInvoiceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pendingOnly",
        .dataTypeSpecific.className = NULL,
        .number = ListInvoiceRequest_FieldNumber_PendingOnly,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListInvoiceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListInvoiceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListInvoiceResponse

@implementation ListInvoiceResponse

@dynamic invoicesArray, invoicesArray_Count;

typedef struct ListInvoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *invoicesArray;
} ListInvoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invoicesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Invoice),
        .number = ListInvoiceResponse_FieldNumber_InvoicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListInvoiceResponse__storage_, invoicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListInvoiceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListInvoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InvoiceSubscription

@implementation InvoiceSubscription


typedef struct InvoiceSubscription__storage_ {
  uint32_t _has_storage_[1];
} InvoiceSubscription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InvoiceSubscription class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(InvoiceSubscription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Payment

@implementation Payment

@dynamic paymentHash;
@dynamic value;
@dynamic creationDate;
@dynamic pathArray, pathArray_Count;
@dynamic fee;
@dynamic paymentPreimage;

typedef struct Payment__storage_ {
  uint32_t _has_storage_[1];
  NSString *paymentHash;
  NSMutableArray *pathArray;
  NSString *paymentPreimage;
  int64_t value;
  int64_t creationDate;
  int64_t fee;
} Payment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PaymentHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Payment__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Payment__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creationDate",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_CreationDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Payment__storage_, creationDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Payment__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Payment__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "paymentPreimage",
        .dataTypeSpecific.className = NULL,
        .number = Payment_FieldNumber_PaymentPreimage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Payment__storage_, paymentPreimage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Payment class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Payment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPaymentsRequest

@implementation ListPaymentsRequest


typedef struct ListPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} ListPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPaymentsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListPaymentsResponse

@implementation ListPaymentsResponse

@dynamic paymentsArray, paymentsArray_Count;

typedef struct ListPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *paymentsArray;
} ListPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Payment),
        .number = ListPaymentsResponse_FieldNumber_PaymentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListPaymentsResponse__storage_, paymentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListPaymentsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAllPaymentsRequest

@implementation DeleteAllPaymentsRequest


typedef struct DeleteAllPaymentsRequest__storage_ {
  uint32_t _has_storage_[1];
} DeleteAllPaymentsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAllPaymentsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteAllPaymentsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteAllPaymentsResponse

@implementation DeleteAllPaymentsResponse


typedef struct DeleteAllPaymentsResponse__storage_ {
  uint32_t _has_storage_[1];
} DeleteAllPaymentsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteAllPaymentsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteAllPaymentsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DebugLevelRequest

@implementation DebugLevelRequest

@dynamic show;
@dynamic levelSpec;

typedef struct DebugLevelRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *levelSpec;
} DebugLevelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "show",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelRequest_FieldNumber_Show,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "levelSpec",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelRequest_FieldNumber_LevelSpec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DebugLevelRequest__storage_, levelSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebugLevelRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebugLevelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DebugLevelResponse

@implementation DebugLevelResponse

@dynamic subSystems;

typedef struct DebugLevelResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *subSystems;
} DebugLevelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subSystems",
        .dataTypeSpecific.className = NULL,
        .number = DebugLevelResponse_FieldNumber_SubSystems,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DebugLevelResponse__storage_, subSystems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DebugLevelResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DebugLevelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayReqString

@implementation PayReqString

@dynamic payReq;

typedef struct PayReqString__storage_ {
  uint32_t _has_storage_[1];
  NSString *payReq;
} PayReqString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payReq",
        .dataTypeSpecific.className = NULL,
        .number = PayReqString_FieldNumber_PayReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayReqString__storage_, payReq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayReqString class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayReqString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayReq

@implementation PayReq

@dynamic destination;
@dynamic paymentHash;
@dynamic numSatoshis;
@dynamic timestamp;
@dynamic expiry;
@dynamic description_p;
@dynamic descriptionHash;
@dynamic fallbackAddr;
@dynamic cltvExpiry;

typedef struct PayReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *destination;
  NSString *paymentHash;
  NSString *description_p;
  NSString *descriptionHash;
  NSString *fallbackAddr;
  int64_t numSatoshis;
  int64_t timestamp;
  int64_t expiry;
  int64_t cltvExpiry;
} PayReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Destination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayReq__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paymentHash",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_PaymentHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PayReq__storage_, paymentHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numSatoshis",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_NumSatoshis,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PayReq__storage_, numSatoshis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PayReq__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Expiry,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PayReq__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_Description_p,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PayReq__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionHash",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_DescriptionHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PayReq__storage_, descriptionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fallbackAddr",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_FallbackAddr,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PayReq__storage_, fallbackAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cltvExpiry",
        .dataTypeSpecific.className = NULL,
        .number = PayReq_FieldNumber_CltvExpiry,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PayReq__storage_, cltvExpiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayReq class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeReportRequest

@implementation FeeReportRequest


typedef struct FeeReportRequest__storage_ {
  uint32_t _has_storage_[1];
} FeeReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeReportRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(FeeReportRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelFeeReport

@implementation ChannelFeeReport

@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feePerMil;
@dynamic feeRate;

typedef struct ChannelFeeReport__storage_ {
  uint32_t _has_storage_[1];
  NSString *chanPoint;
  int64_t baseFeeMsat;
  int64_t feePerMil;
  double feeRate;
} ChannelFeeReport__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_ChanPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerMil",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_FeePerMil,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, feePerMil),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = ChannelFeeReport_FieldNumber_FeeRate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelFeeReport__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelFeeReport class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelFeeReport__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeeReportResponse

@implementation FeeReportResponse

@dynamic channelFeesArray, channelFeesArray_Count;
@dynamic dayFeeSum;
@dynamic weekFeeSum;
@dynamic monthFeeSum;

typedef struct FeeReportResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelFeesArray;
  uint64_t dayFeeSum;
  uint64_t weekFeeSum;
  uint64_t monthFeeSum;
} FeeReportResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelFeesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelFeeReport),
        .number = FeeReportResponse_FieldNumber_ChannelFeesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, channelFeesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dayFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_DayFeeSum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, dayFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "weekFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_WeekFeeSum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, weekFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "monthFeeSum",
        .dataTypeSpecific.className = NULL,
        .number = FeeReportResponse_FieldNumber_MonthFeeSum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FeeReportResponse__storage_, monthFeeSum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FeeReportResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeeReportResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PolicyUpdateRequest

@implementation PolicyUpdateRequest

@dynamic scopeOneOfCase;
@dynamic global;
@dynamic chanPoint;
@dynamic baseFeeMsat;
@dynamic feeRate;
@dynamic timeLockDelta;

typedef struct PolicyUpdateRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t timeLockDelta;
  ChannelPoint *chanPoint;
  int64_t baseFeeMsat;
  double feeRate;
} PolicyUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "global",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_Global,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chanPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPoint),
        .number = PolicyUpdateRequest_FieldNumber_ChanPoint,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, chanPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseFeeMsat",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_BaseFeeMsat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, baseFeeMsat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeRate",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_FeeRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, feeRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timeLockDelta",
        .dataTypeSpecific.className = NULL,
        .number = PolicyUpdateRequest_FieldNumber_TimeLockDelta,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PolicyUpdateRequest__storage_, timeLockDelta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PolicyUpdateRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PolicyUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "scope",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void PolicyUpdateRequest_ClearScopeOneOfCase(PolicyUpdateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - PolicyUpdateResponse

@implementation PolicyUpdateResponse


typedef struct PolicyUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
} PolicyUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PolicyUpdateResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PolicyUpdateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingHistoryRequest

@implementation ForwardingHistoryRequest

@dynamic startTime;
@dynamic endTime;
@dynamic indexOffset;
@dynamic numMaxEvents;

typedef struct ForwardingHistoryRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t indexOffset;
  uint32_t numMaxEvents;
  uint64_t startTime;
  uint64_t endTime;
} ForwardingHistoryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "indexOffset",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_IndexOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, indexOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numMaxEvents",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryRequest_FieldNumber_NumMaxEvents,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ForwardingHistoryRequest__storage_, numMaxEvents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingHistoryRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingHistoryRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingEvent

@implementation ForwardingEvent

@dynamic timestamp;
@dynamic chanIdIn;
@dynamic chanIdOut;
@dynamic amtIn;
@dynamic amtOut;
@dynamic fee;

typedef struct ForwardingEvent__storage_ {
  uint32_t _has_storage_[1];
  uint64_t timestamp;
  uint64_t chanIdIn;
  uint64_t chanIdOut;
  uint64_t amtIn;
  uint64_t amtOut;
  uint64_t fee;
} ForwardingEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdIn",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_ChanIdIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, chanIdIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "chanIdOut",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_ChanIdOut,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, chanIdOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtIn",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_AmtIn,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, amtIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "amtOut",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_AmtOut,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, amtOut),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingEvent_FieldNumber_Fee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ForwardingEvent__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingEvent class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardingHistoryResponse

@implementation ForwardingHistoryResponse

@dynamic forwardingEventsArray, forwardingEventsArray_Count;
@dynamic lastOffsetIndex;

typedef struct ForwardingHistoryResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lastOffsetIndex;
  NSMutableArray *forwardingEventsArray;
} ForwardingHistoryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "forwardingEventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ForwardingEvent),
        .number = ForwardingHistoryResponse_FieldNumber_ForwardingEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ForwardingHistoryResponse__storage_, forwardingEventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastOffsetIndex",
        .dataTypeSpecific.className = NULL,
        .number = ForwardingHistoryResponse_FieldNumber_LastOffsetIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardingHistoryResponse__storage_, lastOffsetIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardingHistoryResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardingHistoryResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
