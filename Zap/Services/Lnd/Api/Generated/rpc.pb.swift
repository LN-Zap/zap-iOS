// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Lnrpc_GenSeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed.
  var aezeedPassphrase: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///seed_entropy is an optional 16-bytes generated via CSPRNG. If not
  ///specified, then a fresh set of randomness will be used to create the seed.
  var seedEntropy: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GenSeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This field is optional, as if not
  ///provided, then the daemon will generate a new cipher seed for the user.
  ///Otherwise, then the daemon will attempt to recover the wallet state linked
  ///to this cipher seed.
  var cipherSeedMnemonic: [String] = []

  ///*
  ///enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
  ///cipher text before run through our mnemonic encoding scheme.
  var encipheredSeed: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InitWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///wallet_password is the passphrase that should be used to encrypt the
  ///wallet. This MUST be at least 8 chars in length. After creation, this
  ///password is required to unlock the daemon.
  var walletPassword: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
  ///cipher seed obtained by the user. This may have been generated by the
  ///GenSeed method, or be an existing seed.
  var cipherSeedMnemonic: [String] = []

  ///*
  ///aezeed_passphrase is an optional user provided passphrase that will be used
  ///to encrypt the generated aezeed cipher seed.
  var aezeedPassphrase: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InitWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_UnlockWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///wallet_password should be the current valid passphrase for the daemon. This
  ///will be required to decrypt on-disk material that the daemon requires to
  ///function properly.
  var walletPassword: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///recovery_window is an optional argument specifying the address lookahead
  ///when restoring a wallet seed. The recovery window applies to each
  ///invdividual branch of the BIP44 derivation paths. Supplying a recovery
  ///window of zero indicates that no addresses should be recovered, such after
  ///the first initialization of the wallet.
  var recoveryWindow: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_UnlockWalletResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The transaction hash
  var txHash: String = String()

  //// The transaction ammount, denominated in satoshis
  var amount: Int64 = 0

  //// The number of confirmations
  var numConfirmations: Int32 = 0

  //// The hash of the block this transaction was included in
  var blockHash: String = String()

  //// The height of the block this transaction was included in
  var blockHeight: Int32 = 0

  //// Timestamp of this transaction 
  var timeStamp: Int64 = 0

  //// Fees paid for this transaction
  var totalFees: Int64 = 0

  //// Addresses that received funds for this transaction
  var destAddresses: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_TransactionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of transactions relevant to the wallet.
  var transactions: [Lnrpc_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the payment recipient
  var dest: Data = SwiftProtobuf.Internal.emptyData

  //// The hex-encoded identity pubkey of the payment recipient
  var destString: String = String()

  //// Number of satoshis to send. 
  var amt: Int64 = 0

  //// The hash to use within the payment's HTLC
  var paymentHash: Data = SwiftProtobuf.Internal.emptyData

  //// The hex-encoded hash to use within the payment's HTLC
  var paymentHashString: String = String()

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  //// The CLTV delta from the current height that should be used to set the timelock for the final hop.
  var finalCltvDelta: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentError: String {
    get {return _storage._paymentError}
    set {_uniqueStorage()._paymentError = newValue}
  }

  var paymentPreimage: Data {
    get {return _storage._paymentPreimage}
    set {_uniqueStorage()._paymentPreimage = newValue}
  }

  var paymentRoute: Lnrpc_Route {
    get {return _storage._paymentRoute ?? Lnrpc_Route()}
    set {_uniqueStorage()._paymentRoute = newValue}
  }
  /// Returns true if `paymentRoute` has been explicitly set.
  var hasPaymentRoute: Bool {return _storage._paymentRoute != nil}
  /// Clears the value of `paymentRoute`. Subsequent reads from it will return its default value.
  mutating func clearPaymentRoute() {_storage._paymentRoute = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fundingTxid: Lnrpc_ChannelPoint.OneOf_FundingTxid? = nil

  //// Txid of the funding transaction
  var fundingTxidBytes: Data {
    get {
      if case .fundingTxidBytes(let v)? = fundingTxid {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {fundingTxid = .fundingTxidBytes(newValue)}
  }

  //// Hex-encoded string representing the funding transaction
  var fundingTxidStr: String {
    get {
      if case .fundingTxidStr(let v)? = fundingTxid {return v}
      return String()
    }
    set {fundingTxid = .fundingTxidStr(newValue)}
  }

  //// The index of the output of the funding transaction
  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_FundingTxid: Equatable {
    //// Txid of the funding transaction
    case fundingTxidBytes(Data)
    //// Hex-encoded string representing the funding transaction
    case fundingTxidStr(String)

    static func ==(lhs: Lnrpc_ChannelPoint.OneOf_FundingTxid, rhs: Lnrpc_ChannelPoint.OneOf_FundingTxid) -> Bool {
      switch (lhs, rhs) {
      case (.fundingTxidBytes(let l), .fundingTxidBytes(let r)): return l == r
      case (.fundingTxidStr(let l), .fundingTxidStr(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}
}

struct Lnrpc_LightningAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the Lightning node
  var pubkey: String = String()

  //// The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
  var host: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The map from addresses to amounts
  var addrToAmount: Dictionary<String,Int64> = [:]

  //// The target number of blocks that this transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
  var satPerByte: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendManyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The id of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The address to send coins to 
  var addr: String = String()

  //// The amount in satoshis to send
  var amount: Int64 = 0

  //// The target number of blocks that this transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the transaction.
  var satPerByte: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SendCoinsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The transaction ID of the transaction
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///* 
///`AddressType` has to be one of:
///
///- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
///- `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
///- `p2pkh`:  Pay to public key hash (`PUBKEY_HASH` = 2)
struct Lnrpc_NewAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The address type
  var type: Lnrpc_NewAddressRequest.AddressType = .witnessPubkeyHash

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AddressType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case witnessPubkeyHash // = 0
    case nestedPubkeyHash // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .witnessPubkeyHash
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .witnessPubkeyHash
      case 1: self = .nestedPubkeyHash
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .witnessPubkeyHash: return 0
      case .nestedPubkeyHash: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Lnrpc_NewWitnessAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NewAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The newly generated wallet address
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The message to be signed
  var msg: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_SignMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The signature for the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The message over which the signature is to be verified
  var msg: Data = SwiftProtobuf.Internal.emptyData

  //// The signature to be verified over the given message
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_VerifyMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Whether the signature was valid over the given message
  var valid: Bool = false

  //// The pubkey recovered from the signature
  var pubkey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Lightning address of the peer, in the format `<pubkey>@host`
  var addr: Lnrpc_LightningAddress {
    get {return _storage._addr ?? Lnrpc_LightningAddress()}
    set {_uniqueStorage()._addr = newValue}
  }
  /// Returns true if `addr` has been explicitly set.
  var hasAddr: Bool {return _storage._addr != nil}
  /// Clears the value of `addr`. Subsequent reads from it will return its default value.
  mutating func clearAddr() {_storage._addr = nil}

  ///* If set, the daemon will attempt to persistently connect to the target
  /// peer.  Otherwise, the call will be synchronous. 
  var perm: Bool {
    get {return _storage._perm}
    set {_uniqueStorage()._perm = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ConnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The pubkey of the node to disconnect from
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DisconnectPeerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_HTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var incoming: Bool = false

  var amount: Int64 = 0

  var hashLock: Data = SwiftProtobuf.Internal.emptyData

  var expirationHeight: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Whether this channel is active or not
  var active: Bool {
    get {return _storage._active}
    set {_uniqueStorage()._active = newValue}
  }

  //// The identity pubkey of the remote node
  var remotePubkey: String {
    get {return _storage._remotePubkey}
    set {_uniqueStorage()._remotePubkey = newValue}
  }

  ///*
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: String {
    get {return _storage._channelPoint}
    set {_uniqueStorage()._channelPoint = newValue}
  }

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get {return _storage._chanID}
    set {_uniqueStorage()._chanID = newValue}
  }

  //// The total amount of funds held in this channel
  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  //// This node's current balance in this channel
  var localBalance: Int64 {
    get {return _storage._localBalance}
    set {_uniqueStorage()._localBalance = newValue}
  }

  //// The counterparty's current balance in this channel
  var remoteBalance: Int64 {
    get {return _storage._remoteBalance}
    set {_uniqueStorage()._remoteBalance = newValue}
  }

  ///*
  ///The amount calculated to be paid in fees for the current set of commitment
  ///transactions. The fee amount is persisted with the channel in order to
  ///allow the fee amount to be removed and recalculated with each channel state
  ///update, including updates that happen after a system restart.
  var commitFee: Int64 {
    get {return _storage._commitFee}
    set {_uniqueStorage()._commitFee = newValue}
  }

  //// The weight of the commitment transaction
  var commitWeight: Int64 {
    get {return _storage._commitWeight}
    set {_uniqueStorage()._commitWeight = newValue}
  }

  ///*
  ///The required number of satoshis per kilo-weight that the requester will pay
  ///at all times, for both the funding transaction and commitment transaction.
  ///This value can later be updated once the channel is open.
  var feePerKw: Int64 {
    get {return _storage._feePerKw}
    set {_uniqueStorage()._feePerKw = newValue}
  }

  //// The unsettled balance in this channel
  var unsettledBalance: Int64 {
    get {return _storage._unsettledBalance}
    set {_uniqueStorage()._unsettledBalance = newValue}
  }

  ///*
  ///The total number of satoshis we've sent within this channel.
  var totalSatoshisSent: Int64 {
    get {return _storage._totalSatoshisSent}
    set {_uniqueStorage()._totalSatoshisSent = newValue}
  }

  ///*
  ///The total number of satoshis we've received within this channel.
  var totalSatoshisReceived: Int64 {
    get {return _storage._totalSatoshisReceived}
    set {_uniqueStorage()._totalSatoshisReceived = newValue}
  }

  ///*
  ///The total number of updates conducted within this channel.
  var numUpdates: UInt64 {
    get {return _storage._numUpdates}
    set {_uniqueStorage()._numUpdates = newValue}
  }

  ///*
  ///The list of active, uncleared HTLCs currently pending within the channel.
  var pendingHtlcs: [Lnrpc_HTLC] {
    get {return _storage._pendingHtlcs}
    set {_uniqueStorage()._pendingHtlcs = newValue}
  }

  ///*
  ///The CSV delay expressed in relative blocks. If the channel is force
  ///closed, we'll need to wait for this many blocks before we can regain our
  ///funds.
  var csvDelay: UInt32 {
    get {return _storage._csvDelay}
    set {_uniqueStorage()._csvDelay = newValue}
  }

  //// Whether this channel is advertised to the network or not
  var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ListChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeOnly: Bool = false

  var inactiveOnly: Bool = false

  var publicOnly: Bool = false

  var privateOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of active channels
  var channels: [Lnrpc_Channel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Peer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the peer
  var pubKey: String = String()

  //// Network address of the peer; eg `127.0.0.1:10011`
  var address: String = String()

  //// Bytes of data transmitted to this peer
  var bytesSent: UInt64 = 0

  //// Bytes of data transmitted from this peer
  var bytesRecv: UInt64 = 0

  //// Satoshis sent to this peer
  var satSent: Int64 = 0

  //// Satoshis received from this peer
  var satRecv: Int64 = 0

  //// A channel is inbound if the counterparty initiated the channel
  var inbound: Bool = false

  //// Ping time to this peer
  var pingTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPeersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPeersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of currently connected peers
  var peers: [Lnrpc_Peer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GetInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The identity pubkey of the current node.
  var identityPubkey: String = String()

  //// If applicable, the alias of the current node, e.g. "bob"
  var alias: String = String()

  //// Number of pending channels
  var numPendingChannels: UInt32 = 0

  //// Number of active channels
  var numActiveChannels: UInt32 = 0

  //// Number of peers
  var numPeers: UInt32 = 0

  //// The node's current view of the height of the best block
  var blockHeight: UInt32 = 0

  //// The node's current view of the hash of the best block
  var blockHash: String = String()

  //// Whether the wallet's view is synced to the main chain
  var syncedToChain: Bool = false

  //// Whether the current node is connected to testnet
  var testnet: Bool = false

  //// A list of active chains the node is connected to
  var chains: [String] = []

  //// The URIs of the current node.
  var uris: [String] = []

  //// Timestamp of the block best known to the wallet
  var bestHeaderTimestamp: Int64 = 0

  //// The version of the LND software that the node is running.
  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ConfirmationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockSha: Data = SwiftProtobuf.Internal.emptyData

  var blockHeight: Int32 = 0

  var numConfsLeft: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelOpenUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPoint: Lnrpc_ChannelPoint {
    get {return _storage._channelPoint ?? Lnrpc_ChannelPoint()}
    set {_uniqueStorage()._channelPoint = newValue}
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool {return _storage._channelPoint != nil}
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() {_storage._channelPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelCloseUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closingTxid: Data = SwiftProtobuf.Internal.emptyData

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_CloseChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The outpoint (txid:index) of the funding transaction. With this value, Bob
  ///will be able to generate a signature for Alice's version of the commitment
  ///transaction.
  var channelPoint: Lnrpc_ChannelPoint {
    get {return _storage._channelPoint ?? Lnrpc_ChannelPoint()}
    set {_uniqueStorage()._channelPoint = newValue}
  }
  /// Returns true if `channelPoint` has been explicitly set.
  var hasChannelPoint: Bool {return _storage._channelPoint != nil}
  /// Clears the value of `channelPoint`. Subsequent reads from it will return its default value.
  mutating func clearChannelPoint() {_storage._channelPoint = nil}

  //// If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
  var force: Bool {
    get {return _storage._force}
    set {_uniqueStorage()._force = newValue}
  }

  //// The target number of blocks that the closure transaction should be confirmed by.
  var targetConf: Int32 {
    get {return _storage._targetConf}
    set {_uniqueStorage()._targetConf = newValue}
  }

  //// A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
  var satPerByte: Int64 {
    get {return _storage._satPerByte}
    set {_uniqueStorage()._satPerByte = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_CloseStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: OneOf_Update? {
    get {return _storage._update}
    set {_uniqueStorage()._update = newValue}
  }

  var closePending: Lnrpc_PendingUpdate {
    get {
      if case .closePending(let v)? = _storage._update {return v}
      return Lnrpc_PendingUpdate()
    }
    set {_uniqueStorage()._update = .closePending(newValue)}
  }

  var confirmation: Lnrpc_ConfirmationUpdate {
    get {
      if case .confirmation(let v)? = _storage._update {return v}
      return Lnrpc_ConfirmationUpdate()
    }
    set {_uniqueStorage()._update = .confirmation(newValue)}
  }

  var chanClose: Lnrpc_ChannelCloseUpdate {
    get {
      if case .chanClose(let v)? = _storage._update {return v}
      return Lnrpc_ChannelCloseUpdate()
    }
    set {_uniqueStorage()._update = .chanClose(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case closePending(Lnrpc_PendingUpdate)
    case confirmation(Lnrpc_ConfirmationUpdate)
    case chanClose(Lnrpc_ChannelCloseUpdate)

    static func ==(lhs: Lnrpc_CloseStatusUpdate.OneOf_Update, rhs: Lnrpc_CloseStatusUpdate.OneOf_Update) -> Bool {
      switch (lhs, rhs) {
      case (.closePending(let l), .closePending(let r)): return l == r
      case (.confirmation(let l), .confirmation(let r)): return l == r
      case (.chanClose(let l), .chanClose(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PendingUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = SwiftProtobuf.Internal.emptyData

  var outputIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_OpenChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The pubkey of the node to open a channel with
  var nodePubkey: Data = SwiftProtobuf.Internal.emptyData

  //// The hex encoded pubkey of the node to open a channel with 
  var nodePubkeyString: String = String()

  //// The number of satoshis the wallet should commit to the channel
  var localFundingAmount: Int64 = 0

  //// The number of satoshis to push to the remote side as part of the initial commitment state
  var pushSat: Int64 = 0

  //// The target number of blocks that the funding transaction should be confirmed by.
  var targetConf: Int32 = 0

  //// A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
  var satPerByte: Int64 = 0

  //// Whether this channel should be private, not announced to the greater network.
  var `private`: Bool = false

  //// The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
  var minHtlcMsat: Int64 = 0

  //// The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
  var remoteCsvDelay: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_OpenStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var update: OneOf_Update? {
    get {return _storage._update}
    set {_uniqueStorage()._update = newValue}
  }

  var chanPending: Lnrpc_PendingUpdate {
    get {
      if case .chanPending(let v)? = _storage._update {return v}
      return Lnrpc_PendingUpdate()
    }
    set {_uniqueStorage()._update = .chanPending(newValue)}
  }

  var confirmation: Lnrpc_ConfirmationUpdate {
    get {
      if case .confirmation(let v)? = _storage._update {return v}
      return Lnrpc_ConfirmationUpdate()
    }
    set {_uniqueStorage()._update = .confirmation(newValue)}
  }

  var chanOpen: Lnrpc_ChannelOpenUpdate {
    get {
      if case .chanOpen(let v)? = _storage._update {return v}
      return Lnrpc_ChannelOpenUpdate()
    }
    set {_uniqueStorage()._update = .chanOpen(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case chanPending(Lnrpc_PendingUpdate)
    case confirmation(Lnrpc_ConfirmationUpdate)
    case chanOpen(Lnrpc_ChannelOpenUpdate)

    static func ==(lhs: Lnrpc_OpenStatusUpdate.OneOf_Update, rhs: Lnrpc_OpenStatusUpdate.OneOf_Update) -> Bool {
      switch (lhs, rhs) {
      case (.chanPending(let l), .chanPending(let r)): return l == r
      case (.confirmation(let l), .confirmation(let r)): return l == r
      case (.chanOpen(let l), .chanOpen(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PendingHTLC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The direction within the channel that the htlc was sent
  var incoming: Bool = false

  //// The total value of the htlc
  var amount: Int64 = 0

  //// The final output to be swept back to the user's wallet
  var outpoint: String = String()

  //// The next block height at which we can spend the current stage
  var maturityHeight: UInt32 = 0

  ///*
  ///The number of blocks remaining until the current stage can be swept.
  ///Negative values indicate how many blocks have passed since becoming
  ///mature.
  var blocksTilMaturity: Int32 = 0

  //// Indicates whether the htlc is in its first or second stage of recovery
  var stage: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PendingChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The balance in satoshis encumbered in pending channels
  var totalLimboBalance: Int64 = 0

  //// Channels pending opening
  var pendingOpenChannels: [Lnrpc_PendingChannelsResponse.PendingOpenChannel] = []

  //// Channels pending closing
  var pendingClosingChannels: [Lnrpc_PendingChannelsResponse.ClosedChannel] = []

  //// Channels pending force closing
  var pendingForceClosingChannels: [Lnrpc_PendingChannelsResponse.ForceClosedChannel] = []

  //// Channels waiting for closing tx to confirm
  var waitingCloseChannels: [Lnrpc_PendingChannelsResponse.WaitingCloseChannel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PendingChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var remoteNodePub: String = String()

    var channelPoint: String = String()

    var capacity: Int64 = 0

    var localBalance: Int64 = 0

    var remoteBalance: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PendingOpenChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_storage._channel = nil}

    //// The height at which this channel will be confirmed
    var confirmationHeight: UInt32 {
      get {return _storage._confirmationHeight}
      set {_uniqueStorage()._confirmationHeight = newValue}
    }

    ///*
    ///The amount calculated to be paid in fees for the current set of
    ///commitment transactions. The fee amount is persisted with the channel
    ///in order to allow the fee amount to be removed and recalculated with
    ///each channel state update, including updates that happen after a system
    ///restart.
    var commitFee: Int64 {
      get {return _storage._commitFee}
      set {_uniqueStorage()._commitFee = newValue}
    }

    //// The weight of the commitment transaction
    var commitWeight: Int64 {
      get {return _storage._commitWeight}
      set {_uniqueStorage()._commitWeight = newValue}
    }

    ///*
    ///The required number of satoshis per kilo-weight that the requester will
    ///pay at all times, for both the funding transaction and commitment
    ///transaction. This value can later be updated once the channel is open.
    var feePerKw: Int64 {
      get {return _storage._feePerKw}
      set {_uniqueStorage()._feePerKw = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct WaitingCloseChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel waiting for closing tx to confirm
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_storage._channel = nil}

    //// The balance in satoshis encumbered in this channel
    var limboBalance: Int64 {
      get {return _storage._limboBalance}
      set {_uniqueStorage()._limboBalance = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel to be closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_storage._channel = nil}

    //// The transaction id of the closing transaction
    var closingTxid: String {
      get {return _storage._closingTxid}
      set {_uniqueStorage()._closingTxid = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ForceClosedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    //// The pending channel to be force closed
    var channel: Lnrpc_PendingChannelsResponse.PendingChannel {
      get {return _storage._channel ?? Lnrpc_PendingChannelsResponse.PendingChannel()}
      set {_uniqueStorage()._channel = newValue}
    }
    /// Returns true if `channel` has been explicitly set.
    var hasChannel: Bool {return _storage._channel != nil}
    /// Clears the value of `channel`. Subsequent reads from it will return its default value.
    mutating func clearChannel() {_storage._channel = nil}

    //// The transaction id of the closing transaction
    var closingTxid: String {
      get {return _storage._closingTxid}
      set {_uniqueStorage()._closingTxid = newValue}
    }

    //// The balance in satoshis encumbered in this pending channel
    var limboBalance: Int64 {
      get {return _storage._limboBalance}
      set {_uniqueStorage()._limboBalance = newValue}
    }

    //// The height at which funds can be sweeped into the wallet
    var maturityHeight: UInt32 {
      get {return _storage._maturityHeight}
      set {_uniqueStorage()._maturityHeight = newValue}
    }

    ///
    ///Remaining # of blocks until the commitment output can be swept.
    ///Negative values indicate how many blocks have passed since becoming
    ///mature.
    var blocksTilMaturity: Int32 {
      get {return _storage._blocksTilMaturity}
      set {_uniqueStorage()._blocksTilMaturity = newValue}
    }

    //// The total value of funds successfully recovered from this channel
    var recoveredBalance: Int64 {
      get {return _storage._recoveredBalance}
      set {_uniqueStorage()._recoveredBalance = newValue}
    }

    var pendingHtlcs: [Lnrpc_PendingHTLC] {
      get {return _storage._pendingHtlcs}
      set {_uniqueStorage()._pendingHtlcs = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Lnrpc_WalletBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_WalletBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The balance of the wallet
  var totalBalance: Int64 = 0

  //// The confirmed balance of a wallet(with >= 1 confirmations)
  var confirmedBalance: Int64 = 0

  //// The unconfirmed balance of a wallet(with 0 confirmations)
  var unconfirmedBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelBalanceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Sum of channels balances denominated in satoshis
  var balance: Int64 = 0

  //// Sum of channels pending balances denominated in satoshis
  var pendingOpenBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_QueryRoutesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The 33-byte hex-encoded public key for the payment destination
  var pubKey: String = String()

  //// The amount to send expressed in satoshis
  var amt: Int64 = 0

  //// The max number of routes to return.
  var numRoutes: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_QueryRoutesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routes: [Lnrpc_Route] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Hop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var chanCapacity: Int64 = 0

  var amtToForward: Int64 = 0

  var fee: Int64 = 0

  var expiry: UInt32 = 0

  var amtToForwardMsat: Int64 = 0

  var feeMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///A path through the channel graph which runs over one or more channels in
///succession. This struct carries all the information required to craft the
///Sphinx onion packet, and send the payment along the first hop in the path. A
///route is only selected as valid if all the channels have sufficient capacity to
///carry the initial payment amount after fees are accounted for.
struct Lnrpc_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The cumulative (final) time lock across the entire route.  This is the CLTV
  ///value that should be extended to the first hop in the route. All other hops
  ///will decrement the time-lock as advertised, leaving enough time for all
  ///hops to wait for or present the payment preimage to complete the payment.
  var totalTimeLock: UInt32 = 0

  ///*
  ///The sum of the fees paid at each hop within the final route.  In the case
  ///of a one-hop payment, this value will be zero as we don't need to pay a fee
  ///it ourself.
  var totalFees: Int64 = 0

  ///*
  ///The total amount of funds required to complete a payment over this route.
  ///This value includes the cumulative fees at each hop. As a result, the HTLC
  ///extended to the first-hop in the route will need to have at least this many
  ///satoshis, otherwise the route will fail at an intermediate node due to an
  ///insufficient amount of fees.
  var totalAmt: Int64 = 0

  ///*
  ///Contains details concerning the specific forwarding details at each hop.
  var hops: [Lnrpc_Hop] = []

  ///*
  ///The total fees in millisatoshis.
  var totalFeesMsat: Int64 = 0

  ///*
  ///The total amount in millisatoshis.
  var totalAmtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The 33-byte hex-encoded compressed public of the target node 
  var pubKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///An individual vertex/node within the channel graph. A node is
  ///connected to other nodes by one or more channel edges emanating from it. As
  ///the graph is directed, a node will also have an incoming edge attached to
  ///it for each outgoing edge.
  var node: Lnrpc_LightningNode {
    get {return _storage._node ?? Lnrpc_LightningNode()}
    set {_uniqueStorage()._node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool {return _storage._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() {_storage._node = nil}

  var numChannels: UInt32 {
    get {return _storage._numChannels}
    set {_uniqueStorage()._numChannels = newValue}
  }

  var totalCapacity: Int64 {
    get {return _storage._totalCapacity}
    set {_uniqueStorage()._totalCapacity = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
///An individual vertex/node within the channel graph. A node is
///connected to other nodes by one or more channel edges emanating from it. As the
///graph is directed, a node will also have an incoming edge attached to it for
///each outgoing edge.
struct Lnrpc_LightningNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdate: UInt32 = 0

  var pubKey: String = String()

  var alias: String = String()

  var addresses: [Lnrpc_NodeAddress] = []

  var color: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RoutingPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeLockDelta: UInt32 = 0

  var minHtlc: Int64 = 0

  var feeBaseMsat: Int64 = 0

  var feeRateMilliMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///A fully authenticated channel along with all its unique attributes.
///Once an authenticated channel announcement has been processed on the network,
///then an instance of ChannelEdgeInfo encapsulating the channels attributes is
///stored. The other portions relevant to routing policy of a channel are stored
///within a ChannelEdgePolicy for each direction of the channel.
struct Lnrpc_ChannelEdge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var channelID: UInt64 {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  var chanPoint: String {
    get {return _storage._chanPoint}
    set {_uniqueStorage()._chanPoint = newValue}
  }

  var lastUpdate: UInt32 {
    get {return _storage._lastUpdate}
    set {_uniqueStorage()._lastUpdate = newValue}
  }

  var node1Pub: String {
    get {return _storage._node1Pub}
    set {_uniqueStorage()._node1Pub = newValue}
  }

  var node2Pub: String {
    get {return _storage._node2Pub}
    set {_uniqueStorage()._node2Pub = newValue}
  }

  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  var node1Policy: Lnrpc_RoutingPolicy {
    get {return _storage._node1Policy ?? Lnrpc_RoutingPolicy()}
    set {_uniqueStorage()._node1Policy = newValue}
  }
  /// Returns true if `node1Policy` has been explicitly set.
  var hasNode1Policy: Bool {return _storage._node1Policy != nil}
  /// Clears the value of `node1Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode1Policy() {_storage._node1Policy = nil}

  var node2Policy: Lnrpc_RoutingPolicy {
    get {return _storage._node2Policy ?? Lnrpc_RoutingPolicy()}
    set {_uniqueStorage()._node2Policy = newValue}
  }
  /// Returns true if `node2Policy` has been explicitly set.
  var hasNode2Policy: Bool {return _storage._node2Policy != nil}
  /// Clears the value of `node2Policy`. Subsequent reads from it will return its default value.
  mutating func clearNode2Policy() {_storage._node2Policy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ChannelGraphRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

//// Returns a new instance of the directed channel graph.
struct Lnrpc_ChannelGraph {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of `LightningNode`s in this channel graph
  var nodes: [Lnrpc_LightningNode] = []

  //// The list of `ChannelEdge`s in this channel graph
  var edges: [Lnrpc_ChannelEdge] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChanInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var graphDiameter: UInt32 = 0

  var avgOutDegree: Double = 0

  var maxOutDegree: UInt32 = 0

  var numNodes: UInt32 = 0

  var numChannels: UInt32 = 0

  var totalNetworkCapacity: Int64 = 0

  var avgChannelSize: Double = 0

  var minChannelSize: Int64 = 0

  var maxChannelSize: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_StopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologySubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_GraphTopologyUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeUpdates: [Lnrpc_NodeUpdate] = []

  var channelUpdates: [Lnrpc_ChannelEdgeUpdate] = []

  var closedChans: [Lnrpc_ClosedChannelUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_NodeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addresses: [String] = []

  var identityKey: String = String()

  var globalFeatures: Data = SwiftProtobuf.Internal.emptyData

  var alias: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelEdgeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get {return _storage._chanID}
    set {_uniqueStorage()._chanID = newValue}
  }

  var chanPoint: Lnrpc_ChannelPoint {
    get {return _storage._chanPoint ?? Lnrpc_ChannelPoint()}
    set {_uniqueStorage()._chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return _storage._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {_storage._chanPoint = nil}

  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  var routingPolicy: Lnrpc_RoutingPolicy {
    get {return _storage._routingPolicy ?? Lnrpc_RoutingPolicy()}
    set {_uniqueStorage()._routingPolicy = newValue}
  }
  /// Returns true if `routingPolicy` has been explicitly set.
  var hasRoutingPolicy: Bool {return _storage._routingPolicy != nil}
  /// Clears the value of `routingPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRoutingPolicy() {_storage._routingPolicy = nil}

  var advertisingNode: String {
    get {return _storage._advertisingNode}
    set {_uniqueStorage()._advertisingNode = newValue}
  }

  var connectingNode: String {
    get {return _storage._connectingNode}
    set {_uniqueStorage()._connectingNode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_ClosedChannelUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The unique channel ID for the channel. The first 3 bytes are the block
  ///height, the next 3 the index within the block, and the last 2 bytes are the
  ///output index for the channel.
  var chanID: UInt64 {
    get {return _storage._chanID}
    set {_uniqueStorage()._chanID = newValue}
  }

  var capacity: Int64 {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  var closedHeight: UInt32 {
    get {return _storage._closedHeight}
    set {_uniqueStorage()._closedHeight = newValue}
  }

  var chanPoint: Lnrpc_ChannelPoint {
    get {return _storage._chanPoint ?? Lnrpc_ChannelPoint()}
    set {_uniqueStorage()._chanPoint = newValue}
  }
  /// Returns true if `chanPoint` has been explicitly set.
  var hasChanPoint: Bool {return _storage._chanPoint != nil}
  /// Clears the value of `chanPoint`. Subsequent reads from it will return its default value.
  mutating func clearChanPoint() {_storage._chanPoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_HopHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The public key of the node at the start of the channel.
  var nodeID: String = String()

  //// The unique identifier of the channel.
  var chanID: UInt64 = 0

  //// The base fee of the channel denominated in millisatoshis.
  var feeBaseMsat: UInt32 = 0

  ///*
  ///The fee rate of the channel for sending one satoshi across it denominated in
  ///millionths of a satoshi.
  var feeProportionalMillionths: UInt32 = 0

  //// The time-lock delta of the channel.
  var cltvExpiryDelta: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_RouteHint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///A list of hop hints that when chained together can assist in reaching a
  ///specific destination.
  var hopHints: [Lnrpc_HopHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Invoice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///An optional memo to attach along with the invoice. Used for record keeping
  ///purposes for the invoice's creator, and will also be set in the description
  ///field of the encoded payment request if the description_hash field is not
  ///being used.
  var memo: String = String()

  //// An optional cryptographic receipt of payment
  var receipt: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///The hex-encoded preimage (32 byte) which will allow settling an incoming
  ///HTLC payable to this preimage
  var rPreimage: Data = SwiftProtobuf.Internal.emptyData

  //// The hash of the preimage
  var rHash: Data = SwiftProtobuf.Internal.emptyData

  //// The value of this invoice in satoshis
  var value: Int64 = 0

  //// Whether this invoice has been fulfilled
  var settled: Bool = false

  //// When this invoice was created
  var creationDate: Int64 = 0

  //// When this invoice was settled
  var settleDate: Int64 = 0

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  ///*
  ///Hash (SHA-256) of a description of the payment. Used if the description of
  ///payment (memo) is too long to naturally fit within the description field
  ///of an encoded payment request.
  var descriptionHash: Data = SwiftProtobuf.Internal.emptyData

  //// Payment request expiry time in seconds. Default is 3600 (1 hour).
  var expiry: Int64 = 0

  //// Fallback on-chain address.
  var fallbackAddr: String = String()

  //// Delta to use for the time-lock of the CLTV extended to the final hop.
  var cltvExpiry: UInt64 = 0

  ///*
  ///Route hints that can each be individually used to assist in reaching the
  ///invoice's destination.
  var routeHints: [Lnrpc_RouteHint] = []

  //// Whether this invoice should include routing hints for private channels.
  var `private`: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_AddInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rHash: Data = SwiftProtobuf.Internal.emptyData

  ///*
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient.
  var paymentRequest: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PaymentHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The hex-encoded payment hash of the invoice to be looked up. The passed
  ///payment hash must be exactly 32 bytes, otherwise an error is returned.
  var rHashStr: String = String()

  //// The payment hash of the invoice to be looked up.
  var rHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Toggles if all invoices should be returned, or only those that are currently unsettled.
  var pendingOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListInvoiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invoices: [Lnrpc_Invoice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_InvoiceSubscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment hash
  var paymentHash: String = String()

  //// The value of the payment in satoshis
  var value: Int64 = 0

  //// The date of this payment
  var creationDate: Int64 = 0

  //// The path this payment took
  var path: [String] = []

  //// The fee paid for this payment in satoshis
  var fee: Int64 = 0

  //// The payment preimage
  var paymentPreimage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ListPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The list of payments
  var payments: [Lnrpc_Payment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DeleteAllPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var show: Bool = false

  var levelSpec: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_DebugLevelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subSystems: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReqString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The payment request string to be decoded
  var payReq: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PayReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String = String()

  var paymentHash: String = String()

  var numSatoshis: Int64 = 0

  var timestamp: Int64 = 0

  var expiry: Int64 = 0

  var description_p: String = String()

  var descriptionHash: String = String()

  var fallbackAddr: String = String()

  var cltvExpiry: Int64 = 0

  var routeHints: [Lnrpc_RouteHint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ChannelFeeReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The channel that this fee report belongs to.
  var chanPoint: String = String()

  //// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 = 0

  //// The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
  var feePerMil: Int64 = 0

  //// The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
  var feeRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_FeeReportResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// An array of channel fee reports which describes the current fee schedule for each channel.
  var channelFees: [Lnrpc_ChannelFeeReport] = []

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
  var dayFeeSum: UInt64 = 0

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
  var weekFeeSum: UInt64 = 0

  //// The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
  var monthFeeSum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_PolicyUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: OneOf_Scope? {
    get {return _storage._scope}
    set {_uniqueStorage()._scope = newValue}
  }

  //// If set, then this update applies to all currently active channels.
  var global: Bool {
    get {
      if case .global(let v)? = _storage._scope {return v}
      return false
    }
    set {_uniqueStorage()._scope = .global(newValue)}
  }

  //// If set, this update will target a specific channel.
  var chanPoint: Lnrpc_ChannelPoint {
    get {
      if case .chanPoint(let v)? = _storage._scope {return v}
      return Lnrpc_ChannelPoint()
    }
    set {_uniqueStorage()._scope = .chanPoint(newValue)}
  }

  //// The base fee charged regardless of the number of milli-satoshis sent.
  var baseFeeMsat: Int64 {
    get {return _storage._baseFeeMsat}
    set {_uniqueStorage()._baseFeeMsat = newValue}
  }

  //// The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
  var feeRate: Double {
    get {return _storage._feeRate}
    set {_uniqueStorage()._feeRate = newValue}
  }

  //// The required timelock delta for HTLCs forwarded over the channel.
  var timeLockDelta: UInt32 {
    get {return _storage._timeLockDelta}
    set {_uniqueStorage()._timeLockDelta = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Scope: Equatable {
    //// If set, then this update applies to all currently active channels.
    case global(Bool)
    //// If set, this update will target a specific channel.
    case chanPoint(Lnrpc_ChannelPoint)

    static func ==(lhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope, rhs: Lnrpc_PolicyUpdateRequest.OneOf_Scope) -> Bool {
      switch (lhs, rhs) {
      case (.global(let l), .global(let r)): return l == r
      case (.chanPoint(let l), .chanPoint(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Lnrpc_PolicyUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
  var startTime: UInt64 = 0

  //// End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
  var endTime: UInt64 = 0

  //// Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
  var indexOffset: UInt32 = 0

  //// The max number of events to return in the response to this query.
  var numMaxEvents: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Timestamp is the time (unix epoch offset) that this circuit was completed.
  var timestamp: UInt64 = 0

  //// The incoming channel ID that carried the HTLC that created the circuit.
  var chanIDIn: UInt64 = 0

  //// The outgoing channel ID that carried the preimage that completed the circuit.
  var chanIDOut: UInt64 = 0

  //// The total amount of the incoming HTLC that created half the circuit.
  var amtIn: UInt64 = 0

  //// The total amount of the outgoign HTLC that created the second half of the circuit.
  var amtOut: UInt64 = 0

  //// The total fee that this payment circuit carried.
  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lnrpc_ForwardingHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of forwarding events from the time slice of the time series specified in the request.
  var forwardingEvents: [Lnrpc_ForwardingEvent] = []

  //// The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
  var lastOffsetIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lnrpc"

extension Lnrpc_GenSeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aezeed_passphrase"),
    2: .standard(proto: "seed_entropy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.aezeedPassphrase)
      case 2: try decoder.decodeSingularBytesField(value: &self.seedEntropy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aezeedPassphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.aezeedPassphrase, fieldNumber: 1)
    }
    if !self.seedEntropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.seedEntropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GenSeedRequest) -> Bool {
    if self.aezeedPassphrase != other.aezeedPassphrase {return false}
    if self.seedEntropy != other.seedEntropy {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GenSeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenSeedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cipher_seed_mnemonic"),
    2: .standard(proto: "enciphered_seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.cipherSeedMnemonic)
      case 2: try decoder.decodeSingularBytesField(value: &self.encipheredSeed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cipherSeedMnemonic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSeedMnemonic, fieldNumber: 1)
    }
    if !self.encipheredSeed.isEmpty {
      try visitor.visitSingularBytesField(value: self.encipheredSeed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GenSeedResponse) -> Bool {
    if self.cipherSeedMnemonic != other.cipherSeedMnemonic {return false}
    if self.encipheredSeed != other.encipheredSeed {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InitWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "cipher_seed_mnemonic"),
    3: .standard(proto: "aezeed_passphrase"),
    4: .standard(proto: "recovery_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.walletPassword)
      case 2: try decoder.decodeRepeatedStringField(value: &self.cipherSeedMnemonic)
      case 3: try decoder.decodeSingularBytesField(value: &self.aezeedPassphrase)
      case 4: try decoder.decodeSingularInt32Field(value: &self.recoveryWindow)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.walletPassword, fieldNumber: 1)
    }
    if !self.cipherSeedMnemonic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSeedMnemonic, fieldNumber: 2)
    }
    if !self.aezeedPassphrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.aezeedPassphrase, fieldNumber: 3)
    }
    if self.recoveryWindow != 0 {
      try visitor.visitSingularInt32Field(value: self.recoveryWindow, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_InitWalletRequest) -> Bool {
    if self.walletPassword != other.walletPassword {return false}
    if self.cipherSeedMnemonic != other.cipherSeedMnemonic {return false}
    if self.aezeedPassphrase != other.aezeedPassphrase {return false}
    if self.recoveryWindow != other.recoveryWindow {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InitWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitWalletResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_InitWalletResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_UnlockWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_password"),
    2: .standard(proto: "recovery_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.walletPassword)
      case 2: try decoder.decodeSingularInt32Field(value: &self.recoveryWindow)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.walletPassword, fieldNumber: 1)
    }
    if self.recoveryWindow != 0 {
      try visitor.visitSingularInt32Field(value: self.recoveryWindow, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_UnlockWalletRequest) -> Bool {
    if self.walletPassword != other.walletPassword {return false}
    if self.recoveryWindow != other.recoveryWindow {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_UnlockWalletResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlockWalletResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_UnlockWalletResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx_hash"),
    2: .same(proto: "amount"),
    3: .same(proto: "num_confirmations"),
    4: .same(proto: "block_hash"),
    5: .same(proto: "block_height"),
    6: .same(proto: "time_stamp"),
    7: .same(proto: "total_fees"),
    8: .same(proto: "dest_addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txHash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.numConfirmations)
      case 4: try decoder.decodeSingularStringField(value: &self.blockHash)
      case 5: try decoder.decodeSingularInt32Field(value: &self.blockHeight)
      case 6: try decoder.decodeSingularInt64Field(value: &self.timeStamp)
      case 7: try decoder.decodeSingularInt64Field(value: &self.totalFees)
      case 8: try decoder.decodeRepeatedStringField(value: &self.destAddresses)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.numConfirmations != 0 {
      try visitor.visitSingularInt32Field(value: self.numConfirmations, fieldNumber: 3)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 4)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 5)
    }
    if self.timeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timeStamp, fieldNumber: 6)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 7)
    }
    if !self.destAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destAddresses, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Transaction) -> Bool {
    if self.txHash != other.txHash {return false}
    if self.amount != other.amount {return false}
    if self.numConfirmations != other.numConfirmations {return false}
    if self.blockHash != other.blockHash {return false}
    if self.blockHeight != other.blockHeight {return false}
    if self.timeStamp != other.timeStamp {return false}
    if self.totalFees != other.totalFees {return false}
    if self.destAddresses != other.destAddresses {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GetTransactionsRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_TransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_TransactionDetails) -> Bool {
    if self.transactions != other.transactions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "dest_string"),
    3: .same(proto: "amt"),
    4: .standard(proto: "payment_hash"),
    5: .standard(proto: "payment_hash_string"),
    6: .standard(proto: "payment_request"),
    7: .standard(proto: "final_cltv_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.dest)
      case 2: try decoder.decodeSingularStringField(value: &self.destString)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amt)
      case 4: try decoder.decodeSingularBytesField(value: &self.paymentHash)
      case 5: try decoder.decodeSingularStringField(value: &self.paymentHashString)
      case 6: try decoder.decodeSingularStringField(value: &self.paymentRequest)
      case 7: try decoder.decodeSingularInt32Field(value: &self.finalCltvDelta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularBytesField(value: self.dest, fieldNumber: 1)
    }
    if !self.destString.isEmpty {
      try visitor.visitSingularStringField(value: self.destString, fieldNumber: 2)
    }
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 3)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 4)
    }
    if !self.paymentHashString.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHashString, fieldNumber: 5)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 6)
    }
    if self.finalCltvDelta != 0 {
      try visitor.visitSingularInt32Field(value: self.finalCltvDelta, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendRequest) -> Bool {
    if self.dest != other.dest {return false}
    if self.destString != other.destString {return false}
    if self.amt != other.amt {return false}
    if self.paymentHash != other.paymentHash {return false}
    if self.paymentHashString != other.paymentHashString {return false}
    if self.paymentRequest != other.paymentRequest {return false}
    if self.finalCltvDelta != other.finalCltvDelta {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment_error"),
    2: .same(proto: "payment_preimage"),
    3: .same(proto: "payment_route"),
  ]

  fileprivate class _StorageClass {
    var _paymentError: String = String()
    var _paymentPreimage: Data = SwiftProtobuf.Internal.emptyData
    var _paymentRoute: Lnrpc_Route? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paymentError = source._paymentError
      _paymentPreimage = source._paymentPreimage
      _paymentRoute = source._paymentRoute
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._paymentError)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._paymentPreimage)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._paymentRoute)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._paymentError.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentError, fieldNumber: 1)
      }
      if !_storage._paymentPreimage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentPreimage, fieldNumber: 2)
      }
      if let v = _storage._paymentRoute {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._paymentError != other_storage._paymentError {return false}
        if _storage._paymentPreimage != other_storage._paymentPreimage {return false}
        if _storage._paymentRoute != other_storage._paymentRoute {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "funding_txid_bytes"),
    2: .same(proto: "funding_txid_str"),
    3: .same(proto: "output_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.fundingTxid != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.fundingTxid = .fundingTxidBytes(v)}
      case 2:
        if self.fundingTxid != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.fundingTxid = .fundingTxidStr(v)}
      case 3: try decoder.decodeSingularUInt32Field(value: &self.outputIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.fundingTxid {
    case .fundingTxidBytes(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    case .fundingTxidStr(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelPoint) -> Bool {
    if self.fundingTxid != other.fundingTxid {return false}
    if self.outputIndex != other.outputIndex {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_LightningAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "host"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.host)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_LightningAddress) -> Bool {
    if self.pubkey != other.pubkey {return false}
    if self.host != other.host {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendManyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AddrToAmount"),
    3: .standard(proto: "target_conf"),
    5: .standard(proto: "sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.addrToAmount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 5: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrToAmount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.addrToAmount, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendManyRequest) -> Bool {
    if self.addrToAmount != other.addrToAmount {return false}
    if self.targetConf != other.targetConf {return false}
    if self.satPerByte != other.satPerByte {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendManyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendManyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendManyResponse) -> Bool {
    if self.txid != other.txid {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCoinsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "amount"),
    3: .standard(proto: "target_conf"),
    5: .standard(proto: "sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.addr)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 5: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendCoinsRequest) -> Bool {
    if self.addr != other.addr {return false}
    if self.amount != other.amount {return false}
    if self.targetConf != other.targetConf {return false}
    if self.satPerByte != other.satPerByte {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SendCoinsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendCoinsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.txid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SendCoinsResponse) -> Bool {
    if self.txid != other.txid {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NewAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .witnessPubkeyHash {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NewAddressRequest) -> Bool {
    if self.type != other.type {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NewAddressRequest.AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WITNESS_PUBKEY_HASH"),
    1: .same(proto: "NESTED_PUBKEY_HASH"),
  ]
}

extension Lnrpc_NewWitnessAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewWitnessAddressRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NewWitnessAddressRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NewAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewAddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NewAddressResponse) -> Bool {
    if self.address != other.address {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SignMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SignMessageRequest) -> Bool {
    if self.msg != other.msg {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_SignMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_SignMessageResponse) -> Bool {
    if self.signature != other.signature {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_VerifyMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.msg)
      case 2: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_VerifyMessageRequest) -> Bool {
    if self.msg != other.msg {return false}
    if self.signature != other.signature {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_VerifyMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.valid)
      case 2: try decoder.decodeSingularStringField(value: &self.pubkey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_VerifyMessageResponse) -> Bool {
    if self.valid != other.valid {return false}
    if self.pubkey != other.pubkey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
    2: .same(proto: "perm"),
  ]

  fileprivate class _StorageClass {
    var _addr: Lnrpc_LightningAddress? = nil
    var _perm: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _addr = source._addr
      _perm = source._perm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._addr)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._perm)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._addr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._perm != false {
        try visitor.visitSingularBoolField(value: _storage._perm, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ConnectPeerRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._addr != other_storage._addr {return false}
        if _storage._perm != other_storage._perm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ConnectPeerResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DisconnectPeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DisconnectPeerRequest) -> Bool {
    if self.pubKey != other.pubKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DisconnectPeerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectPeerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DisconnectPeerResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_HTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .same(proto: "hash_lock"),
    4: .same(proto: "expiration_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.incoming)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularBytesField(value: &self.hashLock)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.expirationHeight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.hashLock.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashLock, fieldNumber: 3)
    }
    if self.expirationHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.expirationHeight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_HTLC) -> Bool {
    if self.incoming != other.incoming {return false}
    if self.amount != other.amount {return false}
    if self.hashLock != other.hashLock {return false}
    if self.expirationHeight != other.expirationHeight {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "remote_pubkey"),
    3: .same(proto: "channel_point"),
    4: .same(proto: "chan_id"),
    5: .same(proto: "capacity"),
    6: .same(proto: "local_balance"),
    7: .same(proto: "remote_balance"),
    8: .same(proto: "commit_fee"),
    9: .same(proto: "commit_weight"),
    10: .same(proto: "fee_per_kw"),
    11: .same(proto: "unsettled_balance"),
    12: .same(proto: "total_satoshis_sent"),
    13: .same(proto: "total_satoshis_received"),
    14: .same(proto: "num_updates"),
    15: .same(proto: "pending_htlcs"),
    16: .same(proto: "csv_delay"),
    17: .same(proto: "private"),
  ]

  fileprivate class _StorageClass {
    var _active: Bool = false
    var _remotePubkey: String = String()
    var _channelPoint: String = String()
    var _chanID: UInt64 = 0
    var _capacity: Int64 = 0
    var _localBalance: Int64 = 0
    var _remoteBalance: Int64 = 0
    var _commitFee: Int64 = 0
    var _commitWeight: Int64 = 0
    var _feePerKw: Int64 = 0
    var _unsettledBalance: Int64 = 0
    var _totalSatoshisSent: Int64 = 0
    var _totalSatoshisReceived: Int64 = 0
    var _numUpdates: UInt64 = 0
    var _pendingHtlcs: [Lnrpc_HTLC] = []
    var _csvDelay: UInt32 = 0
    var _private: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _active = source._active
      _remotePubkey = source._remotePubkey
      _channelPoint = source._channelPoint
      _chanID = source._chanID
      _capacity = source._capacity
      _localBalance = source._localBalance
      _remoteBalance = source._remoteBalance
      _commitFee = source._commitFee
      _commitWeight = source._commitWeight
      _feePerKw = source._feePerKw
      _unsettledBalance = source._unsettledBalance
      _totalSatoshisSent = source._totalSatoshisSent
      _totalSatoshisReceived = source._totalSatoshisReceived
      _numUpdates = source._numUpdates
      _pendingHtlcs = source._pendingHtlcs
      _csvDelay = source._csvDelay
      _private = source._private
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._active)
        case 2: try decoder.decodeSingularStringField(value: &_storage._remotePubkey)
        case 3: try decoder.decodeSingularStringField(value: &_storage._channelPoint)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._localBalance)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._remoteBalance)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._commitFee)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._commitWeight)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._feePerKw)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._unsettledBalance)
        case 12: try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisSent)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._totalSatoshisReceived)
        case 14: try decoder.decodeSingularUInt64Field(value: &_storage._numUpdates)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs)
        case 16: try decoder.decodeSingularUInt32Field(value: &_storage._csvDelay)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._private)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._active != false {
        try visitor.visitSingularBoolField(value: _storage._active, fieldNumber: 1)
      }
      if !_storage._remotePubkey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remotePubkey, fieldNumber: 2)
      }
      if !_storage._channelPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelPoint, fieldNumber: 3)
      }
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 4)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 5)
      }
      if _storage._localBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._localBalance, fieldNumber: 6)
      }
      if _storage._remoteBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remoteBalance, fieldNumber: 7)
      }
      if _storage._commitFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitFee, fieldNumber: 8)
      }
      if _storage._commitWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitWeight, fieldNumber: 9)
      }
      if _storage._feePerKw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerKw, fieldNumber: 10)
      }
      if _storage._unsettledBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unsettledBalance, fieldNumber: 11)
      }
      if _storage._totalSatoshisSent != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisSent, fieldNumber: 12)
      }
      if _storage._totalSatoshisReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalSatoshisReceived, fieldNumber: 13)
      }
      if _storage._numUpdates != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numUpdates, fieldNumber: 14)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 15)
      }
      if _storage._csvDelay != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._csvDelay, fieldNumber: 16)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Channel) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._active != other_storage._active {return false}
        if _storage._remotePubkey != other_storage._remotePubkey {return false}
        if _storage._channelPoint != other_storage._channelPoint {return false}
        if _storage._chanID != other_storage._chanID {return false}
        if _storage._capacity != other_storage._capacity {return false}
        if _storage._localBalance != other_storage._localBalance {return false}
        if _storage._remoteBalance != other_storage._remoteBalance {return false}
        if _storage._commitFee != other_storage._commitFee {return false}
        if _storage._commitWeight != other_storage._commitWeight {return false}
        if _storage._feePerKw != other_storage._feePerKw {return false}
        if _storage._unsettledBalance != other_storage._unsettledBalance {return false}
        if _storage._totalSatoshisSent != other_storage._totalSatoshisSent {return false}
        if _storage._totalSatoshisReceived != other_storage._totalSatoshisReceived {return false}
        if _storage._numUpdates != other_storage._numUpdates {return false}
        if _storage._pendingHtlcs != other_storage._pendingHtlcs {return false}
        if _storage._csvDelay != other_storage._csvDelay {return false}
        if _storage._private != other_storage._private {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_only"),
    2: .standard(proto: "inactive_only"),
    3: .standard(proto: "public_only"),
    4: .standard(proto: "private_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.activeOnly)
      case 2: try decoder.decodeSingularBoolField(value: &self.inactiveOnly)
      case 3: try decoder.decodeSingularBoolField(value: &self.publicOnly)
      case 4: try decoder.decodeSingularBoolField(value: &self.privateOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeOnly != false {
      try visitor.visitSingularBoolField(value: self.activeOnly, fieldNumber: 1)
    }
    if self.inactiveOnly != false {
      try visitor.visitSingularBoolField(value: self.inactiveOnly, fieldNumber: 2)
    }
    if self.publicOnly != false {
      try visitor.visitSingularBoolField(value: self.publicOnly, fieldNumber: 3)
    }
    if self.privateOnly != false {
      try visitor.visitSingularBoolField(value: self.privateOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListChannelsRequest) -> Bool {
    if self.activeOnly != other.activeOnly {return false}
    if self.inactiveOnly != other.inactiveOnly {return false}
    if self.publicOnly != other.publicOnly {return false}
    if self.privateOnly != other.privateOnly {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 11: try decoder.decodeRepeatedMessageField(value: &self.channels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListChannelsResponse) -> Bool {
    if self.channels != other.channels {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Peer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pub_key"),
    3: .same(proto: "address"),
    4: .same(proto: "bytes_sent"),
    5: .same(proto: "bytes_recv"),
    6: .same(proto: "sat_sent"),
    7: .same(proto: "sat_recv"),
    8: .same(proto: "inbound"),
    9: .same(proto: "ping_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 3: try decoder.decodeSingularStringField(value: &self.address)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.bytesSent)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.bytesRecv)
      case 6: try decoder.decodeSingularInt64Field(value: &self.satSent)
      case 7: try decoder.decodeSingularInt64Field(value: &self.satRecv)
      case 8: try decoder.decodeSingularBoolField(value: &self.inbound)
      case 9: try decoder.decodeSingularInt64Field(value: &self.pingTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 4)
    }
    if self.bytesRecv != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesRecv, fieldNumber: 5)
    }
    if self.satSent != 0 {
      try visitor.visitSingularInt64Field(value: self.satSent, fieldNumber: 6)
    }
    if self.satRecv != 0 {
      try visitor.visitSingularInt64Field(value: self.satRecv, fieldNumber: 7)
    }
    if self.inbound != false {
      try visitor.visitSingularBoolField(value: self.inbound, fieldNumber: 8)
    }
    if self.pingTime != 0 {
      try visitor.visitSingularInt64Field(value: self.pingTime, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Peer) -> Bool {
    if self.pubKey != other.pubKey {return false}
    if self.address != other.address {return false}
    if self.bytesSent != other.bytesSent {return false}
    if self.bytesRecv != other.bytesRecv {return false}
    if self.satSent != other.satSent {return false}
    if self.satRecv != other.satRecv {return false}
    if self.inbound != other.inbound {return false}
    if self.pingTime != other.pingTime {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPeersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListPeersRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPeersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPeersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.peers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListPeersResponse) -> Bool {
    if self.peers != other.peers {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GetInfoRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GetInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity_pubkey"),
    2: .same(proto: "alias"),
    3: .same(proto: "num_pending_channels"),
    4: .same(proto: "num_active_channels"),
    5: .same(proto: "num_peers"),
    6: .same(proto: "block_height"),
    8: .same(proto: "block_hash"),
    9: .same(proto: "synced_to_chain"),
    10: .same(proto: "testnet"),
    11: .same(proto: "chains"),
    12: .same(proto: "uris"),
    13: .same(proto: "best_header_timestamp"),
    14: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.identityPubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.alias)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numPendingChannels)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numActiveChannels)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numPeers)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.blockHeight)
      case 8: try decoder.decodeSingularStringField(value: &self.blockHash)
      case 9: try decoder.decodeSingularBoolField(value: &self.syncedToChain)
      case 10: try decoder.decodeSingularBoolField(value: &self.testnet)
      case 11: try decoder.decodeRepeatedStringField(value: &self.chains)
      case 12: try decoder.decodeRepeatedStringField(value: &self.uris)
      case 13: try decoder.decodeSingularInt64Field(value: &self.bestHeaderTimestamp)
      case 14: try decoder.decodeSingularStringField(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identityPubkey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityPubkey, fieldNumber: 1)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 2)
    }
    if self.numPendingChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingChannels, fieldNumber: 3)
    }
    if self.numActiveChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numActiveChannels, fieldNumber: 4)
    }
    if self.numPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPeers, fieldNumber: 5)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockHeight, fieldNumber: 6)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 8)
    }
    if self.syncedToChain != false {
      try visitor.visitSingularBoolField(value: self.syncedToChain, fieldNumber: 9)
    }
    if self.testnet != false {
      try visitor.visitSingularBoolField(value: self.testnet, fieldNumber: 10)
    }
    if !self.chains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.chains, fieldNumber: 11)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 12)
    }
    if self.bestHeaderTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.bestHeaderTimestamp, fieldNumber: 13)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GetInfoResponse) -> Bool {
    if self.identityPubkey != other.identityPubkey {return false}
    if self.alias != other.alias {return false}
    if self.numPendingChannels != other.numPendingChannels {return false}
    if self.numActiveChannels != other.numActiveChannels {return false}
    if self.numPeers != other.numPeers {return false}
    if self.blockHeight != other.blockHeight {return false}
    if self.blockHash != other.blockHash {return false}
    if self.syncedToChain != other.syncedToChain {return false}
    if self.testnet != other.testnet {return false}
    if self.chains != other.chains {return false}
    if self.uris != other.uris {return false}
    if self.bestHeaderTimestamp != other.bestHeaderTimestamp {return false}
    if self.version != other.version {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ConfirmationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmationUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_sha"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "num_confs_left"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.blockSha)
      case 2: try decoder.decodeSingularInt32Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numConfsLeft)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockSha.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockSha, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 2)
    }
    if self.numConfsLeft != 0 {
      try visitor.visitSingularUInt32Field(value: self.numConfsLeft, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ConfirmationUpdate) -> Bool {
    if self.blockSha != other.blockSha {return false}
    if self.blockHeight != other.blockHeight {return false}
    if self.numConfsLeft != other.numConfsLeft {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelOpenUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelOpenUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_point"),
  ]

  fileprivate class _StorageClass {
    var _channelPoint: Lnrpc_ChannelPoint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPoint = source._channelPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channelPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channelPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelOpenUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channelPoint != other_storage._channelPoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelCloseUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelCloseUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closing_txid"),
    2: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.closingTxid)
      case 2: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closingTxid.isEmpty {
      try visitor.visitSingularBytesField(value: self.closingTxid, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelCloseUpdate) -> Bool {
    if self.closingTxid != other.closingTxid {return false}
    if self.success != other.success {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CloseChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_point"),
    2: .same(proto: "force"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_byte"),
  ]

  fileprivate class _StorageClass {
    var _channelPoint: Lnrpc_ChannelPoint? = nil
    var _force: Bool = false
    var _targetConf: Int32 = 0
    var _satPerByte: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPoint = source._channelPoint
      _force = source._force
      _targetConf = source._targetConf
      _satPerByte = source._satPerByte
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channelPoint)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._force)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._targetConf)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._satPerByte)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channelPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._force != false {
        try visitor.visitSingularBoolField(value: _storage._force, fieldNumber: 2)
      }
      if _storage._targetConf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetConf, fieldNumber: 3)
      }
      if _storage._satPerByte != 0 {
        try visitor.visitSingularInt64Field(value: _storage._satPerByte, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_CloseChannelRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channelPoint != other_storage._channelPoint {return false}
        if _storage._force != other_storage._force {return false}
        if _storage._targetConf != other_storage._targetConf {return false}
        if _storage._satPerByte != other_storage._satPerByte {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_CloseStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "close_pending"),
    2: .same(proto: "confirmation"),
    3: .same(proto: "chan_close"),
  ]

  fileprivate class _StorageClass {
    var _update: Lnrpc_CloseStatusUpdate.OneOf_Update?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_PendingUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .closePending(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .closePending(v)}
        case 2:
          var v: Lnrpc_ConfirmationUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .confirmation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .confirmation(v)}
        case 3:
          var v: Lnrpc_ChannelCloseUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .chanClose(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._update {
      case .closePending(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .confirmation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .chanClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_CloseStatusUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._update != other_storage._update {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "output_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txid)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.outputIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.outputIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingUpdate) -> Bool {
    if self.txid != other.txid {return false}
    if self.outputIndex != other.outputIndex {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_OpenChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "node_pubkey"),
    3: .same(proto: "node_pubkey_string"),
    4: .same(proto: "local_funding_amount"),
    5: .same(proto: "push_sat"),
    6: .standard(proto: "target_conf"),
    7: .standard(proto: "sat_per_byte"),
    8: .same(proto: "private"),
    9: .same(proto: "min_htlc_msat"),
    10: .same(proto: "remote_csv_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularBytesField(value: &self.nodePubkey)
      case 3: try decoder.decodeSingularStringField(value: &self.nodePubkeyString)
      case 4: try decoder.decodeSingularInt64Field(value: &self.localFundingAmount)
      case 5: try decoder.decodeSingularInt64Field(value: &self.pushSat)
      case 6: try decoder.decodeSingularInt32Field(value: &self.targetConf)
      case 7: try decoder.decodeSingularInt64Field(value: &self.satPerByte)
      case 8: try decoder.decodeSingularBoolField(value: &self.`private`)
      case 9: try decoder.decodeSingularInt64Field(value: &self.minHtlcMsat)
      case 10: try decoder.decodeSingularUInt32Field(value: &self.remoteCsvDelay)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePubkey, fieldNumber: 2)
    }
    if !self.nodePubkeyString.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePubkeyString, fieldNumber: 3)
    }
    if self.localFundingAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.localFundingAmount, fieldNumber: 4)
    }
    if self.pushSat != 0 {
      try visitor.visitSingularInt64Field(value: self.pushSat, fieldNumber: 5)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConf, fieldNumber: 6)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerByte, fieldNumber: 7)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 8)
    }
    if self.minHtlcMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlcMsat, fieldNumber: 9)
    }
    if self.remoteCsvDelay != 0 {
      try visitor.visitSingularUInt32Field(value: self.remoteCsvDelay, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_OpenChannelRequest) -> Bool {
    if self.nodePubkey != other.nodePubkey {return false}
    if self.nodePubkeyString != other.nodePubkeyString {return false}
    if self.localFundingAmount != other.localFundingAmount {return false}
    if self.pushSat != other.pushSat {return false}
    if self.targetConf != other.targetConf {return false}
    if self.satPerByte != other.satPerByte {return false}
    if self.`private` != other.`private` {return false}
    if self.minHtlcMsat != other.minHtlcMsat {return false}
    if self.remoteCsvDelay != other.remoteCsvDelay {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_OpenStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_pending"),
    2: .same(proto: "confirmation"),
    3: .same(proto: "chan_open"),
  ]

  fileprivate class _StorageClass {
    var _update: Lnrpc_OpenStatusUpdate.OneOf_Update?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _update = source._update
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Lnrpc_PendingUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanPending(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .chanPending(v)}
        case 2:
          var v: Lnrpc_ConfirmationUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .confirmation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .confirmation(v)}
        case 3:
          var v: Lnrpc_ChannelOpenUpdate?
          if let current = _storage._update {
            try decoder.handleConflictingOneOf()
            if case .chanOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._update = .chanOpen(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._update {
      case .chanPending(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .confirmation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .chanOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_OpenStatusUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._update != other_storage._update {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingHTLC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingHTLC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "incoming"),
    2: .same(proto: "amount"),
    3: .same(proto: "outpoint"),
    4: .same(proto: "maturity_height"),
    5: .same(proto: "blocks_til_maturity"),
    6: .same(proto: "stage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.incoming)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularStringField(value: &self.outpoint)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.maturityHeight)
      case 5: try decoder.decodeSingularInt32Field(value: &self.blocksTilMaturity)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.stage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incoming != false {
      try visitor.visitSingularBoolField(value: self.incoming, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if !self.outpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.outpoint, fieldNumber: 3)
    }
    if self.maturityHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.maturityHeight, fieldNumber: 4)
    }
    if self.blocksTilMaturity != 0 {
      try visitor.visitSingularInt32Field(value: self.blocksTilMaturity, fieldNumber: 5)
    }
    if self.stage != 0 {
      try visitor.visitSingularUInt32Field(value: self.stage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingHTLC) -> Bool {
    if self.incoming != other.incoming {return false}
    if self.amount != other.amount {return false}
    if self.outpoint != other.outpoint {return false}
    if self.maturityHeight != other.maturityHeight {return false}
    if self.blocksTilMaturity != other.blocksTilMaturity {return false}
    if self.stage != other.stage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_limbo_balance"),
    2: .same(proto: "pending_open_channels"),
    3: .same(proto: "pending_closing_channels"),
    4: .same(proto: "pending_force_closing_channels"),
    5: .same(proto: "waiting_close_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.totalLimboBalance)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.pendingOpenChannels)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.pendingClosingChannels)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.pendingForceClosingChannels)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.waitingCloseChannels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalLimboBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalLimboBalance, fieldNumber: 1)
    }
    if !self.pendingOpenChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingOpenChannels, fieldNumber: 2)
    }
    if !self.pendingClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingClosingChannels, fieldNumber: 3)
    }
    if !self.pendingForceClosingChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingForceClosingChannels, fieldNumber: 4)
    }
    if !self.waitingCloseChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waitingCloseChannels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse) -> Bool {
    if self.totalLimboBalance != other.totalLimboBalance {return false}
    if self.pendingOpenChannels != other.pendingOpenChannels {return false}
    if self.pendingClosingChannels != other.pendingClosingChannels {return false}
    if self.pendingForceClosingChannels != other.pendingForceClosingChannels {return false}
    if self.waitingCloseChannels != other.waitingCloseChannels {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "remote_node_pub"),
    2: .same(proto: "channel_point"),
    3: .same(proto: "capacity"),
    4: .same(proto: "local_balance"),
    5: .same(proto: "remote_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.remoteNodePub)
      case 2: try decoder.decodeSingularStringField(value: &self.channelPoint)
      case 3: try decoder.decodeSingularInt64Field(value: &self.capacity)
      case 4: try decoder.decodeSingularInt64Field(value: &self.localBalance)
      case 5: try decoder.decodeSingularInt64Field(value: &self.remoteBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.remoteNodePub.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteNodePub, fieldNumber: 1)
    }
    if !self.channelPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPoint, fieldNumber: 2)
    }
    if self.capacity != 0 {
      try visitor.visitSingularInt64Field(value: self.capacity, fieldNumber: 3)
    }
    if self.localBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.localBalance, fieldNumber: 4)
    }
    if self.remoteBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteBalance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse.PendingChannel) -> Bool {
    if self.remoteNodePub != other.remoteNodePub {return false}
    if self.channelPoint != other.channelPoint {return false}
    if self.capacity != other.capacity {return false}
    if self.localBalance != other.localBalance {return false}
    if self.remoteBalance != other.remoteBalance {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.PendingOpenChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".PendingOpenChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "confirmation_height"),
    4: .same(proto: "commit_fee"),
    5: .same(proto: "commit_weight"),
    6: .same(proto: "fee_per_kw"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _confirmationHeight: UInt32 = 0
    var _commitFee: Int64 = 0
    var _commitWeight: Int64 = 0
    var _feePerKw: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _confirmationHeight = source._confirmationHeight
      _commitFee = source._commitFee
      _commitWeight = source._commitWeight
      _feePerKw = source._feePerKw
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._confirmationHeight)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._commitFee)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._commitWeight)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._feePerKw)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._confirmationHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._confirmationHeight, fieldNumber: 2)
      }
      if _storage._commitFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitFee, fieldNumber: 4)
      }
      if _storage._commitWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commitWeight, fieldNumber: 5)
      }
      if _storage._feePerKw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerKw, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse.PendingOpenChannel) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channel != other_storage._channel {return false}
        if _storage._confirmationHeight != other_storage._confirmationHeight {return false}
        if _storage._commitFee != other_storage._commitFee {return false}
        if _storage._commitWeight != other_storage._commitWeight {return false}
        if _storage._feePerKw != other_storage._feePerKw {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.WaitingCloseChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".WaitingCloseChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "limbo_balance"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _limboBalance: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _limboBalance = source._limboBalance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._limboBalance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse.WaitingCloseChannel) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channel != other_storage._channel {return false}
        if _storage._limboBalance != other_storage._limboBalance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "closing_txid"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _closingTxid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _closingTxid = source._closingTxid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularStringField(value: &_storage._closingTxid)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._closingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closingTxid, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse.ClosedChannel) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channel != other_storage._channel {return false}
        if _storage._closingTxid != other_storage._closingTxid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PendingChannelsResponse.ForceClosedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Lnrpc_PendingChannelsResponse.protoMessageName + ".ForceClosedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "closing_txid"),
    3: .same(proto: "limbo_balance"),
    4: .same(proto: "maturity_height"),
    5: .same(proto: "blocks_til_maturity"),
    6: .same(proto: "recovered_balance"),
    8: .same(proto: "pending_htlcs"),
  ]

  fileprivate class _StorageClass {
    var _channel: Lnrpc_PendingChannelsResponse.PendingChannel? = nil
    var _closingTxid: String = String()
    var _limboBalance: Int64 = 0
    var _maturityHeight: UInt32 = 0
    var _blocksTilMaturity: Int32 = 0
    var _recoveredBalance: Int64 = 0
    var _pendingHtlcs: [Lnrpc_PendingHTLC] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _closingTxid = source._closingTxid
      _limboBalance = source._limboBalance
      _maturityHeight = source._maturityHeight
      _blocksTilMaturity = source._blocksTilMaturity
      _recoveredBalance = source._recoveredBalance
      _pendingHtlcs = source._pendingHtlcs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularStringField(value: &_storage._closingTxid)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._limboBalance)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._maturityHeight)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._blocksTilMaturity)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._recoveredBalance)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._pendingHtlcs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._closingTxid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._closingTxid, fieldNumber: 2)
      }
      if _storage._limboBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limboBalance, fieldNumber: 3)
      }
      if _storage._maturityHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maturityHeight, fieldNumber: 4)
      }
      if _storage._blocksTilMaturity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blocksTilMaturity, fieldNumber: 5)
      }
      if _storage._recoveredBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._recoveredBalance, fieldNumber: 6)
      }
      if !_storage._pendingHtlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingHtlcs, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PendingChannelsResponse.ForceClosedChannel) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channel != other_storage._channel {return false}
        if _storage._closingTxid != other_storage._closingTxid {return false}
        if _storage._limboBalance != other_storage._limboBalance {return false}
        if _storage._maturityHeight != other_storage._maturityHeight {return false}
        if _storage._blocksTilMaturity != other_storage._blocksTilMaturity {return false}
        if _storage._recoveredBalance != other_storage._recoveredBalance {return false}
        if _storage._pendingHtlcs != other_storage._pendingHtlcs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WalletBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_WalletBalanceRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_WalletBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WalletBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_balance"),
    2: .same(proto: "confirmed_balance"),
    3: .same(proto: "unconfirmed_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.totalBalance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.confirmedBalance)
      case 3: try decoder.decodeSingularInt64Field(value: &self.unconfirmedBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.totalBalance, fieldNumber: 1)
    }
    if self.confirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.confirmedBalance, fieldNumber: 2)
    }
    if self.unconfirmedBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.unconfirmedBalance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_WalletBalanceResponse) -> Bool {
    if self.totalBalance != other.totalBalance {return false}
    if self.confirmedBalance != other.confirmedBalance {return false}
    if self.unconfirmedBalance != other.unconfirmedBalance {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBalanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelBalanceRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelBalanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelBalanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "pending_open_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.balance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.pendingOpenBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 1)
    }
    if self.pendingOpenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingOpenBalance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelBalanceResponse) -> Bool {
    if self.balance != other.balance {return false}
    if self.pendingOpenBalance != other.pendingOpenBalance {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_QueryRoutesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "amt"),
    3: .standard(proto: "num_routes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amt)
      case 3: try decoder.decodeSingularInt32Field(value: &self.numRoutes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    if self.amt != 0 {
      try visitor.visitSingularInt64Field(value: self.amt, fieldNumber: 2)
    }
    if self.numRoutes != 0 {
      try visitor.visitSingularInt32Field(value: self.numRoutes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_QueryRoutesRequest) -> Bool {
    if self.pubKey != other.pubKey {return false}
    if self.amt != other.amt {return false}
    if self.numRoutes != other.numRoutes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_QueryRoutesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRoutesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.routes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_QueryRoutesResponse) -> Bool {
    if self.routes != other.routes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Hop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chan_id"),
    2: .same(proto: "chan_capacity"),
    3: .same(proto: "amt_to_forward"),
    4: .same(proto: "fee"),
    5: .same(proto: "expiry"),
    6: .same(proto: "amt_to_forward_msat"),
    7: .same(proto: "fee_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.chanCapacity)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amtToForward)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.expiry)
      case 6: try decoder.decodeSingularInt64Field(value: &self.amtToForwardMsat)
      case 7: try decoder.decodeSingularInt64Field(value: &self.feeMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.chanCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.chanCapacity, fieldNumber: 2)
    }
    if self.amtToForward != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForward, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiry, fieldNumber: 5)
    }
    if self.amtToForwardMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtToForwardMsat, fieldNumber: 6)
    }
    if self.feeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeMsat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Hop) -> Bool {
    if self.chanID != other.chanID {return false}
    if self.chanCapacity != other.chanCapacity {return false}
    if self.amtToForward != other.amtToForward {return false}
    if self.fee != other.fee {return false}
    if self.expiry != other.expiry {return false}
    if self.amtToForwardMsat != other.amtToForwardMsat {return false}
    if self.feeMsat != other.feeMsat {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Route"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total_time_lock"),
    2: .same(proto: "total_fees"),
    3: .same(proto: "total_amt"),
    4: .same(proto: "hops"),
    5: .same(proto: "total_fees_msat"),
    6: .same(proto: "total_amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.totalTimeLock)
      case 2: try decoder.decodeSingularInt64Field(value: &self.totalFees)
      case 3: try decoder.decodeSingularInt64Field(value: &self.totalAmt)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.hops)
      case 5: try decoder.decodeSingularInt64Field(value: &self.totalFeesMsat)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalAmtMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalTimeLock != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalTimeLock, fieldNumber: 1)
    }
    if self.totalFees != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFees, fieldNumber: 2)
    }
    if self.totalAmt != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmt, fieldNumber: 3)
    }
    if !self.hops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hops, fieldNumber: 4)
    }
    if self.totalFeesMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFeesMsat, fieldNumber: 5)
    }
    if self.totalAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.totalAmtMsat, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Route) -> Bool {
    if self.totalTimeLock != other.totalTimeLock {return false}
    if self.totalFees != other.totalFees {return false}
    if self.totalAmt != other.totalAmt {return false}
    if self.hops != other.hops {return false}
    if self.totalFeesMsat != other.totalFeesMsat {return false}
    if self.totalAmtMsat != other.totalAmtMsat {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NodeInfoRequest) -> Bool {
    if self.pubKey != other.pubKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "num_channels"),
    3: .same(proto: "total_capacity"),
  ]

  fileprivate class _StorageClass {
    var _node: Lnrpc_LightningNode? = nil
    var _numChannels: UInt32 = 0
    var _totalCapacity: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _node = source._node
      _numChannels = source._numChannels
      _totalCapacity = source._totalCapacity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._node)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._numChannels)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._totalCapacity)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._numChannels != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numChannels, fieldNumber: 2)
      }
      if _storage._totalCapacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalCapacity, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NodeInfo) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._node != other_storage._node {return false}
        if _storage._numChannels != other_storage._numChannels {return false}
        if _storage._totalCapacity != other_storage._totalCapacity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_LightningNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LightningNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "last_update"),
    2: .same(proto: "pub_key"),
    3: .same(proto: "alias"),
    4: .same(proto: "addresses"),
    5: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.lastUpdate)
      case 2: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 3: try decoder.decodeSingularStringField(value: &self.alias)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.addresses)
      case 5: try decoder.decodeSingularStringField(value: &self.color)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastUpdate != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastUpdate, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 2)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 3)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 4)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_LightningNode) -> Bool {
    if self.lastUpdate != other.lastUpdate {return false}
    if self.pubKey != other.pubKey {return false}
    if self.alias != other.alias {return false}
    if self.addresses != other.addresses {return false}
    if self.color != other.color {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.network)
      case 2: try decoder.decodeSingularStringField(value: &self.addr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NodeAddress) -> Bool {
    if self.network != other.network {return false}
    if self.addr != other.addr {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RoutingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoutingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time_lock_delta"),
    2: .same(proto: "min_htlc"),
    3: .same(proto: "fee_base_msat"),
    4: .same(proto: "fee_rate_milli_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.timeLockDelta)
      case 2: try decoder.decodeSingularInt64Field(value: &self.minHtlc)
      case 3: try decoder.decodeSingularInt64Field(value: &self.feeBaseMsat)
      case 4: try decoder.decodeSingularInt64Field(value: &self.feeRateMilliMsat)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeLockDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeLockDelta, fieldNumber: 1)
    }
    if self.minHtlc != 0 {
      try visitor.visitSingularInt64Field(value: self.minHtlc, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeRateMilliMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.feeRateMilliMsat, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_RoutingPolicy) -> Bool {
    if self.timeLockDelta != other.timeLockDelta {return false}
    if self.minHtlc != other.minHtlc {return false}
    if self.feeBaseMsat != other.feeBaseMsat {return false}
    if self.feeRateMilliMsat != other.feeRateMilliMsat {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_id"),
    2: .same(proto: "chan_point"),
    3: .same(proto: "last_update"),
    4: .same(proto: "node1_pub"),
    5: .same(proto: "node2_pub"),
    6: .same(proto: "capacity"),
    7: .same(proto: "node1_policy"),
    8: .same(proto: "node2_policy"),
  ]

  fileprivate class _StorageClass {
    var _channelID: UInt64 = 0
    var _chanPoint: String = String()
    var _lastUpdate: UInt32 = 0
    var _node1Pub: String = String()
    var _node2Pub: String = String()
    var _capacity: Int64 = 0
    var _node1Policy: Lnrpc_RoutingPolicy? = nil
    var _node2Policy: Lnrpc_RoutingPolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _chanPoint = source._chanPoint
      _lastUpdate = source._lastUpdate
      _node1Pub = source._node1Pub
      _node2Pub = source._node2Pub
      _capacity = source._capacity
      _node1Policy = source._node1Policy
      _node2Policy = source._node2Policy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._channelID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._chanPoint)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._lastUpdate)
        case 4: try decoder.decodeSingularStringField(value: &_storage._node1Pub)
        case 5: try decoder.decodeSingularStringField(value: &_storage._node2Pub)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._node1Policy)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._node2Policy)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._chanPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chanPoint, fieldNumber: 2)
      }
      if _storage._lastUpdate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lastUpdate, fieldNumber: 3)
      }
      if !_storage._node1Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node1Pub, fieldNumber: 4)
      }
      if !_storage._node2Pub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._node2Pub, fieldNumber: 5)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 6)
      }
      if let v = _storage._node1Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._node2Policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelEdge) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channelID != other_storage._channelID {return false}
        if _storage._chanPoint != other_storage._chanPoint {return false}
        if _storage._lastUpdate != other_storage._lastUpdate {return false}
        if _storage._node1Pub != other_storage._node1Pub {return false}
        if _storage._node2Pub != other_storage._node2Pub {return false}
        if _storage._capacity != other_storage._capacity {return false}
        if _storage._node1Policy != other_storage._node1Policy {return false}
        if _storage._node2Policy != other_storage._node2Policy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelGraphRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraphRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelGraphRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelGraph"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "edges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.edges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if !self.edges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelGraph) -> Bool {
    if self.nodes != other.nodes {return false}
    if self.edges != other.edges {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChanInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChanInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChanInfoRequest) -> Bool {
    if self.chanID != other.chanID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NetworkInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NetworkInfoRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "graph_diameter"),
    2: .same(proto: "avg_out_degree"),
    3: .same(proto: "max_out_degree"),
    4: .same(proto: "num_nodes"),
    5: .same(proto: "num_channels"),
    6: .same(proto: "total_network_capacity"),
    7: .same(proto: "avg_channel_size"),
    8: .same(proto: "min_channel_size"),
    9: .same(proto: "max_channel_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.graphDiameter)
      case 2: try decoder.decodeSingularDoubleField(value: &self.avgOutDegree)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.maxOutDegree)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numNodes)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numChannels)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalNetworkCapacity)
      case 7: try decoder.decodeSingularDoubleField(value: &self.avgChannelSize)
      case 8: try decoder.decodeSingularInt64Field(value: &self.minChannelSize)
      case 9: try decoder.decodeSingularInt64Field(value: &self.maxChannelSize)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.graphDiameter != 0 {
      try visitor.visitSingularUInt32Field(value: self.graphDiameter, fieldNumber: 1)
    }
    if self.avgOutDegree != 0 {
      try visitor.visitSingularDoubleField(value: self.avgOutDegree, fieldNumber: 2)
    }
    if self.maxOutDegree != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxOutDegree, fieldNumber: 3)
    }
    if self.numNodes != 0 {
      try visitor.visitSingularUInt32Field(value: self.numNodes, fieldNumber: 4)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numChannels, fieldNumber: 5)
    }
    if self.totalNetworkCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNetworkCapacity, fieldNumber: 6)
    }
    if self.avgChannelSize != 0 {
      try visitor.visitSingularDoubleField(value: self.avgChannelSize, fieldNumber: 7)
    }
    if self.minChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.minChannelSize, fieldNumber: 8)
    }
    if self.maxChannelSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxChannelSize, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NetworkInfo) -> Bool {
    if self.graphDiameter != other.graphDiameter {return false}
    if self.avgOutDegree != other.avgOutDegree {return false}
    if self.maxOutDegree != other.maxOutDegree {return false}
    if self.numNodes != other.numNodes {return false}
    if self.numChannels != other.numChannels {return false}
    if self.totalNetworkCapacity != other.totalNetworkCapacity {return false}
    if self.avgChannelSize != other.avgChannelSize {return false}
    if self.minChannelSize != other.minChannelSize {return false}
    if self.maxChannelSize != other.maxChannelSize {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_StopRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_StopResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GraphTopologySubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologySubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GraphTopologySubscription) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_GraphTopologyUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GraphTopologyUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_updates"),
    2: .standard(proto: "channel_updates"),
    3: .standard(proto: "closed_chans"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeUpdates)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.channelUpdates)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.closedChans)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeUpdates, fieldNumber: 1)
    }
    if !self.channelUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelUpdates, fieldNumber: 2)
    }
    if !self.closedChans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closedChans, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_GraphTopologyUpdate) -> Bool {
    if self.nodeUpdates != other.nodeUpdates {return false}
    if self.channelUpdates != other.channelUpdates {return false}
    if self.closedChans != other.closedChans {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .standard(proto: "identity_key"),
    3: .standard(proto: "global_features"),
    4: .same(proto: "alias"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.addresses)
      case 2: try decoder.decodeSingularStringField(value: &self.identityKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.globalFeatures)
      case 4: try decoder.decodeSingularStringField(value: &self.alias)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.identityKey, fieldNumber: 2)
    }
    if !self.globalFeatures.isEmpty {
      try visitor.visitSingularBytesField(value: self.globalFeatures, fieldNumber: 3)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_NodeUpdate) -> Bool {
    if self.addresses != other.addresses {return false}
    if self.identityKey != other.identityKey {return false}
    if self.globalFeatures != other.globalFeatures {return false}
    if self.alias != other.alias {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelEdgeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelEdgeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "chan_point"),
    3: .same(proto: "capacity"),
    4: .standard(proto: "routing_policy"),
    5: .standard(proto: "advertising_node"),
    6: .standard(proto: "connecting_node"),
  ]

  fileprivate class _StorageClass {
    var _chanID: UInt64 = 0
    var _chanPoint: Lnrpc_ChannelPoint? = nil
    var _capacity: Int64 = 0
    var _routingPolicy: Lnrpc_RoutingPolicy? = nil
    var _advertisingNode: String = String()
    var _connectingNode: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanID = source._chanID
      _chanPoint = source._chanPoint
      _capacity = source._capacity
      _routingPolicy = source._routingPolicy
      _advertisingNode = source._advertisingNode
      _connectingNode = source._connectingNode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._routingPolicy)
        case 5: try decoder.decodeSingularStringField(value: &_storage._advertisingNode)
        case 6: try decoder.decodeSingularStringField(value: &_storage._connectingNode)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 1)
      }
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 3)
      }
      if let v = _storage._routingPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._advertisingNode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._advertisingNode, fieldNumber: 5)
      }
      if !_storage._connectingNode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectingNode, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelEdgeUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._chanID != other_storage._chanID {return false}
        if _storage._chanPoint != other_storage._chanPoint {return false}
        if _storage._capacity != other_storage._capacity {return false}
        if _storage._routingPolicy != other_storage._routingPolicy {return false}
        if _storage._advertisingNode != other_storage._advertisingNode {return false}
        if _storage._connectingNode != other_storage._connectingNode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ClosedChannelUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedChannelUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .same(proto: "capacity"),
    3: .standard(proto: "closed_height"),
    4: .standard(proto: "chan_point"),
  ]

  fileprivate class _StorageClass {
    var _chanID: UInt64 = 0
    var _capacity: Int64 = 0
    var _closedHeight: UInt32 = 0
    var _chanPoint: Lnrpc_ChannelPoint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chanID = source._chanID
      _capacity = source._capacity
      _closedHeight = source._closedHeight
      _chanPoint = source._chanPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._chanID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._capacity)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._closedHeight)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._chanPoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._chanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chanID, fieldNumber: 1)
      }
      if _storage._capacity != 0 {
        try visitor.visitSingularInt64Field(value: _storage._capacity, fieldNumber: 2)
      }
      if _storage._closedHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._closedHeight, fieldNumber: 3)
      }
      if let v = _storage._chanPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ClosedChannelUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._chanID != other_storage._chanID {return false}
        if _storage._capacity != other_storage._capacity {return false}
        if _storage._closedHeight != other_storage._closedHeight {return false}
        if _storage._chanPoint != other_storage._chanPoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_HopHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HopHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node_id"),
    2: .same(proto: "chan_id"),
    3: .same(proto: "fee_base_msat"),
    4: .same(proto: "fee_proportional_millionths"),
    5: .same(proto: "cltv_expiry_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nodeID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.chanID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.feeBaseMsat)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.feeProportionalMillionths)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.cltvExpiryDelta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 2)
    }
    if self.feeBaseMsat != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeBaseMsat, fieldNumber: 3)
    }
    if self.feeProportionalMillionths != 0 {
      try visitor.visitSingularUInt32Field(value: self.feeProportionalMillionths, fieldNumber: 4)
    }
    if self.cltvExpiryDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.cltvExpiryDelta, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_HopHint) -> Bool {
    if self.nodeID != other.nodeID {return false}
    if self.chanID != other.chanID {return false}
    if self.feeBaseMsat != other.feeBaseMsat {return false}
    if self.feeProportionalMillionths != other.feeProportionalMillionths {return false}
    if self.cltvExpiryDelta != other.cltvExpiryDelta {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_RouteHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteHint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hop_hints"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.hopHints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hopHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hopHints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_RouteHint) -> Bool {
    if self.hopHints != other.hopHints {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Invoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invoice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memo"),
    2: .same(proto: "receipt"),
    3: .same(proto: "r_preimage"),
    4: .same(proto: "r_hash"),
    5: .same(proto: "value"),
    6: .same(proto: "settled"),
    7: .same(proto: "creation_date"),
    8: .same(proto: "settle_date"),
    9: .same(proto: "payment_request"),
    10: .same(proto: "description_hash"),
    11: .same(proto: "expiry"),
    12: .same(proto: "fallback_addr"),
    13: .same(proto: "cltv_expiry"),
    14: .same(proto: "route_hints"),
    15: .same(proto: "private"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.memo)
      case 2: try decoder.decodeSingularBytesField(value: &self.receipt)
      case 3: try decoder.decodeSingularBytesField(value: &self.rPreimage)
      case 4: try decoder.decodeSingularBytesField(value: &self.rHash)
      case 5: try decoder.decodeSingularInt64Field(value: &self.value)
      case 6: try decoder.decodeSingularBoolField(value: &self.settled)
      case 7: try decoder.decodeSingularInt64Field(value: &self.creationDate)
      case 8: try decoder.decodeSingularInt64Field(value: &self.settleDate)
      case 9: try decoder.decodeSingularStringField(value: &self.paymentRequest)
      case 10: try decoder.decodeSingularBytesField(value: &self.descriptionHash)
      case 11: try decoder.decodeSingularInt64Field(value: &self.expiry)
      case 12: try decoder.decodeSingularStringField(value: &self.fallbackAddr)
      case 13: try decoder.decodeSingularUInt64Field(value: &self.cltvExpiry)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.routeHints)
      case 15: try decoder.decodeSingularBoolField(value: &self.`private`)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 1)
    }
    if !self.receipt.isEmpty {
      try visitor.visitSingularBytesField(value: self.receipt, fieldNumber: 2)
    }
    if !self.rPreimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.rPreimage, fieldNumber: 3)
    }
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 5)
    }
    if self.settled != false {
      try visitor.visitSingularBoolField(value: self.settled, fieldNumber: 6)
    }
    if self.creationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.creationDate, fieldNumber: 7)
    }
    if self.settleDate != 0 {
      try visitor.visitSingularInt64Field(value: self.settleDate, fieldNumber: 8)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 9)
    }
    if !self.descriptionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.descriptionHash, fieldNumber: 10)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 11)
    }
    if !self.fallbackAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackAddr, fieldNumber: 12)
    }
    if self.cltvExpiry != 0 {
      try visitor.visitSingularUInt64Field(value: self.cltvExpiry, fieldNumber: 13)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 14)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Invoice) -> Bool {
    if self.memo != other.memo {return false}
    if self.receipt != other.receipt {return false}
    if self.rPreimage != other.rPreimage {return false}
    if self.rHash != other.rHash {return false}
    if self.value != other.value {return false}
    if self.settled != other.settled {return false}
    if self.creationDate != other.creationDate {return false}
    if self.settleDate != other.settleDate {return false}
    if self.paymentRequest != other.paymentRequest {return false}
    if self.descriptionHash != other.descriptionHash {return false}
    if self.expiry != other.expiry {return false}
    if self.fallbackAddr != other.fallbackAddr {return false}
    if self.cltvExpiry != other.cltvExpiry {return false}
    if self.routeHints != other.routeHints {return false}
    if self.`private` != other.`private` {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_AddInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r_hash"),
    2: .same(proto: "payment_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.rHash)
      case 2: try decoder.decodeSingularStringField(value: &self.paymentRequest)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 1)
    }
    if !self.paymentRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentRequest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_AddInvoiceResponse) -> Bool {
    if self.rHash != other.rHash {return false}
    if self.paymentRequest != other.paymentRequest {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PaymentHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r_hash_str"),
    2: .same(proto: "r_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.rHashStr)
      case 2: try decoder.decodeSingularBytesField(value: &self.rHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rHashStr.isEmpty {
      try visitor.visitSingularStringField(value: self.rHashStr, fieldNumber: 1)
    }
    if !self.rHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.rHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PaymentHash) -> Bool {
    if self.rHashStr != other.rHashStr {return false}
    if self.rHash != other.rHash {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListInvoiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.pendingOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pendingOnly != false {
      try visitor.visitSingularBoolField(value: self.pendingOnly, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListInvoiceRequest) -> Bool {
    if self.pendingOnly != other.pendingOnly {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListInvoiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListInvoiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.invoices)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invoices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListInvoiceResponse) -> Bool {
    if self.invoices != other.invoices {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_InvoiceSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvoiceSubscription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_InvoiceSubscription) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment_hash"),
    2: .same(proto: "value"),
    3: .same(proto: "creation_date"),
    4: .same(proto: "path"),
    5: .same(proto: "fee"),
    6: .same(proto: "payment_preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.paymentHash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      case 3: try decoder.decodeSingularInt64Field(value: &self.creationDate)
      case 4: try decoder.decodeRepeatedStringField(value: &self.path)
      case 5: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 6: try decoder.decodeSingularStringField(value: &self.paymentPreimage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if self.creationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.creationDate, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedStringField(value: self.path, fieldNumber: 4)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 5)
    }
    if !self.paymentPreimage.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentPreimage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_Payment) -> Bool {
    if self.paymentHash != other.paymentHash {return false}
    if self.value != other.value {return false}
    if self.creationDate != other.creationDate {return false}
    if self.path != other.path {return false}
    if self.fee != other.fee {return false}
    if self.paymentPreimage != other.paymentPreimage {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListPaymentsRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ListPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.payments)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ListPaymentsResponse) -> Bool {
    if self.payments != other.payments {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DeleteAllPaymentsRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DeleteAllPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllPaymentsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DeleteAllPaymentsResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DebugLevelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show"),
    2: .standard(proto: "level_spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.show)
      case 2: try decoder.decodeSingularStringField(value: &self.levelSpec)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.show != false {
      try visitor.visitSingularBoolField(value: self.show, fieldNumber: 1)
    }
    if !self.levelSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.levelSpec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DebugLevelRequest) -> Bool {
    if self.show != other.show {return false}
    if self.levelSpec != other.levelSpec {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_DebugLevelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLevelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sub_systems"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subSystems)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subSystems.isEmpty {
      try visitor.visitSingularStringField(value: self.subSystems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_DebugLevelResponse) -> Bool {
    if self.subSystems != other.subSystems {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PayReqString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReqString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pay_req"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.payReq)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payReq.isEmpty {
      try visitor.visitSingularStringField(value: self.payReq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PayReqString) -> Bool {
    if self.payReq != other.payReq {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PayReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "payment_hash"),
    3: .same(proto: "num_satoshis"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "expiry"),
    6: .same(proto: "description"),
    7: .same(proto: "description_hash"),
    8: .same(proto: "fallback_addr"),
    9: .same(proto: "cltv_expiry"),
    10: .same(proto: "route_hints"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.destination)
      case 2: try decoder.decodeSingularStringField(value: &self.paymentHash)
      case 3: try decoder.decodeSingularInt64Field(value: &self.numSatoshis)
      case 4: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 5: try decoder.decodeSingularInt64Field(value: &self.expiry)
      case 6: try decoder.decodeSingularStringField(value: &self.description_p)
      case 7: try decoder.decodeSingularStringField(value: &self.descriptionHash)
      case 8: try decoder.decodeSingularStringField(value: &self.fallbackAddr)
      case 9: try decoder.decodeSingularInt64Field(value: &self.cltvExpiry)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.routeHints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentHash, fieldNumber: 2)
    }
    if self.numSatoshis != 0 {
      try visitor.visitSingularInt64Field(value: self.numSatoshis, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.expiry != 0 {
      try visitor.visitSingularInt64Field(value: self.expiry, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.descriptionHash.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptionHash, fieldNumber: 7)
    }
    if !self.fallbackAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackAddr, fieldNumber: 8)
    }
    if self.cltvExpiry != 0 {
      try visitor.visitSingularInt64Field(value: self.cltvExpiry, fieldNumber: 9)
    }
    if !self.routeHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeHints, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PayReq) -> Bool {
    if self.destination != other.destination {return false}
    if self.paymentHash != other.paymentHash {return false}
    if self.numSatoshis != other.numSatoshis {return false}
    if self.timestamp != other.timestamp {return false}
    if self.expiry != other.expiry {return false}
    if self.description_p != other.description_p {return false}
    if self.descriptionHash != other.descriptionHash {return false}
    if self.fallbackAddr != other.fallbackAddr {return false}
    if self.cltvExpiry != other.cltvExpiry {return false}
    if self.routeHints != other.routeHints {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FeeReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_FeeReportRequest) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ChannelFeeReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelFeeReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chan_point", json: "channel_point"),
    2: .same(proto: "base_fee_msat"),
    3: .same(proto: "fee_per_mil"),
    4: .same(proto: "fee_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chanPoint)
      case 2: try decoder.decodeSingularInt64Field(value: &self.baseFeeMsat)
      case 3: try decoder.decodeSingularInt64Field(value: &self.feePerMil)
      case 4: try decoder.decodeSingularDoubleField(value: &self.feeRate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chanPoint.isEmpty {
      try visitor.visitSingularStringField(value: self.chanPoint, fieldNumber: 1)
    }
    if self.baseFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.baseFeeMsat, fieldNumber: 2)
    }
    if self.feePerMil != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerMil, fieldNumber: 3)
    }
    if self.feeRate != 0 {
      try visitor.visitSingularDoubleField(value: self.feeRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ChannelFeeReport) -> Bool {
    if self.chanPoint != other.chanPoint {return false}
    if self.baseFeeMsat != other.baseFeeMsat {return false}
    if self.feePerMil != other.feePerMil {return false}
    if self.feeRate != other.feeRate {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_FeeReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeeReportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel_fees"),
    2: .same(proto: "day_fee_sum"),
    3: .same(proto: "week_fee_sum"),
    4: .same(proto: "month_fee_sum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.channelFees)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.dayFeeSum)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.weekFeeSum)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.monthFeeSum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelFees, fieldNumber: 1)
    }
    if self.dayFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.dayFeeSum, fieldNumber: 2)
    }
    if self.weekFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.weekFeeSum, fieldNumber: 3)
    }
    if self.monthFeeSum != 0 {
      try visitor.visitSingularUInt64Field(value: self.monthFeeSum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_FeeReportResponse) -> Bool {
    if self.channelFees != other.channelFees {return false}
    if self.dayFeeSum != other.dayFeeSum {return false}
    if self.weekFeeSum != other.weekFeeSum {return false}
    if self.monthFeeSum != other.monthFeeSum {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PolicyUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "global"),
    2: .same(proto: "chan_point"),
    3: .same(proto: "base_fee_msat"),
    4: .same(proto: "fee_rate"),
    5: .same(proto: "time_lock_delta"),
  ]

  fileprivate class _StorageClass {
    var _scope: Lnrpc_PolicyUpdateRequest.OneOf_Scope?
    var _baseFeeMsat: Int64 = 0
    var _feeRate: Double = 0
    var _timeLockDelta: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _baseFeeMsat = source._baseFeeMsat
      _feeRate = source._feeRate
      _timeLockDelta = source._timeLockDelta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._scope != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._scope = .global(v)}
        case 2:
          var v: Lnrpc_ChannelPoint?
          if let current = _storage._scope {
            try decoder.handleConflictingOneOf()
            if case .chanPoint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scope = .chanPoint(v)}
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._baseFeeMsat)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._feeRate)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._timeLockDelta)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._scope {
      case .global(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      case .chanPoint(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if _storage._baseFeeMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._baseFeeMsat, fieldNumber: 3)
      }
      if _storage._feeRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._feeRate, fieldNumber: 4)
      }
      if _storage._timeLockDelta != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._timeLockDelta, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PolicyUpdateRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._scope != other_storage._scope {return false}
        if _storage._baseFeeMsat != other_storage._baseFeeMsat {return false}
        if _storage._feeRate != other_storage._feeRate {return false}
        if _storage._timeLockDelta != other_storage._timeLockDelta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_PolicyUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyUpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_PolicyUpdateResponse) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start_time"),
    2: .same(proto: "end_time"),
    3: .same(proto: "index_offset"),
    4: .same(proto: "num_max_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.startTime)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.endTime)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.indexOffset)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numMaxEvents)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 2)
    }
    if self.indexOffset != 0 {
      try visitor.visitSingularUInt32Field(value: self.indexOffset, fieldNumber: 3)
    }
    if self.numMaxEvents != 0 {
      try visitor.visitSingularUInt32Field(value: self.numMaxEvents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ForwardingHistoryRequest) -> Bool {
    if self.startTime != other.startTime {return false}
    if self.endTime != other.endTime {return false}
    if self.indexOffset != other.indexOffset {return false}
    if self.numMaxEvents != other.numMaxEvents {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "chan_id_in"),
    4: .same(proto: "chan_id_out"),
    5: .same(proto: "amt_in"),
    6: .same(proto: "amt_out"),
    7: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.chanIDIn)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.chanIDOut)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.amtIn)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.amtOut)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.fee)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.chanIDIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDIn, fieldNumber: 2)
    }
    if self.chanIDOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanIDOut, fieldNumber: 4)
    }
    if self.amtIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtIn, fieldNumber: 5)
    }
    if self.amtOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.amtOut, fieldNumber: 6)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ForwardingEvent) -> Bool {
    if self.timestamp != other.timestamp {return false}
    if self.chanIDIn != other.chanIDIn {return false}
    if self.chanIDOut != other.chanIDOut {return false}
    if self.amtIn != other.amtIn {return false}
    if self.amtOut != other.amtOut {return false}
    if self.fee != other.fee {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Lnrpc_ForwardingHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardingHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forwarding_events"),
    2: .same(proto: "last_offset_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.forwardingEvents)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.lastOffsetIndex)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forwardingEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwardingEvents, fieldNumber: 1)
    }
    if self.lastOffsetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastOffsetIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Lnrpc_ForwardingHistoryResponse) -> Bool {
    if self.forwardingEvents != other.forwardingEvents {return false}
    if self.lastOffsetIndex != other.lastOffsetIndex {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
